// Code generated from huloParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package generated // huloParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type huloParser struct {
	*antlr.BaseParser
}

var HuloParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func huloparserParserInit() {
	staticData := &HuloParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'mod'", "'use'", "'import'", "'from'", "'type'", "'typeof'", "'as'",
		"'if'", "'else'", "'match'", "'do'", "'loop'", "'in'", "'of'", "'range'",
		"'continue'", "'break'", "'let'", "'var'", "'const'", "'static'", "'final'",
		"'pub'", "'required'", "'try'", "'catch'", "'finally'", "'throw'", "'throws'",
		"'fn'", "'operator'", "'return'", "'enum'", "'class'", "'trait'", "'impl'",
		"'for'", "'this'", "'super'", "'extend'", "'declare'", "'defer'", "'comptime'",
		"'when'", "'unsafe'", "'extern'", "'.'", "'..'", "','", "'('", "')'",
		"'['", "']'", "'{'", "'}'", "'**'", "'*'", "'%'", "'/'", "'+'", "'-'",
		"'#'", "'@'", "'?'", "'$'", "'\\'", "'_'", "'='", "'+='", "'-='", "'*='",
		"'**='", "'/='", "'%='", "'&&='", "'<'", "'>'", "'<='", "'>='", "'!='",
		"'=='", "'<<'", "'>>'", "'->'", "'<-'", "'=>'", "'...'", "':'", "'::'",
		"':='", "';'", "'&&'", "'||'", "'!'", "'++'", "'--'", "'---'", "'&'",
		"'|'", "'^'", "'''", "'\"'", "'\"\"\"'", "'new'", "'delete'", "'null'",
		"'num'", "'str'", "'bool'", "'any'", "'void'",
	}
	staticData.SymbolicNames = []string{
		"", "MOD_LIT", "USE", "IMPORT", "FROM", "TYPE", "TYPEOF", "AS", "IF",
		"ELSE", "MATCH", "DO", "LOOP", "IN", "OF", "RANGE", "CONTINUE", "BREAK",
		"LET", "VAR", "CONST", "STATIC", "FINAL", "PUB", "REQUIRED", "TRY",
		"CATCH", "FINALLY", "THROW", "THROWS", "FN", "OPERATOR", "RETURN", "ENUM",
		"CLASS", "TRAIT", "IMPL", "FOR", "THIS", "SUPER", "EXTEND", "DECLARE",
		"DEFER", "COMPTIME", "WHEN", "UNSAFE", "EXTERN", "DOT", "DOUBLE_DOT",
		"COMMA", "LPAREN", "RPAREN", "LBRACK", "RBRACK", "LBRACE", "RBRACE",
		"EXP", "MUL", "MOD", "DIV", "ADD", "SUB", "HASH", "AT", "QUEST", "DOLLAR",
		"BACKSLASH", "WILDCARD", "ASSIGN", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN",
		"EXP_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "LT", "GT",
		"LE", "GE", "NEQ", "EQ", "SHL", "SHR", "ARROW", "BACKARROW", "DOUBLE_ARROW",
		"ELLIPSIS", "COLON", "DOUBLE_COLON", "COLON_ASSIGN", "SEMI", "AND",
		"OR", "NOT", "INC", "DEC", "TRIPLE_MINUS", "BITAND", "BITOR", "BITXOR",
		"SINGLE_QUOTE", "QUOTE", "TRIPLE_QUOTE", "NEW", "DELETE", "NULL", "NUM",
		"STR", "BOOL", "ANY", "VOID", "UnsafeLiteral", "NumberLiteral", "StringLiteral",
		"BoolLiteral", "RawStringLiteral", "FileStringLiteral", "CommandStringLiteral",
		"ESC", "LineComment", "BlockComment", "Identifier", "WS",
	}
	staticData.RuleNames = []string{
		"file", "block", "comment", "statement", "assignStatement", "lambdaAssignStatement",
		"variableNullableExpressions", "variableNullableExpression", "variableNames",
		"variableNameList", "conditionalExpression", "conditionalBoolExpression",
		"logicalExpression", "shiftExpression", "addSubExpression", "mulDivExpression",
		"incDecExpression", "preIncDecExpression", "postIncDecExpression", "factor",
		"tripleExpression", "listExpression", "newDelExpression", "mapExpression",
		"pair", "variableExpression", "methodExpression", "expression", "expressionList",
		"memberAccess", "fileExpression", "callExpression", "callExpressionLinkedList",
		"memberAccessPoint", "literal", "receiverArgumentList", "namedArgumentList",
		"namedArgument", "variableName", "rangeExpression", "expressionStatement",
		"option", "shortOption", "longOption", "commandExpression", "commandArgument",
		"builtinCommandArgument", "commandJoin", "commandStream", "commandAccessPoint",
		"receiverParameters", "receiverParameterList", "receiverParameter",
		"namedParameters", "namedParameterList", "namedParameter", "returnStatement",
		"functionDeclaration", "operatorIdentifier", "standardFunctionDeclaration",
		"functionReturnValue", "lambdaFunctionDeclaration", "lambdaExpression",
		"lambdaBody", "functionSignature", "functionModifier", "macroStatement",
		"classDeclaration", "classModifier", "classSuper", "classBody", "classMember",
		"classMemberModifier", "classMethod", "classMethodModifier", "classBuiltinMethod",
		"classBuiltinMethodModifier", "classBuiltinParameters", "classNamedParameters",
		"classNamedParameterList", "classNamedParameter", "classNamedParameterAccessPoint",
		"classInitializeExpression", "enumDeclaration", "enumModifier", "enumBodySimple",
		"enumBodyAssociated", "enumBodyADT", "enumValue", "enumAssociatedFields",
		"enumAssociatedField", "enumFieldModifier", "enumField", "enumAssociatedValues",
		"enumAssociatedValue", "enumAssociatedConstructor", "enumConstructor",
		"enumConstructorName", "enumConstructorParameters", "enumConstructorDirectInit",
		"enumConstructorInit", "enumAssociatedMethods", "enumVariant", "enumMethods",
		"enumMethod", "enumMethodModifier", "enumMember", "enumMemberModifier",
		"enumBuiltinMethodModifier", "enumInitialize", "enumInitializeMember",
		"traitDeclaration", "traitModifier", "traitBody", "traitMember", "traitMemberModifier",
		"implDeclaration", "implDeclarationBinding", "implDeclarationBody",
		"extendDeclaration", "extendEnum", "extendClass", "extendTrait", "extendType",
		"extendMod", "importDeclaration", "importSingle", "importAll", "importMulti",
		"asIdentifier", "identifierAsIdentifier", "moduleDeclaration", "moduleStatement",
		"useDeclaration", "useSingle", "useMulti", "useAll", "typeDeclaration",
		"genericArguments", "genericParameters", "genericParameterList", "genericParameter",
		"compositeType", "type", "typeLiteral", "nullableType", "unionType",
		"intersectionType", "arrayType", "typeAccessPoint", "typeList", "typeofExpression",
		"asExpression", "objectType", "objectTypeMember", "tupleType", "functionType",
		"tryStatement", "catchClause", "catchClauseReceiver", "finallyClause",
		"throwStatement", "breakStatement", "continueStatement", "ifStatement",
		"matchStatement", "matchCaseClause", "matchEnum", "matchEnumMember",
		"matchTriple", "matchTripleValue", "matchCaseBody", "matchDefaultClause",
		"loopStatement", "loopLabel", "foreachStatement", "foreachClause", "foreachVariableName",
		"forStatement", "forClause", "rangeStatement", "rangeClause", "doWhileStatement",
		"whileStatement", "deferStatement", "declareStatement", "channelInputStatement",
		"channelOutputExpression", "unsafeExpression", "comptimeExpression",
		"comptimeCaseClause", "comptimeDefaultClause", "externDeclaration",
		"externList", "externItem",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 123, 2084, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 1, 0, 1, 0, 5, 0, 393, 8, 0, 10, 0, 12, 0, 396, 9, 0, 5, 0,
		398, 8, 0, 10, 0, 12, 0, 401, 9, 0, 1, 1, 1, 1, 1, 1, 5, 1, 406, 8, 1,
		10, 1, 12, 1, 409, 9, 1, 5, 1, 411, 8, 1, 10, 1, 12, 1, 414, 9, 1, 1, 1,
		1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 447, 8, 3, 1, 4, 1, 4, 1, 4,
		3, 4, 452, 8, 4, 1, 4, 1, 4, 3, 4, 456, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 461,
		8, 4, 3, 4, 463, 8, 4, 1, 4, 1, 4, 3, 4, 467, 8, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 472, 8, 4, 3, 4, 474, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 480, 8, 5,
		1, 6, 1, 6, 1, 6, 5, 6, 485, 8, 6, 10, 6, 12, 6, 488, 9, 6, 1, 7, 1, 7,
		3, 7, 492, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 5, 9, 501, 8,
		9, 10, 9, 12, 9, 504, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 512, 8, 10, 1, 11, 1, 11, 1, 11, 5, 11, 517, 8, 11, 10, 11, 12, 11,
		520, 9, 11, 1, 12, 1, 12, 1, 12, 5, 12, 525, 8, 12, 10, 12, 12, 12, 528,
		9, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 534, 8, 12, 1, 13, 1, 13, 1,
		13, 5, 13, 539, 8, 13, 10, 13, 12, 13, 542, 9, 13, 1, 14, 1, 14, 1, 14,
		5, 14, 547, 8, 14, 10, 14, 12, 14, 550, 9, 14, 1, 15, 1, 15, 1, 15, 5,
		15, 555, 8, 15, 10, 15, 12, 15, 558, 9, 15, 1, 16, 1, 16, 3, 16, 562, 8,
		16, 1, 17, 3, 17, 565, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 3, 18, 571, 8,
		18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 587, 8, 19, 1, 20, 1, 20, 1, 20, 1,
		20, 5, 20, 593, 8, 20, 10, 20, 12, 20, 596, 9, 20, 1, 20, 1, 20, 1, 21,
		1, 21, 1, 21, 1, 21, 5, 21, 604, 8, 21, 10, 21, 12, 21, 607, 9, 21, 1,
		21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 618,
		8, 23, 10, 23, 12, 23, 621, 9, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 636, 8, 26,
		1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 3, 27, 649, 8, 27, 1, 28, 1, 28, 1, 28, 5, 28, 654, 8, 28, 10, 28,
		12, 28, 657, 9, 28, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 663, 8, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 672, 8, 29, 1, 29, 1,
		29, 3, 29, 676, 8, 29, 3, 29, 678, 8, 29, 1, 29, 3, 29, 681, 8, 29, 1,
		30, 1, 30, 3, 30, 685, 8, 30, 1, 31, 1, 31, 3, 31, 689, 8, 31, 1, 31, 1,
		31, 3, 31, 693, 8, 31, 1, 31, 1, 31, 3, 31, 697, 8, 31, 1, 32, 1, 32, 1,
		32, 1, 32, 3, 32, 703, 8, 32, 1, 32, 1, 32, 3, 32, 707, 8, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 3, 32, 713, 8, 32, 1, 32, 1, 32, 3, 32, 717, 8, 32, 3,
		32, 719, 8, 32, 1, 33, 1, 33, 1, 33, 3, 33, 724, 8, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 3, 33, 730, 8, 33, 1, 33, 1, 33, 1, 33, 3, 33, 735, 8, 33, 1,
		33, 1, 33, 1, 33, 3, 33, 740, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33,
		746, 8, 33, 3, 33, 748, 8, 33, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 3, 35,
		755, 8, 35, 1, 35, 3, 35, 758, 8, 35, 1, 36, 1, 36, 1, 36, 5, 36, 763,
		8, 36, 10, 36, 12, 36, 766, 9, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1,
		38, 1, 38, 1, 38, 3, 38, 776, 8, 38, 3, 38, 778, 8, 38, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 40, 1, 40, 1, 41, 1, 41, 3, 41, 788, 8, 41, 1, 42, 1, 42,
		1, 42, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 798, 8, 44, 1, 44, 5,
		44, 801, 8, 44, 10, 44, 12, 44, 804, 9, 44, 1, 44, 3, 44, 807, 8, 44, 1,
		44, 3, 44, 810, 8, 44, 1, 44, 1, 44, 3, 44, 814, 8, 44, 1, 45, 1, 45, 1,
		45, 3, 45, 819, 8, 45, 1, 46, 1, 46, 5, 46, 823, 8, 46, 10, 46, 12, 46,
		826, 9, 46, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1,
		49, 3, 49, 837, 8, 49, 1, 49, 1, 49, 1, 49, 3, 49, 842, 8, 49, 3, 49, 844,
		8, 49, 1, 50, 1, 50, 3, 50, 848, 8, 50, 1, 50, 1, 50, 1, 50, 3, 50, 853,
		8, 50, 1, 50, 3, 50, 856, 8, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 5,
		51, 863, 8, 51, 10, 51, 12, 51, 866, 9, 51, 1, 52, 5, 52, 869, 8, 52, 10,
		52, 12, 52, 872, 9, 52, 1, 52, 3, 52, 875, 8, 52, 1, 52, 1, 52, 3, 52,
		879, 8, 52, 1, 52, 1, 52, 3, 52, 883, 8, 52, 1, 52, 1, 52, 3, 52, 887,
		8, 52, 1, 53, 1, 53, 3, 53, 891, 8, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1,
		54, 5, 54, 898, 8, 54, 10, 54, 12, 54, 901, 9, 54, 1, 55, 3, 55, 904, 8,
		55, 1, 55, 1, 55, 1, 56, 1, 56, 3, 56, 910, 8, 56, 1, 57, 1, 57, 1, 57,
		3, 57, 915, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 932, 8, 58,
		1, 59, 5, 59, 935, 8, 59, 10, 59, 12, 59, 938, 9, 59, 1, 59, 1, 59, 1,
		59, 3, 59, 943, 8, 59, 1, 59, 3, 59, 946, 8, 59, 1, 59, 1, 59, 3, 59, 950,
		8, 59, 1, 59, 1, 59, 3, 59, 954, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 3, 60, 963, 8, 60, 1, 61, 5, 61, 966, 8, 61, 10, 61,
		12, 61, 969, 9, 61, 1, 61, 1, 61, 1, 61, 3, 61, 974, 8, 61, 1, 61, 3, 61,
		977, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 1, 63, 3, 63, 991, 8, 63, 1, 64, 5, 64, 994, 8, 64, 10,
		64, 12, 64, 997, 9, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1002, 8, 64, 1, 64,
		3, 64, 1005, 8, 64, 1, 64, 1, 64, 3, 64, 1009, 8, 64, 1, 64, 1, 64, 3,
		64, 1013, 8, 64, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1021,
		8, 66, 1, 66, 3, 66, 1024, 8, 66, 1, 67, 5, 67, 1027, 8, 67, 10, 67, 12,
		67, 1030, 9, 67, 1, 67, 5, 67, 1033, 8, 67, 10, 67, 12, 67, 1036, 9, 67,
		1, 67, 1, 67, 1, 67, 3, 67, 1041, 8, 67, 1, 67, 1, 67, 3, 67, 1045, 8,
		67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 5, 69, 1054, 8, 69,
		10, 69, 12, 69, 1057, 9, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70,
		1064, 8, 70, 1, 70, 5, 70, 1067, 8, 70, 10, 70, 12, 70, 1070, 9, 70, 5,
		70, 1072, 8, 70, 10, 70, 12, 70, 1075, 9, 70, 1, 70, 1, 70, 1, 71, 5, 71,
		1080, 8, 71, 10, 71, 12, 71, 1083, 9, 71, 1, 71, 5, 71, 1086, 8, 71, 10,
		71, 12, 71, 1089, 9, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1096,
		8, 71, 1, 72, 1, 72, 1, 73, 5, 73, 1101, 8, 73, 10, 73, 12, 73, 1104, 9,
		73, 1, 73, 5, 73, 1107, 8, 73, 10, 73, 12, 73, 1110, 9, 73, 1, 73, 1, 73,
		3, 73, 1114, 8, 73, 1, 74, 1, 74, 1, 75, 5, 75, 1119, 8, 75, 10, 75, 12,
		75, 1122, 9, 75, 1, 75, 3, 75, 1125, 8, 75, 1, 75, 1, 75, 1, 75, 3, 75,
		1130, 8, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1135, 8, 75, 1, 76, 1, 76, 1,
		77, 1, 77, 3, 77, 1141, 8, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1146, 8, 77,
		1, 77, 3, 77, 1149, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 1155, 8,
		78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 5, 79, 1162, 8, 79, 10, 79, 12,
		79, 1165, 9, 79, 1, 80, 3, 80, 1168, 8, 80, 1, 80, 1, 80, 3, 80, 1172,
		8, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1178, 8, 80, 3, 80, 1180, 8,
		80, 1, 81, 1, 81, 1, 81, 3, 81, 1185, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82,
		1, 82, 1, 83, 5, 83, 1193, 8, 83, 10, 83, 12, 83, 1196, 9, 83, 1, 83, 3,
		83, 1199, 8, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1204, 8, 83, 1, 83, 1, 83,
		1, 83, 3, 83, 1209, 8, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 5,
		85, 1217, 8, 85, 10, 85, 12, 85, 1220, 9, 85, 1, 85, 5, 85, 1223, 8, 85,
		10, 85, 12, 85, 1226, 9, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 1232, 8,
		86, 1, 86, 3, 86, 1235, 8, 86, 1, 86, 1, 86, 3, 86, 1239, 8, 86, 1, 86,
		3, 86, 1242, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 1250,
		8, 87, 10, 87, 12, 87, 1253, 9, 87, 1, 87, 5, 87, 1256, 8, 87, 10, 87,
		12, 87, 1259, 9, 87, 1, 87, 3, 87, 1262, 8, 87, 1, 87, 1, 87, 1, 88, 1,
		88, 1, 88, 3, 88, 1269, 8, 88, 1, 88, 3, 88, 1272, 8, 88, 1, 89, 1, 89,
		1, 89, 5, 89, 1277, 8, 89, 10, 89, 12, 89, 1280, 9, 89, 1, 89, 1, 89, 1,
		90, 5, 90, 1285, 8, 90, 10, 90, 12, 90, 1288, 9, 90, 1, 90, 1, 90, 1, 90,
		1, 90, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 5,
		93, 1303, 8, 93, 10, 93, 12, 93, 1306, 9, 93, 1, 93, 5, 93, 1309, 8, 93,
		10, 93, 12, 93, 1312, 9, 93, 1, 94, 1, 94, 1, 94, 3, 94, 1317, 8, 94, 1,
		94, 1, 94, 1, 95, 4, 95, 1322, 8, 95, 11, 95, 12, 95, 1323, 1, 96, 5, 96,
		1327, 8, 96, 10, 96, 12, 96, 1330, 9, 96, 1, 96, 3, 96, 1333, 8, 96, 1,
		96, 1, 96, 1, 96, 3, 96, 1338, 8, 96, 1, 96, 3, 96, 1341, 8, 96, 1, 96,
		1, 96, 3, 96, 1345, 8, 96, 1, 96, 1, 96, 1, 96, 3, 96, 1350, 8, 96, 1,
		96, 3, 96, 1353, 8, 96, 1, 97, 1, 97, 1, 97, 3, 97, 1358, 8, 97, 1, 98,
		1, 98, 1, 98, 1, 98, 1, 98, 5, 98, 1365, 8, 98, 10, 98, 12, 98, 1368, 9,
		98, 1, 98, 3, 98, 1371, 8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99,
		1, 100, 1, 100, 1, 100, 1, 101, 4, 101, 1383, 8, 101, 11, 101, 12, 101,
		1384, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 5, 102, 1392, 8, 102, 10,
		102, 12, 102, 1395, 9, 102, 1, 102, 1, 102, 1, 103, 4, 103, 1400, 8, 103,
		11, 103, 12, 103, 1401, 1, 104, 5, 104, 1405, 8, 104, 10, 104, 12, 104,
		1408, 9, 104, 1, 104, 5, 104, 1411, 8, 104, 10, 104, 12, 104, 1414, 9,
		104, 1, 104, 1, 104, 3, 104, 1418, 8, 104, 1, 105, 1, 105, 1, 106, 5, 106,
		1423, 8, 106, 10, 106, 12, 106, 1426, 9, 106, 1, 106, 5, 106, 1429, 8,
		106, 10, 106, 12, 106, 1432, 9, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1,
		107, 1, 107, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 5, 109, 1445, 8, 109,
		10, 109, 12, 109, 1448, 9, 109, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110,
		1, 110, 3, 110, 1456, 8, 110, 1, 110, 1, 110, 1, 111, 5, 111, 1461, 8,
		111, 10, 111, 12, 111, 1464, 9, 111, 1, 111, 3, 111, 1467, 8, 111, 1, 111,
		1, 111, 1, 111, 3, 111, 1472, 8, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1,
		113, 1, 113, 1, 113, 3, 113, 1481, 8, 113, 1, 113, 5, 113, 1484, 8, 113,
		10, 113, 12, 113, 1487, 9, 113, 5, 113, 1489, 8, 113, 10, 113, 12, 113,
		1492, 9, 113, 1, 113, 1, 113, 1, 114, 5, 114, 1497, 8, 114, 10, 114, 12,
		114, 1500, 9, 114, 1, 114, 1, 114, 3, 114, 1504, 8, 114, 1, 114, 1, 114,
		1, 114, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116,
		1516, 8, 116, 1, 117, 1, 117, 1, 117, 5, 117, 1521, 8, 117, 10, 117, 12,
		117, 1524, 9, 117, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 3, 119, 1535, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1,
		120, 3, 120, 1542, 8, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122,
		1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1556, 8, 123, 1,
		123, 1, 123, 1, 124, 1, 124, 1, 124, 1, 124, 5, 124, 1564, 8, 124, 10,
		124, 12, 124, 1567, 9, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 1,
		125, 3, 125, 1575, 8, 125, 1, 126, 1, 126, 3, 126, 1579, 8, 126, 1, 127,
		1, 127, 3, 127, 1583, 8, 127, 1, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1,
		128, 1, 128, 5, 128, 1592, 8, 128, 10, 128, 12, 128, 1595, 9, 128, 3, 128,
		1597, 8, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1,
		130, 1, 130, 3, 130, 1608, 8, 130, 1, 131, 3, 131, 1611, 8, 131, 1, 131,
		1, 131, 1, 131, 1, 131, 5, 131, 1617, 8, 131, 10, 131, 12, 131, 1620, 9,
		131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1,
		132, 1, 132, 3, 132, 1632, 8, 132, 1, 133, 1, 133, 1, 133, 1, 133, 3, 133,
		1638, 8, 133, 1, 134, 1, 134, 3, 134, 1642, 8, 134, 1, 135, 1, 135, 1,
		135, 1, 135, 5, 135, 1648, 8, 135, 10, 135, 12, 135, 1651, 9, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 3, 136, 1659, 8, 136, 1, 136, 1,
		136, 1, 136, 1, 137, 1, 137, 1, 137, 3, 137, 1667, 8, 137, 1, 137, 1, 137,
		1, 137, 1, 138, 1, 138, 3, 138, 1674, 8, 138, 1, 138, 1, 138, 1, 139, 1,
		139, 1, 139, 1, 139, 1, 140, 1, 140, 1, 140, 5, 140, 1685, 8, 140, 10,
		140, 12, 140, 1688, 9, 140, 1, 141, 1, 141, 1, 141, 3, 141, 1693, 8, 141,
		1, 142, 1, 142, 1, 142, 1, 142, 3, 142, 1699, 8, 142, 1, 142, 3, 142, 1702,
		8, 142, 1, 143, 1, 143, 3, 143, 1706, 8, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 1, 143, 3, 143, 1713, 8, 143, 1, 143, 3, 143, 1716, 8, 143, 1, 143,
		3, 143, 1719, 8, 143, 1, 143, 3, 143, 1722, 8, 143, 1, 144, 1, 144, 1,
		145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146, 5, 146, 1732, 8, 146, 10,
		146, 12, 146, 1735, 9, 146, 1, 147, 1, 147, 1, 147, 5, 147, 1740, 8, 147,
		10, 147, 12, 147, 1743, 9, 147, 1, 148, 1, 148, 1, 148, 3, 148, 1748, 8,
		148, 1, 148, 1, 148, 1, 149, 1, 149, 3, 149, 1754, 8, 149, 1, 149, 1, 149,
		3, 149, 1758, 8, 149, 1, 150, 1, 150, 1, 150, 5, 150, 1763, 8, 150, 10,
		150, 12, 150, 1766, 9, 150, 1, 151, 1, 151, 1, 151, 1, 152, 1, 152, 1,
		152, 1, 152, 1, 153, 1, 153, 1, 153, 1, 153, 5, 153, 1779, 8, 153, 10,
		153, 12, 153, 1782, 9, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 1,
		154, 1, 155, 1, 155, 1, 155, 1, 155, 1, 156, 1, 156, 3, 156, 1796, 8, 156,
		1, 156, 1, 156, 3, 156, 1800, 8, 156, 1, 157, 1, 157, 1, 157, 5, 157, 1805,
		8, 157, 10, 157, 12, 157, 1808, 9, 157, 1, 157, 3, 157, 1811, 8, 157, 1,
		158, 1, 158, 1, 158, 3, 158, 1816, 8, 158, 1, 158, 1, 158, 1, 159, 1, 159,
		1, 159, 1, 159, 3, 159, 1824, 8, 159, 1, 159, 1, 159, 1, 160, 1, 160, 1,
		160, 1, 161, 1, 161, 1, 161, 3, 161, 1834, 8, 161, 1, 162, 1, 162, 3, 162,
		1838, 8, 162, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 1,
		164, 3, 164, 1848, 8, 164, 3, 164, 1850, 8, 164, 1, 165, 1, 165, 1, 165,
		1, 165, 1, 165, 1, 165, 5, 165, 1858, 8, 165, 10, 165, 12, 165, 1861, 9,
		165, 5, 165, 1863, 8, 165, 10, 165, 12, 165, 1866, 9, 165, 1, 165, 1, 165,
		3, 165, 1870, 8, 165, 1, 165, 5, 165, 1873, 8, 165, 10, 165, 12, 165, 1876,
		9, 165, 3, 165, 1878, 8, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1,
		166, 1, 166, 1, 166, 3, 166, 1888, 8, 166, 1, 166, 1, 166, 1, 166, 1, 167,
		1, 167, 1, 167, 1, 167, 1, 167, 5, 167, 1898, 8, 167, 10, 167, 12, 167,
		1901, 9, 167, 1, 167, 1, 167, 1, 167, 3, 167, 1906, 8, 167, 1, 168, 1,
		168, 1, 168, 3, 168, 1911, 8, 168, 1, 169, 1, 169, 1, 169, 1, 169, 5, 169,
		1917, 8, 169, 10, 169, 12, 169, 1920, 9, 169, 1, 169, 1, 169, 1, 169, 3,
		169, 1925, 8, 169, 1, 170, 1, 170, 1, 171, 1, 171, 1, 171, 3, 171, 1932,
		8, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 173, 3, 173, 1939, 8, 173, 1,
		173, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 1946, 8, 173, 1, 174, 1, 174,
		1, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 176, 1, 176,
		1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 3, 176, 1964, 8, 176, 1, 177, 1,
		177, 3, 177, 1968, 8, 177, 1, 178, 1, 178, 3, 178, 1972, 8, 178, 1, 178,
		1, 178, 3, 178, 1976, 8, 178, 1, 178, 1, 178, 1, 179, 3, 179, 1981, 8,
		179, 1, 179, 1, 179, 1, 179, 1, 179, 3, 179, 1987, 8, 179, 1, 180, 1, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 181,
		1, 181, 1, 181, 3, 181, 2002, 8, 181, 1, 181, 1, 181, 1, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 3, 183, 2015, 8, 183,
		1, 183, 1, 183, 1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 185, 1, 185,
		1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 2030, 8, 185, 1, 186, 1, 186, 1,
		186, 1, 186, 3, 186, 2036, 8, 186, 1, 187, 1, 187, 1, 187, 1, 188, 1, 188,
		1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 5, 189, 2050, 8,
		189, 10, 189, 12, 189, 2053, 9, 189, 1, 189, 3, 189, 2056, 8, 189, 3, 189,
		2058, 8, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 191, 1, 191, 1,
		191, 1, 192, 1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 5, 193, 2074, 8, 193,
		10, 193, 12, 193, 2077, 9, 193, 1, 194, 1, 194, 1, 194, 3, 194, 2082, 8,
		194, 1, 194, 0, 0, 195, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
		128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
		158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
		188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216,
		218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246,
		248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276,
		278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306,
		308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336,
		338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366,
		368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 0, 27, 1, 0, 120,
		121, 1, 0, 18, 20, 1, 0, 68, 75, 2, 0, 92, 93, 98, 100, 2, 0, 58, 58, 76,
		81, 1, 0, 80, 81, 1, 0, 82, 83, 1, 0, 60, 61, 2, 0, 57, 57, 59, 59, 1,
		0, 95, 96, 1, 0, 104, 105, 2, 0, 113, 115, 122, 122, 1, 0, 107, 109, 2,
		0, 106, 106, 113, 115, 1, 0, 92, 93, 3, 0, 76, 77, 82, 83, 99, 99, 2, 0,
		23, 23, 43, 43, 1, 0, 20, 23, 2, 0, 21, 21, 23, 23, 1, 0, 38, 39, 1, 0,
		22, 23, 2, 0, 20, 20, 22, 22, 2, 0, 107, 111, 122, 122, 2, 0, 107, 110,
		122, 122, 2, 0, 67, 67, 122, 122, 1, 0, 13, 14, 1, 0, 113, 114, 2245, 0,
		399, 1, 0, 0, 0, 2, 402, 1, 0, 0, 0, 4, 417, 1, 0, 0, 0, 6, 446, 1, 0,
		0, 0, 8, 473, 1, 0, 0, 0, 10, 475, 1, 0, 0, 0, 12, 481, 1, 0, 0, 0, 14,
		491, 1, 0, 0, 0, 16, 493, 1, 0, 0, 0, 18, 497, 1, 0, 0, 0, 20, 505, 1,
		0, 0, 0, 22, 513, 1, 0, 0, 0, 24, 533, 1, 0, 0, 0, 26, 535, 1, 0, 0, 0,
		28, 543, 1, 0, 0, 0, 30, 551, 1, 0, 0, 0, 32, 561, 1, 0, 0, 0, 34, 564,
		1, 0, 0, 0, 36, 568, 1, 0, 0, 0, 38, 586, 1, 0, 0, 0, 40, 588, 1, 0, 0,
		0, 42, 599, 1, 0, 0, 0, 44, 610, 1, 0, 0, 0, 46, 613, 1, 0, 0, 0, 48, 624,
		1, 0, 0, 0, 50, 628, 1, 0, 0, 0, 52, 631, 1, 0, 0, 0, 54, 648, 1, 0, 0,
		0, 56, 650, 1, 0, 0, 0, 58, 677, 1, 0, 0, 0, 60, 682, 1, 0, 0, 0, 62, 686,
		1, 0, 0, 0, 64, 718, 1, 0, 0, 0, 66, 747, 1, 0, 0, 0, 68, 749, 1, 0, 0,
		0, 70, 757, 1, 0, 0, 0, 72, 759, 1, 0, 0, 0, 74, 767, 1, 0, 0, 0, 76, 777,
		1, 0, 0, 0, 78, 779, 1, 0, 0, 0, 80, 783, 1, 0, 0, 0, 82, 787, 1, 0, 0,
		0, 84, 789, 1, 0, 0, 0, 86, 792, 1, 0, 0, 0, 88, 797, 1, 0, 0, 0, 90, 818,
		1, 0, 0, 0, 92, 820, 1, 0, 0, 0, 94, 827, 1, 0, 0, 0, 96, 830, 1, 0, 0,
		0, 98, 843, 1, 0, 0, 0, 100, 845, 1, 0, 0, 0, 102, 859, 1, 0, 0, 0, 104,
		870, 1, 0, 0, 0, 106, 888, 1, 0, 0, 0, 108, 894, 1, 0, 0, 0, 110, 903,
		1, 0, 0, 0, 112, 907, 1, 0, 0, 0, 114, 914, 1, 0, 0, 0, 116, 916, 1, 0,
		0, 0, 118, 936, 1, 0, 0, 0, 120, 962, 1, 0, 0, 0, 122, 967, 1, 0, 0, 0,
		124, 980, 1, 0, 0, 0, 126, 990, 1, 0, 0, 0, 128, 995, 1, 0, 0, 0, 130,
		1014, 1, 0, 0, 0, 132, 1016, 1, 0, 0, 0, 134, 1028, 1, 0, 0, 0, 136, 1048,
		1, 0, 0, 0, 138, 1050, 1, 0, 0, 0, 140, 1058, 1, 0, 0, 0, 142, 1081, 1,
		0, 0, 0, 144, 1097, 1, 0, 0, 0, 146, 1102, 1, 0, 0, 0, 148, 1115, 1, 0,
		0, 0, 150, 1120, 1, 0, 0, 0, 152, 1136, 1, 0, 0, 0, 154, 1138, 1, 0, 0,
		0, 156, 1152, 1, 0, 0, 0, 158, 1158, 1, 0, 0, 0, 160, 1179, 1, 0, 0, 0,
		162, 1181, 1, 0, 0, 0, 164, 1186, 1, 0, 0, 0, 166, 1194, 1, 0, 0, 0, 168,
		1210, 1, 0, 0, 0, 170, 1212, 1, 0, 0, 0, 172, 1229, 1, 0, 0, 0, 174, 1245,
		1, 0, 0, 0, 176, 1265, 1, 0, 0, 0, 178, 1273, 1, 0, 0, 0, 180, 1286, 1,
		0, 0, 0, 182, 1293, 1, 0, 0, 0, 184, 1295, 1, 0, 0, 0, 186, 1299, 1, 0,
		0, 0, 188, 1313, 1, 0, 0, 0, 190, 1321, 1, 0, 0, 0, 192, 1328, 1, 0, 0,
		0, 194, 1354, 1, 0, 0, 0, 196, 1359, 1, 0, 0, 0, 198, 1374, 1, 0, 0, 0,
		200, 1378, 1, 0, 0, 0, 202, 1382, 1, 0, 0, 0, 204, 1386, 1, 0, 0, 0, 206,
		1399, 1, 0, 0, 0, 208, 1406, 1, 0, 0, 0, 210, 1419, 1, 0, 0, 0, 212, 1424,
		1, 0, 0, 0, 214, 1437, 1, 0, 0, 0, 216, 1439, 1, 0, 0, 0, 218, 1446, 1,
		0, 0, 0, 220, 1452, 1, 0, 0, 0, 222, 1462, 1, 0, 0, 0, 224, 1475, 1, 0,
		0, 0, 226, 1477, 1, 0, 0, 0, 228, 1498, 1, 0, 0, 0, 230, 1508, 1, 0, 0,
		0, 232, 1510, 1, 0, 0, 0, 234, 1517, 1, 0, 0, 0, 236, 1525, 1, 0, 0, 0,
		238, 1528, 1, 0, 0, 0, 240, 1536, 1, 0, 0, 0, 242, 1543, 1, 0, 0, 0, 244,
		1547, 1, 0, 0, 0, 246, 1551, 1, 0, 0, 0, 248, 1559, 1, 0, 0, 0, 250, 1570,
		1, 0, 0, 0, 252, 1576, 1, 0, 0, 0, 254, 1580, 1, 0, 0, 0, 256, 1587, 1,
		0, 0, 0, 258, 1602, 1, 0, 0, 0, 260, 1605, 1, 0, 0, 0, 262, 1610, 1, 0,
		0, 0, 264, 1631, 1, 0, 0, 0, 266, 1633, 1, 0, 0, 0, 268, 1639, 1, 0, 0,
		0, 270, 1643, 1, 0, 0, 0, 272, 1656, 1, 0, 0, 0, 274, 1663, 1, 0, 0, 0,
		276, 1671, 1, 0, 0, 0, 278, 1677, 1, 0, 0, 0, 280, 1681, 1, 0, 0, 0, 282,
		1689, 1, 0, 0, 0, 284, 1698, 1, 0, 0, 0, 286, 1712, 1, 0, 0, 0, 288, 1723,
		1, 0, 0, 0, 290, 1725, 1, 0, 0, 0, 292, 1728, 1, 0, 0, 0, 294, 1736, 1,
		0, 0, 0, 296, 1744, 1, 0, 0, 0, 298, 1751, 1, 0, 0, 0, 300, 1759, 1, 0,
		0, 0, 302, 1767, 1, 0, 0, 0, 304, 1770, 1, 0, 0, 0, 306, 1774, 1, 0, 0,
		0, 308, 1785, 1, 0, 0, 0, 310, 1789, 1, 0, 0, 0, 312, 1793, 1, 0, 0, 0,
		314, 1801, 1, 0, 0, 0, 316, 1812, 1, 0, 0, 0, 318, 1819, 1, 0, 0, 0, 320,
		1827, 1, 0, 0, 0, 322, 1830, 1, 0, 0, 0, 324, 1835, 1, 0, 0, 0, 326, 1839,
		1, 0, 0, 0, 328, 1841, 1, 0, 0, 0, 330, 1851, 1, 0, 0, 0, 332, 1887, 1,
		0, 0, 0, 334, 1892, 1, 0, 0, 0, 336, 1910, 1, 0, 0, 0, 338, 1912, 1, 0,
		0, 0, 340, 1926, 1, 0, 0, 0, 342, 1931, 1, 0, 0, 0, 344, 1933, 1, 0, 0,
		0, 346, 1938, 1, 0, 0, 0, 348, 1947, 1, 0, 0, 0, 350, 1950, 1, 0, 0, 0,
		352, 1963, 1, 0, 0, 0, 354, 1967, 1, 0, 0, 0, 356, 1969, 1, 0, 0, 0, 358,
		1980, 1, 0, 0, 0, 360, 1988, 1, 0, 0, 0, 362, 1994, 1, 0, 0, 0, 364, 2005,
		1, 0, 0, 0, 366, 2012, 1, 0, 0, 0, 368, 2018, 1, 0, 0, 0, 370, 2021, 1,
		0, 0, 0, 372, 2031, 1, 0, 0, 0, 374, 2037, 1, 0, 0, 0, 376, 2040, 1, 0,
		0, 0, 378, 2057, 1, 0, 0, 0, 380, 2059, 1, 0, 0, 0, 382, 2064, 1, 0, 0,
		0, 384, 2067, 1, 0, 0, 0, 386, 2070, 1, 0, 0, 0, 388, 2078, 1, 0, 0, 0,
		390, 394, 3, 6, 3, 0, 391, 393, 5, 91, 0, 0, 392, 391, 1, 0, 0, 0, 393,
		396, 1, 0, 0, 0, 394, 392, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395, 398,
		1, 0, 0, 0, 396, 394, 1, 0, 0, 0, 397, 390, 1, 0, 0, 0, 398, 401, 1, 0,
		0, 0, 399, 397, 1, 0, 0, 0, 399, 400, 1, 0, 0, 0, 400, 1, 1, 0, 0, 0, 401,
		399, 1, 0, 0, 0, 402, 412, 5, 54, 0, 0, 403, 407, 3, 6, 3, 0, 404, 406,
		5, 91, 0, 0, 405, 404, 1, 0, 0, 0, 406, 409, 1, 0, 0, 0, 407, 405, 1, 0,
		0, 0, 407, 408, 1, 0, 0, 0, 408, 411, 1, 0, 0, 0, 409, 407, 1, 0, 0, 0,
		410, 403, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0, 412, 410, 1, 0, 0, 0, 412,
		413, 1, 0, 0, 0, 413, 415, 1, 0, 0, 0, 414, 412, 1, 0, 0, 0, 415, 416,
		5, 55, 0, 0, 416, 3, 1, 0, 0, 0, 417, 418, 7, 0, 0, 0, 418, 5, 1, 0, 0,
		0, 419, 447, 3, 4, 2, 0, 420, 447, 3, 250, 125, 0, 421, 447, 3, 262, 131,
		0, 422, 447, 3, 114, 57, 0, 423, 447, 3, 134, 67, 0, 424, 447, 3, 166,
		83, 0, 425, 447, 3, 222, 111, 0, 426, 447, 3, 232, 116, 0, 427, 447, 3,
		274, 137, 0, 428, 447, 3, 238, 119, 0, 429, 447, 3, 384, 192, 0, 430, 447,
		3, 132, 66, 0, 431, 447, 3, 8, 4, 0, 432, 447, 3, 10, 5, 0, 433, 447, 3,
		314, 157, 0, 434, 447, 3, 322, 161, 0, 435, 447, 3, 112, 56, 0, 436, 447,
		3, 324, 162, 0, 437, 447, 3, 326, 163, 0, 438, 447, 3, 328, 164, 0, 439,
		447, 3, 330, 165, 0, 440, 447, 3, 346, 173, 0, 441, 447, 3, 112, 56, 0,
		442, 447, 3, 368, 184, 0, 443, 447, 3, 370, 185, 0, 444, 447, 3, 372, 186,
		0, 445, 447, 3, 80, 40, 0, 446, 419, 1, 0, 0, 0, 446, 420, 1, 0, 0, 0,
		446, 421, 1, 0, 0, 0, 446, 422, 1, 0, 0, 0, 446, 423, 1, 0, 0, 0, 446,
		424, 1, 0, 0, 0, 446, 425, 1, 0, 0, 0, 446, 426, 1, 0, 0, 0, 446, 427,
		1, 0, 0, 0, 446, 428, 1, 0, 0, 0, 446, 429, 1, 0, 0, 0, 446, 430, 1, 0,
		0, 0, 446, 431, 1, 0, 0, 0, 446, 432, 1, 0, 0, 0, 446, 433, 1, 0, 0, 0,
		446, 434, 1, 0, 0, 0, 446, 435, 1, 0, 0, 0, 446, 436, 1, 0, 0, 0, 446,
		437, 1, 0, 0, 0, 446, 438, 1, 0, 0, 0, 446, 439, 1, 0, 0, 0, 446, 440,
		1, 0, 0, 0, 446, 441, 1, 0, 0, 0, 446, 442, 1, 0, 0, 0, 446, 443, 1, 0,
		0, 0, 446, 444, 1, 0, 0, 0, 446, 445, 1, 0, 0, 0, 447, 7, 1, 0, 0, 0, 448,
		451, 7, 1, 0, 0, 449, 452, 5, 122, 0, 0, 450, 452, 3, 16, 8, 0, 451, 449,
		1, 0, 0, 0, 451, 450, 1, 0, 0, 0, 452, 455, 1, 0, 0, 0, 453, 454, 5, 88,
		0, 0, 454, 456, 3, 286, 143, 0, 455, 453, 1, 0, 0, 0, 455, 456, 1, 0, 0,
		0, 456, 462, 1, 0, 0, 0, 457, 460, 5, 68, 0, 0, 458, 461, 3, 54, 27, 0,
		459, 461, 3, 330, 165, 0, 460, 458, 1, 0, 0, 0, 460, 459, 1, 0, 0, 0, 461,
		463, 1, 0, 0, 0, 462, 457, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463, 474,
		1, 0, 0, 0, 464, 467, 3, 50, 25, 0, 465, 467, 3, 12, 6, 0, 466, 464, 1,
		0, 0, 0, 466, 465, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 471, 7, 2, 0,
		0, 469, 472, 3, 54, 27, 0, 470, 472, 3, 330, 165, 0, 471, 469, 1, 0, 0,
		0, 471, 470, 1, 0, 0, 0, 472, 474, 1, 0, 0, 0, 473, 448, 1, 0, 0, 0, 473,
		466, 1, 0, 0, 0, 474, 9, 1, 0, 0, 0, 475, 476, 3, 50, 25, 0, 476, 479,
		5, 90, 0, 0, 477, 480, 3, 54, 27, 0, 478, 480, 3, 330, 165, 0, 479, 477,
		1, 0, 0, 0, 479, 478, 1, 0, 0, 0, 480, 11, 1, 0, 0, 0, 481, 486, 3, 14,
		7, 0, 482, 483, 5, 49, 0, 0, 483, 485, 3, 14, 7, 0, 484, 482, 1, 0, 0,
		0, 485, 488, 1, 0, 0, 0, 486, 484, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487,
		13, 1, 0, 0, 0, 488, 486, 1, 0, 0, 0, 489, 492, 3, 50, 25, 0, 490, 492,
		5, 67, 0, 0, 491, 489, 1, 0, 0, 0, 491, 490, 1, 0, 0, 0, 492, 15, 1, 0,
		0, 0, 493, 494, 5, 54, 0, 0, 494, 495, 3, 18, 9, 0, 495, 496, 5, 55, 0,
		0, 496, 17, 1, 0, 0, 0, 497, 502, 3, 76, 38, 0, 498, 499, 5, 49, 0, 0,
		499, 501, 3, 76, 38, 0, 500, 498, 1, 0, 0, 0, 501, 504, 1, 0, 0, 0, 502,
		500, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0, 503, 19, 1, 0, 0, 0, 504, 502, 1,
		0, 0, 0, 505, 511, 3, 22, 11, 0, 506, 507, 5, 64, 0, 0, 507, 508, 3, 20,
		10, 0, 508, 509, 5, 88, 0, 0, 509, 510, 3, 20, 10, 0, 510, 512, 1, 0, 0,
		0, 511, 506, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512, 21, 1, 0, 0, 0, 513,
		518, 3, 24, 12, 0, 514, 515, 7, 3, 0, 0, 515, 517, 3, 24, 12, 0, 516, 514,
		1, 0, 0, 0, 517, 520, 1, 0, 0, 0, 518, 516, 1, 0, 0, 0, 518, 519, 1, 0,
		0, 0, 519, 23, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 521, 526, 3, 26, 13, 0,
		522, 523, 7, 4, 0, 0, 523, 525, 3, 26, 13, 0, 524, 522, 1, 0, 0, 0, 525,
		528, 1, 0, 0, 0, 526, 524, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527, 534,
		1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 529, 530, 3, 302, 151, 0, 530, 531, 7,
		5, 0, 0, 531, 532, 5, 114, 0, 0, 532, 534, 1, 0, 0, 0, 533, 521, 1, 0,
		0, 0, 533, 529, 1, 0, 0, 0, 534, 25, 1, 0, 0, 0, 535, 540, 3, 28, 14, 0,
		536, 537, 7, 6, 0, 0, 537, 539, 3, 28, 14, 0, 538, 536, 1, 0, 0, 0, 539,
		542, 1, 0, 0, 0, 540, 538, 1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 27, 1,
		0, 0, 0, 542, 540, 1, 0, 0, 0, 543, 548, 3, 30, 15, 0, 544, 545, 7, 7,
		0, 0, 545, 547, 3, 30, 15, 0, 546, 544, 1, 0, 0, 0, 547, 550, 1, 0, 0,
		0, 548, 546, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 29, 1, 0, 0, 0, 550,
		548, 1, 0, 0, 0, 551, 556, 3, 32, 16, 0, 552, 553, 7, 8, 0, 0, 553, 555,
		3, 32, 16, 0, 554, 552, 1, 0, 0, 0, 555, 558, 1, 0, 0, 0, 556, 554, 1,
		0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 31, 1, 0, 0, 0, 558, 556, 1, 0, 0,
		0, 559, 562, 3, 34, 17, 0, 560, 562, 3, 36, 18, 0, 561, 559, 1, 0, 0, 0,
		561, 560, 1, 0, 0, 0, 562, 33, 1, 0, 0, 0, 563, 565, 7, 9, 0, 0, 564, 563,
		1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 567, 3, 38,
		19, 0, 567, 35, 1, 0, 0, 0, 568, 570, 3, 38, 19, 0, 569, 571, 7, 9, 0,
		0, 570, 569, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 37, 1, 0, 0, 0, 572,
		573, 5, 50, 0, 0, 573, 574, 3, 38, 19, 0, 574, 575, 5, 51, 0, 0, 575, 587,
		1, 0, 0, 0, 576, 577, 5, 61, 0, 0, 577, 587, 3, 38, 19, 0, 578, 587, 3,
		68, 34, 0, 579, 587, 3, 42, 21, 0, 580, 587, 3, 40, 20, 0, 581, 587, 3,
		46, 23, 0, 582, 587, 3, 52, 26, 0, 583, 587, 3, 50, 25, 0, 584, 587, 3,
		62, 31, 0, 585, 587, 3, 60, 30, 0, 586, 572, 1, 0, 0, 0, 586, 576, 1, 0,
		0, 0, 586, 578, 1, 0, 0, 0, 586, 579, 1, 0, 0, 0, 586, 580, 1, 0, 0, 0,
		586, 581, 1, 0, 0, 0, 586, 582, 1, 0, 0, 0, 586, 583, 1, 0, 0, 0, 586,
		584, 1, 0, 0, 0, 586, 585, 1, 0, 0, 0, 587, 39, 1, 0, 0, 0, 588, 589, 5,
		50, 0, 0, 589, 594, 3, 54, 27, 0, 590, 591, 5, 49, 0, 0, 591, 593, 3, 54,
		27, 0, 592, 590, 1, 0, 0, 0, 593, 596, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0,
		594, 595, 1, 0, 0, 0, 595, 597, 1, 0, 0, 0, 596, 594, 1, 0, 0, 0, 597,
		598, 5, 51, 0, 0, 598, 41, 1, 0, 0, 0, 599, 600, 5, 52, 0, 0, 600, 605,
		3, 54, 27, 0, 601, 602, 5, 49, 0, 0, 602, 604, 3, 54, 27, 0, 603, 601,
		1, 0, 0, 0, 604, 607, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 605, 606, 1, 0,
		0, 0, 606, 608, 1, 0, 0, 0, 607, 605, 1, 0, 0, 0, 608, 609, 5, 53, 0, 0,
		609, 43, 1, 0, 0, 0, 610, 611, 7, 10, 0, 0, 611, 612, 3, 62, 31, 0, 612,
		45, 1, 0, 0, 0, 613, 614, 5, 54, 0, 0, 614, 619, 3, 48, 24, 0, 615, 616,
		5, 49, 0, 0, 616, 618, 3, 48, 24, 0, 617, 615, 1, 0, 0, 0, 618, 621, 1,
		0, 0, 0, 619, 617, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 622, 1, 0, 0,
		0, 621, 619, 1, 0, 0, 0, 622, 623, 5, 55, 0, 0, 623, 47, 1, 0, 0, 0, 624,
		625, 7, 11, 0, 0, 625, 626, 5, 88, 0, 0, 626, 627, 3, 54, 27, 0, 627, 49,
		1, 0, 0, 0, 628, 629, 5, 65, 0, 0, 629, 630, 3, 58, 29, 0, 630, 51, 1,
		0, 0, 0, 631, 632, 5, 65, 0, 0, 632, 633, 3, 58, 29, 0, 633, 635, 5, 50,
		0, 0, 634, 636, 3, 70, 35, 0, 635, 634, 1, 0, 0, 0, 635, 636, 1, 0, 0,
		0, 636, 637, 1, 0, 0, 0, 637, 638, 5, 51, 0, 0, 638, 53, 1, 0, 0, 0, 639,
		649, 3, 124, 62, 0, 640, 649, 3, 20, 10, 0, 641, 649, 3, 44, 22, 0, 642,
		649, 3, 164, 82, 0, 643, 649, 3, 302, 151, 0, 644, 649, 3, 374, 187, 0,
		645, 649, 3, 88, 44, 0, 646, 649, 3, 376, 188, 0, 647, 649, 3, 378, 189,
		0, 648, 639, 1, 0, 0, 0, 648, 640, 1, 0, 0, 0, 648, 641, 1, 0, 0, 0, 648,
		642, 1, 0, 0, 0, 648, 643, 1, 0, 0, 0, 648, 644, 1, 0, 0, 0, 648, 645,
		1, 0, 0, 0, 648, 646, 1, 0, 0, 0, 648, 647, 1, 0, 0, 0, 649, 55, 1, 0,
		0, 0, 650, 655, 3, 54, 27, 0, 651, 652, 5, 49, 0, 0, 652, 654, 3, 54, 27,
		0, 653, 651, 1, 0, 0, 0, 654, 657, 1, 0, 0, 0, 655, 653, 1, 0, 0, 0, 655,
		656, 1, 0, 0, 0, 656, 57, 1, 0, 0, 0, 657, 655, 1, 0, 0, 0, 658, 659, 5,
		122, 0, 0, 659, 678, 3, 276, 138, 0, 660, 662, 5, 122, 0, 0, 661, 663,
		3, 66, 33, 0, 662, 661, 1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 678, 1,
		0, 0, 0, 664, 665, 7, 12, 0, 0, 665, 678, 3, 66, 33, 0, 666, 667, 3, 68,
		34, 0, 667, 668, 3, 66, 33, 0, 668, 678, 1, 0, 0, 0, 669, 671, 5, 38, 0,
		0, 670, 672, 3, 66, 33, 0, 671, 670, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0,
		672, 678, 1, 0, 0, 0, 673, 675, 5, 39, 0, 0, 674, 676, 3, 66, 33, 0, 675,
		674, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 678, 1, 0, 0, 0, 677, 658,
		1, 0, 0, 0, 677, 660, 1, 0, 0, 0, 677, 664, 1, 0, 0, 0, 677, 666, 1, 0,
		0, 0, 677, 669, 1, 0, 0, 0, 677, 673, 1, 0, 0, 0, 678, 680, 1, 0, 0, 0,
		679, 681, 5, 94, 0, 0, 680, 679, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681,
		59, 1, 0, 0, 0, 682, 684, 5, 117, 0, 0, 683, 685, 3, 64, 32, 0, 684, 683,
		1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 61, 1, 0, 0, 0, 686, 688, 3, 58,
		29, 0, 687, 689, 5, 94, 0, 0, 688, 687, 1, 0, 0, 0, 688, 689, 1, 0, 0,
		0, 689, 690, 1, 0, 0, 0, 690, 692, 5, 50, 0, 0, 691, 693, 3, 70, 35, 0,
		692, 691, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694,
		696, 5, 51, 0, 0, 695, 697, 3, 64, 32, 0, 696, 695, 1, 0, 0, 0, 696, 697,
		1, 0, 0, 0, 697, 63, 1, 0, 0, 0, 698, 699, 5, 47, 0, 0, 699, 700, 5, 122,
		0, 0, 700, 702, 5, 50, 0, 0, 701, 703, 3, 70, 35, 0, 702, 701, 1, 0, 0,
		0, 702, 703, 1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 706, 5, 51, 0, 0, 705,
		707, 3, 64, 32, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 719,
		1, 0, 0, 0, 708, 709, 5, 48, 0, 0, 709, 710, 5, 122, 0, 0, 710, 712, 5,
		50, 0, 0, 711, 713, 3, 70, 35, 0, 712, 711, 1, 0, 0, 0, 712, 713, 1, 0,
		0, 0, 713, 714, 1, 0, 0, 0, 714, 716, 5, 51, 0, 0, 715, 717, 3, 64, 32,
		0, 716, 715, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 719, 1, 0, 0, 0, 718,
		698, 1, 0, 0, 0, 718, 708, 1, 0, 0, 0, 719, 65, 1, 0, 0, 0, 720, 721, 5,
		47, 0, 0, 721, 723, 5, 122, 0, 0, 722, 724, 3, 66, 33, 0, 723, 722, 1,
		0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 748, 1, 0, 0, 0, 725, 726, 5, 47, 0,
		0, 726, 727, 5, 122, 0, 0, 727, 729, 3, 276, 138, 0, 728, 730, 3, 66, 33,
		0, 729, 728, 1, 0, 0, 0, 729, 730, 1, 0, 0, 0, 730, 748, 1, 0, 0, 0, 731,
		732, 5, 89, 0, 0, 732, 734, 5, 122, 0, 0, 733, 735, 3, 66, 33, 0, 734,
		733, 1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 748, 1, 0, 0, 0, 736, 737,
		5, 89, 0, 0, 737, 739, 3, 50, 25, 0, 738, 740, 3, 66, 33, 0, 739, 738,
		1, 0, 0, 0, 739, 740, 1, 0, 0, 0, 740, 748, 1, 0, 0, 0, 741, 742, 5, 52,
		0, 0, 742, 743, 3, 54, 27, 0, 743, 745, 5, 53, 0, 0, 744, 746, 3, 66, 33,
		0, 745, 744, 1, 0, 0, 0, 745, 746, 1, 0, 0, 0, 746, 748, 1, 0, 0, 0, 747,
		720, 1, 0, 0, 0, 747, 725, 1, 0, 0, 0, 747, 731, 1, 0, 0, 0, 747, 736,
		1, 0, 0, 0, 747, 741, 1, 0, 0, 0, 748, 67, 1, 0, 0, 0, 749, 750, 7, 13,
		0, 0, 750, 69, 1, 0, 0, 0, 751, 754, 3, 56, 28, 0, 752, 753, 5, 49, 0,
		0, 753, 755, 3, 72, 36, 0, 754, 752, 1, 0, 0, 0, 754, 755, 1, 0, 0, 0,
		755, 758, 1, 0, 0, 0, 756, 758, 3, 72, 36, 0, 757, 751, 1, 0, 0, 0, 757,
		756, 1, 0, 0, 0, 758, 71, 1, 0, 0, 0, 759, 764, 3, 74, 37, 0, 760, 761,
		5, 49, 0, 0, 761, 763, 3, 74, 37, 0, 762, 760, 1, 0, 0, 0, 763, 766, 1,
		0, 0, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 73, 1, 0, 0,
		0, 766, 764, 1, 0, 0, 0, 767, 768, 5, 122, 0, 0, 768, 769, 5, 88, 0, 0,
		769, 770, 3, 54, 27, 0, 770, 75, 1, 0, 0, 0, 771, 778, 5, 67, 0, 0, 772,
		775, 5, 122, 0, 0, 773, 774, 5, 88, 0, 0, 774, 776, 3, 286, 143, 0, 775,
		773, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 778, 1, 0, 0, 0, 777, 771,
		1, 0, 0, 0, 777, 772, 1, 0, 0, 0, 778, 77, 1, 0, 0, 0, 779, 780, 5, 113,
		0, 0, 780, 781, 5, 48, 0, 0, 781, 782, 5, 113, 0, 0, 782, 79, 1, 0, 0,
		0, 783, 784, 3, 54, 27, 0, 784, 81, 1, 0, 0, 0, 785, 788, 3, 84, 42, 0,
		786, 788, 3, 86, 43, 0, 787, 785, 1, 0, 0, 0, 787, 786, 1, 0, 0, 0, 788,
		83, 1, 0, 0, 0, 789, 790, 5, 61, 0, 0, 790, 791, 5, 122, 0, 0, 791, 85,
		1, 0, 0, 0, 792, 793, 5, 96, 0, 0, 793, 794, 5, 122, 0, 0, 794, 87, 1,
		0, 0, 0, 795, 798, 3, 58, 29, 0, 796, 798, 5, 118, 0, 0, 797, 795, 1, 0,
		0, 0, 797, 796, 1, 0, 0, 0, 798, 802, 1, 0, 0, 0, 799, 801, 3, 90, 45,
		0, 800, 799, 1, 0, 0, 0, 801, 804, 1, 0, 0, 0, 802, 800, 1, 0, 0, 0, 802,
		803, 1, 0, 0, 0, 803, 806, 1, 0, 0, 0, 804, 802, 1, 0, 0, 0, 805, 807,
		5, 98, 0, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 809, 1, 0,
		0, 0, 808, 810, 3, 92, 46, 0, 809, 808, 1, 0, 0, 0, 809, 810, 1, 0, 0,
		0, 810, 813, 1, 0, 0, 0, 811, 814, 3, 94, 47, 0, 812, 814, 3, 96, 48, 0,
		813, 811, 1, 0, 0, 0, 813, 812, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814,
		89, 1, 0, 0, 0, 815, 819, 3, 82, 41, 0, 816, 819, 3, 20, 10, 0, 817, 819,
		3, 58, 29, 0, 818, 815, 1, 0, 0, 0, 818, 816, 1, 0, 0, 0, 818, 817, 1,
		0, 0, 0, 819, 91, 1, 0, 0, 0, 820, 824, 5, 97, 0, 0, 821, 823, 3, 90, 45,
		0, 822, 821, 1, 0, 0, 0, 823, 826, 1, 0, 0, 0, 824, 822, 1, 0, 0, 0, 824,
		825, 1, 0, 0, 0, 825, 93, 1, 0, 0, 0, 826, 824, 1, 0, 0, 0, 827, 828, 7,
		14, 0, 0, 828, 829, 3, 88, 44, 0, 829, 95, 1, 0, 0, 0, 830, 831, 7, 15,
		0, 0, 831, 832, 3, 88, 44, 0, 832, 97, 1, 0, 0, 0, 833, 834, 5, 47, 0,
		0, 834, 836, 5, 122, 0, 0, 835, 837, 3, 98, 49, 0, 836, 835, 1, 0, 0, 0,
		836, 837, 1, 0, 0, 0, 837, 844, 1, 0, 0, 0, 838, 839, 5, 89, 0, 0, 839,
		841, 5, 122, 0, 0, 840, 842, 3, 98, 49, 0, 841, 840, 1, 0, 0, 0, 841, 842,
		1, 0, 0, 0, 842, 844, 1, 0, 0, 0, 843, 833, 1, 0, 0, 0, 843, 838, 1, 0,
		0, 0, 844, 99, 1, 0, 0, 0, 845, 855, 5, 50, 0, 0, 846, 848, 3, 102, 51,
		0, 847, 846, 1, 0, 0, 0, 847, 848, 1, 0, 0, 0, 848, 856, 1, 0, 0, 0, 849,
		852, 3, 102, 51, 0, 850, 851, 5, 49, 0, 0, 851, 853, 3, 106, 53, 0, 852,
		850, 1, 0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 856, 1, 0, 0, 0, 854, 856,
		3, 106, 53, 0, 855, 847, 1, 0, 0, 0, 855, 849, 1, 0, 0, 0, 855, 854, 1,
		0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 858, 5, 51, 0, 0, 858, 101, 1, 0, 0,
		0, 859, 864, 3, 104, 52, 0, 860, 861, 5, 49, 0, 0, 861, 863, 3, 104, 52,
		0, 862, 860, 1, 0, 0, 0, 863, 866, 1, 0, 0, 0, 864, 862, 1, 0, 0, 0, 864,
		865, 1, 0, 0, 0, 865, 103, 1, 0, 0, 0, 866, 864, 1, 0, 0, 0, 867, 869,
		3, 4, 2, 0, 868, 867, 1, 0, 0, 0, 869, 872, 1, 0, 0, 0, 870, 868, 1, 0,
		0, 0, 870, 871, 1, 0, 0, 0, 871, 874, 1, 0, 0, 0, 872, 870, 1, 0, 0, 0,
		873, 875, 5, 87, 0, 0, 874, 873, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875,
		876, 1, 0, 0, 0, 876, 878, 5, 122, 0, 0, 877, 879, 5, 64, 0, 0, 878, 877,
		1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 882, 1, 0, 0, 0, 880, 881, 5, 88,
		0, 0, 881, 883, 3, 286, 143, 0, 882, 880, 1, 0, 0, 0, 882, 883, 1, 0, 0,
		0, 883, 886, 1, 0, 0, 0, 884, 885, 5, 68, 0, 0, 885, 887, 3, 54, 27, 0,
		886, 884, 1, 0, 0, 0, 886, 887, 1, 0, 0, 0, 887, 105, 1, 0, 0, 0, 888,
		890, 5, 54, 0, 0, 889, 891, 3, 108, 54, 0, 890, 889, 1, 0, 0, 0, 890, 891,
		1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 893, 5, 55, 0, 0, 893, 107, 1, 0,
		0, 0, 894, 899, 3, 110, 55, 0, 895, 896, 5, 49, 0, 0, 896, 898, 3, 110,
		55, 0, 897, 895, 1, 0, 0, 0, 898, 901, 1, 0, 0, 0, 899, 897, 1, 0, 0, 0,
		899, 900, 1, 0, 0, 0, 900, 109, 1, 0, 0, 0, 901, 899, 1, 0, 0, 0, 902,
		904, 5, 24, 0, 0, 903, 902, 1, 0, 0, 0, 903, 904, 1, 0, 0, 0, 904, 905,
		1, 0, 0, 0, 905, 906, 3, 104, 52, 0, 906, 111, 1, 0, 0, 0, 907, 909, 5,
		32, 0, 0, 908, 910, 3, 56, 28, 0, 909, 908, 1, 0, 0, 0, 909, 910, 1, 0,
		0, 0, 910, 113, 1, 0, 0, 0, 911, 915, 3, 118, 59, 0, 912, 915, 3, 122,
		61, 0, 913, 915, 3, 128, 64, 0, 914, 911, 1, 0, 0, 0, 914, 912, 1, 0, 0,
		0, 914, 913, 1, 0, 0, 0, 915, 115, 1, 0, 0, 0, 916, 931, 5, 31, 0, 0, 917,
		932, 5, 60, 0, 0, 918, 932, 5, 61, 0, 0, 919, 932, 5, 57, 0, 0, 920, 932,
		5, 59, 0, 0, 921, 932, 5, 58, 0, 0, 922, 932, 5, 76, 0, 0, 923, 932, 5,
		77, 0, 0, 924, 932, 5, 82, 0, 0, 925, 932, 5, 83, 0, 0, 926, 932, 5, 62,
		0, 0, 927, 932, 5, 104, 0, 0, 928, 932, 5, 105, 0, 0, 929, 930, 5, 52,
		0, 0, 930, 932, 5, 53, 0, 0, 931, 917, 1, 0, 0, 0, 931, 918, 1, 0, 0, 0,
		931, 919, 1, 0, 0, 0, 931, 920, 1, 0, 0, 0, 931, 921, 1, 0, 0, 0, 931,
		922, 1, 0, 0, 0, 931, 923, 1, 0, 0, 0, 931, 924, 1, 0, 0, 0, 931, 925,
		1, 0, 0, 0, 931, 926, 1, 0, 0, 0, 931, 927, 1, 0, 0, 0, 931, 928, 1, 0,
		0, 0, 931, 929, 1, 0, 0, 0, 932, 117, 1, 0, 0, 0, 933, 935, 3, 130, 65,
		0, 934, 933, 1, 0, 0, 0, 935, 938, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 936,
		937, 1, 0, 0, 0, 937, 939, 1, 0, 0, 0, 938, 936, 1, 0, 0, 0, 939, 942,
		5, 30, 0, 0, 940, 943, 5, 122, 0, 0, 941, 943, 3, 116, 58, 0, 942, 940,
		1, 0, 0, 0, 942, 941, 1, 0, 0, 0, 943, 945, 1, 0, 0, 0, 944, 946, 3, 278,
		139, 0, 945, 944, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 947, 1, 0, 0,
		0, 947, 949, 3, 100, 50, 0, 948, 950, 5, 29, 0, 0, 949, 948, 1, 0, 0, 0,
		949, 950, 1, 0, 0, 0, 950, 953, 1, 0, 0, 0, 951, 952, 5, 84, 0, 0, 952,
		954, 3, 120, 60, 0, 953, 951, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954, 955,
		1, 0, 0, 0, 955, 956, 3, 2, 1, 0, 956, 119, 1, 0, 0, 0, 957, 963, 3, 286,
		143, 0, 958, 959, 5, 50, 0, 0, 959, 960, 3, 300, 150, 0, 960, 961, 5, 51,
		0, 0, 961, 963, 1, 0, 0, 0, 962, 957, 1, 0, 0, 0, 962, 958, 1, 0, 0, 0,
		963, 121, 1, 0, 0, 0, 964, 966, 3, 130, 65, 0, 965, 964, 1, 0, 0, 0, 966,
		969, 1, 0, 0, 0, 967, 965, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 970,
		1, 0, 0, 0, 969, 967, 1, 0, 0, 0, 970, 973, 5, 30, 0, 0, 971, 974, 5, 122,
		0, 0, 972, 974, 3, 116, 58, 0, 973, 971, 1, 0, 0, 0, 973, 972, 1, 0, 0,
		0, 974, 976, 1, 0, 0, 0, 975, 977, 3, 278, 139, 0, 976, 975, 1, 0, 0, 0,
		976, 977, 1, 0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 979, 3, 124, 62, 0, 979,
		123, 1, 0, 0, 0, 980, 981, 3, 100, 50, 0, 981, 982, 5, 86, 0, 0, 982, 983,
		3, 126, 63, 0, 983, 125, 1, 0, 0, 0, 984, 991, 3, 54, 27, 0, 985, 986,
		5, 54, 0, 0, 986, 987, 3, 56, 28, 0, 987, 988, 5, 55, 0, 0, 988, 991, 1,
		0, 0, 0, 989, 991, 3, 2, 1, 0, 990, 984, 1, 0, 0, 0, 990, 985, 1, 0, 0,
		0, 990, 989, 1, 0, 0, 0, 991, 127, 1, 0, 0, 0, 992, 994, 3, 130, 65, 0,
		993, 992, 1, 0, 0, 0, 994, 997, 1, 0, 0, 0, 995, 993, 1, 0, 0, 0, 995,
		996, 1, 0, 0, 0, 996, 998, 1, 0, 0, 0, 997, 995, 1, 0, 0, 0, 998, 1001,
		5, 30, 0, 0, 999, 1002, 5, 122, 0, 0, 1000, 1002, 3, 116, 58, 0, 1001,
		999, 1, 0, 0, 0, 1001, 1000, 1, 0, 0, 0, 1002, 1004, 1, 0, 0, 0, 1003,
		1005, 3, 278, 139, 0, 1004, 1003, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005,
		1006, 1, 0, 0, 0, 1006, 1008, 3, 100, 50, 0, 1007, 1009, 5, 29, 0, 0, 1008,
		1007, 1, 0, 0, 0, 1008, 1009, 1, 0, 0, 0, 1009, 1012, 1, 0, 0, 0, 1010,
		1011, 5, 84, 0, 0, 1011, 1013, 3, 120, 60, 0, 1012, 1010, 1, 0, 0, 0, 1012,
		1013, 1, 0, 0, 0, 1013, 129, 1, 0, 0, 0, 1014, 1015, 7, 16, 0, 0, 1015,
		131, 1, 0, 0, 0, 1016, 1017, 5, 63, 0, 0, 1017, 1023, 3, 58, 29, 0, 1018,
		1020, 5, 50, 0, 0, 1019, 1021, 3, 70, 35, 0, 1020, 1019, 1, 0, 0, 0, 1020,
		1021, 1, 0, 0, 0, 1021, 1022, 1, 0, 0, 0, 1022, 1024, 5, 51, 0, 0, 1023,
		1018, 1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 133, 1, 0, 0, 0, 1025,
		1027, 3, 132, 66, 0, 1026, 1025, 1, 0, 0, 0, 1027, 1030, 1, 0, 0, 0, 1028,
		1026, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1034, 1, 0, 0, 0, 1030,
		1028, 1, 0, 0, 0, 1031, 1033, 3, 136, 68, 0, 1032, 1031, 1, 0, 0, 0, 1033,
		1036, 1, 0, 0, 0, 1034, 1032, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035,
		1037, 1, 0, 0, 0, 1036, 1034, 1, 0, 0, 0, 1037, 1038, 5, 34, 0, 0, 1038,
		1040, 5, 122, 0, 0, 1039, 1041, 3, 278, 139, 0, 1040, 1039, 1, 0, 0, 0,
		1040, 1041, 1, 0, 0, 0, 1041, 1044, 1, 0, 0, 0, 1042, 1043, 5, 88, 0, 0,
		1043, 1045, 3, 138, 69, 0, 1044, 1042, 1, 0, 0, 0, 1044, 1045, 1, 0, 0,
		0, 1045, 1046, 1, 0, 0, 0, 1046, 1047, 3, 140, 70, 0, 1047, 135, 1, 0,
		0, 0, 1048, 1049, 5, 23, 0, 0, 1049, 137, 1, 0, 0, 0, 1050, 1055, 3, 58,
		29, 0, 1051, 1052, 5, 49, 0, 0, 1052, 1054, 3, 58, 29, 0, 1053, 1051, 1,
		0, 0, 0, 1054, 1057, 1, 0, 0, 0, 1055, 1053, 1, 0, 0, 0, 1055, 1056, 1,
		0, 0, 0, 1056, 139, 1, 0, 0, 0, 1057, 1055, 1, 0, 0, 0, 1058, 1073, 5,
		54, 0, 0, 1059, 1064, 3, 4, 2, 0, 1060, 1064, 3, 142, 71, 0, 1061, 1064,
		3, 146, 73, 0, 1062, 1064, 3, 150, 75, 0, 1063, 1059, 1, 0, 0, 0, 1063,
		1060, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1063, 1062, 1, 0, 0, 0, 1064,
		1068, 1, 0, 0, 0, 1065, 1067, 5, 91, 0, 0, 1066, 1065, 1, 0, 0, 0, 1067,
		1070, 1, 0, 0, 0, 1068, 1066, 1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069,
		1072, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1071, 1063, 1, 0, 0, 0, 1072,
		1075, 1, 0, 0, 0, 1073, 1071, 1, 0, 0, 0, 1073, 1074, 1, 0, 0, 0, 1074,
		1076, 1, 0, 0, 0, 1075, 1073, 1, 0, 0, 0, 1076, 1077, 5, 55, 0, 0, 1077,
		141, 1, 0, 0, 0, 1078, 1080, 3, 132, 66, 0, 1079, 1078, 1, 0, 0, 0, 1080,
		1083, 1, 0, 0, 0, 1081, 1079, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082,
		1087, 1, 0, 0, 0, 1083, 1081, 1, 0, 0, 0, 1084, 1086, 3, 144, 72, 0, 1085,
		1084, 1, 0, 0, 0, 1086, 1089, 1, 0, 0, 0, 1087, 1085, 1, 0, 0, 0, 1087,
		1088, 1, 0, 0, 0, 1088, 1090, 1, 0, 0, 0, 1089, 1087, 1, 0, 0, 0, 1090,
		1091, 5, 122, 0, 0, 1091, 1092, 5, 88, 0, 0, 1092, 1095, 3, 286, 143, 0,
		1093, 1094, 5, 68, 0, 0, 1094, 1096, 3, 54, 27, 0, 1095, 1093, 1, 0, 0,
		0, 1095, 1096, 1, 0, 0, 0, 1096, 143, 1, 0, 0, 0, 1097, 1098, 7, 17, 0,
		0, 1098, 145, 1, 0, 0, 0, 1099, 1101, 3, 132, 66, 0, 1100, 1099, 1, 0,
		0, 0, 1101, 1104, 1, 0, 0, 0, 1102, 1100, 1, 0, 0, 0, 1102, 1103, 1, 0,
		0, 0, 1103, 1108, 1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1105, 1107, 3, 148,
		74, 0, 1106, 1105, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106, 1, 0,
		0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1113, 1, 0, 0, 0, 1110, 1108, 1, 0,
		0, 0, 1111, 1114, 3, 118, 59, 0, 1112, 1114, 3, 122, 61, 0, 1113, 1111,
		1, 0, 0, 0, 1113, 1112, 1, 0, 0, 0, 1114, 147, 1, 0, 0, 0, 1115, 1116,
		7, 18, 0, 0, 1116, 149, 1, 0, 0, 0, 1117, 1119, 3, 132, 66, 0, 1118, 1117,
		1, 0, 0, 0, 1119, 1122, 1, 0, 0, 0, 1120, 1118, 1, 0, 0, 0, 1120, 1121,
		1, 0, 0, 0, 1121, 1124, 1, 0, 0, 0, 1122, 1120, 1, 0, 0, 0, 1123, 1125,
		3, 152, 76, 0, 1124, 1123, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1126,
		1, 0, 0, 0, 1126, 1127, 5, 122, 0, 0, 1127, 1134, 3, 154, 77, 0, 1128,
		1130, 5, 29, 0, 0, 1129, 1128, 1, 0, 0, 0, 1129, 1130, 1, 0, 0, 0, 1130,
		1131, 1, 0, 0, 0, 1131, 1135, 3, 2, 1, 0, 1132, 1133, 5, 86, 0, 0, 1133,
		1135, 3, 2, 1, 0, 1134, 1129, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1134,
		1135, 1, 0, 0, 0, 1135, 151, 1, 0, 0, 0, 1136, 1137, 5, 20, 0, 0, 1137,
		153, 1, 0, 0, 0, 1138, 1148, 5, 50, 0, 0, 1139, 1141, 3, 102, 51, 0, 1140,
		1139, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1149, 1, 0, 0, 0, 1142,
		1145, 3, 102, 51, 0, 1143, 1144, 5, 49, 0, 0, 1144, 1146, 3, 156, 78, 0,
		1145, 1143, 1, 0, 0, 0, 1145, 1146, 1, 0, 0, 0, 1146, 1149, 1, 0, 0, 0,
		1147, 1149, 3, 156, 78, 0, 1148, 1140, 1, 0, 0, 0, 1148, 1142, 1, 0, 0,
		0, 1148, 1147, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150, 1151, 5, 51, 0,
		0, 1151, 155, 1, 0, 0, 0, 1152, 1154, 5, 54, 0, 0, 1153, 1155, 3, 158,
		79, 0, 1154, 1153, 1, 0, 0, 0, 1154, 1155, 1, 0, 0, 0, 1155, 1156, 1, 0,
		0, 0, 1156, 1157, 5, 55, 0, 0, 1157, 157, 1, 0, 0, 0, 1158, 1163, 3, 160,
		80, 0, 1159, 1160, 5, 49, 0, 0, 1160, 1162, 3, 160, 80, 0, 1161, 1159,
		1, 0, 0, 0, 1162, 1165, 1, 0, 0, 0, 1163, 1161, 1, 0, 0, 0, 1163, 1164,
		1, 0, 0, 0, 1164, 159, 1, 0, 0, 0, 1165, 1163, 1, 0, 0, 0, 1166, 1168,
		5, 24, 0, 0, 1167, 1166, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1169,
		1, 0, 0, 0, 1169, 1180, 3, 104, 52, 0, 1170, 1172, 5, 24, 0, 0, 1171, 1170,
		1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1173, 1, 0, 0, 0, 1173, 1174,
		7, 19, 0, 0, 1174, 1177, 3, 162, 81, 0, 1175, 1176, 5, 68, 0, 0, 1176,
		1178, 3, 54, 27, 0, 1177, 1175, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178,
		1180, 1, 0, 0, 0, 1179, 1167, 1, 0, 0, 0, 1179, 1171, 1, 0, 0, 0, 1180,
		161, 1, 0, 0, 0, 1181, 1182, 5, 47, 0, 0, 1182, 1184, 5, 122, 0, 0, 1183,
		1185, 3, 162, 81, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185,
		163, 1, 0, 0, 0, 1186, 1187, 5, 122, 0, 0, 1187, 1188, 5, 54, 0, 0, 1188,
		1189, 3, 72, 36, 0, 1189, 1190, 5, 55, 0, 0, 1190, 165, 1, 0, 0, 0, 1191,
		1193, 3, 132, 66, 0, 1192, 1191, 1, 0, 0, 0, 1193, 1196, 1, 0, 0, 0, 1194,
		1192, 1, 0, 0, 0, 1194, 1195, 1, 0, 0, 0, 1195, 1198, 1, 0, 0, 0, 1196,
		1194, 1, 0, 0, 0, 1197, 1199, 3, 168, 84, 0, 1198, 1197, 1, 0, 0, 0, 1198,
		1199, 1, 0, 0, 0, 1199, 1200, 1, 0, 0, 0, 1200, 1201, 5, 33, 0, 0, 1201,
		1203, 5, 122, 0, 0, 1202, 1204, 3, 278, 139, 0, 1203, 1202, 1, 0, 0, 0,
		1203, 1204, 1, 0, 0, 0, 1204, 1208, 1, 0, 0, 0, 1205, 1209, 3, 170, 85,
		0, 1206, 1209, 3, 172, 86, 0, 1207, 1209, 3, 174, 87, 0, 1208, 1205, 1,
		0, 0, 0, 1208, 1206, 1, 0, 0, 0, 1208, 1207, 1, 0, 0, 0, 1209, 167, 1,
		0, 0, 0, 1210, 1211, 7, 20, 0, 0, 1211, 169, 1, 0, 0, 0, 1212, 1213, 5,
		54, 0, 0, 1213, 1224, 3, 176, 88, 0, 1214, 1218, 5, 49, 0, 0, 1215, 1217,
		3, 4, 2, 0, 1216, 1215, 1, 0, 0, 0, 1217, 1220, 1, 0, 0, 0, 1218, 1216,
		1, 0, 0, 0, 1218, 1219, 1, 0, 0, 0, 1219, 1221, 1, 0, 0, 0, 1220, 1218,
		1, 0, 0, 0, 1221, 1223, 3, 176, 88, 0, 1222, 1214, 1, 0, 0, 0, 1223, 1226,
		1, 0, 0, 0, 1224, 1222, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1227,
		1, 0, 0, 0, 1226, 1224, 1, 0, 0, 0, 1227, 1228, 5, 55, 0, 0, 1228, 171,
		1, 0, 0, 0, 1229, 1231, 5, 54, 0, 0, 1230, 1232, 3, 178, 89, 0, 1231, 1230,
		1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1234, 1, 0, 0, 0, 1233, 1235,
		3, 190, 95, 0, 1234, 1233, 1, 0, 0, 0, 1234, 1235, 1, 0, 0, 0, 1235, 1236,
		1, 0, 0, 0, 1236, 1238, 3, 186, 93, 0, 1237, 1239, 5, 91, 0, 0, 1238, 1237,
		1, 0, 0, 0, 1238, 1239, 1, 0, 0, 0, 1239, 1241, 1, 0, 0, 0, 1240, 1242,
		3, 202, 101, 0, 1241, 1240, 1, 0, 0, 0, 1241, 1242, 1, 0, 0, 0, 1242, 1243,
		1, 0, 0, 0, 1243, 1244, 5, 55, 0, 0, 1244, 173, 1, 0, 0, 0, 1245, 1246,
		5, 54, 0, 0, 1246, 1257, 3, 204, 102, 0, 1247, 1251, 5, 49, 0, 0, 1248,
		1250, 3, 4, 2, 0, 1249, 1248, 1, 0, 0, 0, 1250, 1253, 1, 0, 0, 0, 1251,
		1249, 1, 0, 0, 0, 1251, 1252, 1, 0, 0, 0, 1252, 1254, 1, 0, 0, 0, 1253,
		1251, 1, 0, 0, 0, 1254, 1256, 3, 204, 102, 0, 1255, 1247, 1, 0, 0, 0, 1256,
		1259, 1, 0, 0, 0, 1257, 1255, 1, 0, 0, 0, 1257, 1258, 1, 0, 0, 0, 1258,
		1261, 1, 0, 0, 0, 1259, 1257, 1, 0, 0, 0, 1260, 1262, 3, 206, 103, 0, 1261,
		1260, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263,
		1264, 5, 55, 0, 0, 1264, 175, 1, 0, 0, 0, 1265, 1268, 5, 122, 0, 0, 1266,
		1267, 5, 68, 0, 0, 1267, 1269, 3, 54, 27, 0, 1268, 1266, 1, 0, 0, 0, 1268,
		1269, 1, 0, 0, 0, 1269, 1271, 1, 0, 0, 0, 1270, 1272, 3, 4, 2, 0, 1271,
		1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 177, 1, 0, 0, 0, 1273,
		1278, 3, 180, 90, 0, 1274, 1275, 5, 49, 0, 0, 1275, 1277, 3, 180, 90, 0,
		1276, 1274, 1, 0, 0, 0, 1277, 1280, 1, 0, 0, 0, 1278, 1276, 1, 0, 0, 0,
		1278, 1279, 1, 0, 0, 0, 1279, 1281, 1, 0, 0, 0, 1280, 1278, 1, 0, 0, 0,
		1281, 1282, 5, 91, 0, 0, 1282, 179, 1, 0, 0, 0, 1283, 1285, 3, 182, 91,
		0, 1284, 1283, 1, 0, 0, 0, 1285, 1288, 1, 0, 0, 0, 1286, 1284, 1, 0, 0,
		0, 1286, 1287, 1, 0, 0, 0, 1287, 1289, 1, 0, 0, 0, 1288, 1286, 1, 0, 0,
		0, 1289, 1290, 5, 122, 0, 0, 1290, 1291, 5, 88, 0, 0, 1291, 1292, 3, 286,
		143, 0, 1292, 181, 1, 0, 0, 0, 1293, 1294, 7, 21, 0, 0, 1294, 183, 1, 0,
		0, 0, 1295, 1296, 5, 122, 0, 0, 1296, 1297, 5, 88, 0, 0, 1297, 1298, 3,
		286, 143, 0, 1298, 185, 1, 0, 0, 0, 1299, 1310, 3, 188, 94, 0, 1300, 1304,
		5, 49, 0, 0, 1301, 1303, 3, 4, 2, 0, 1302, 1301, 1, 0, 0, 0, 1303, 1306,
		1, 0, 0, 0, 1304, 1302, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1307,
		1, 0, 0, 0, 1306, 1304, 1, 0, 0, 0, 1307, 1309, 3, 188, 94, 0, 1308, 1300,
		1, 0, 0, 0, 1309, 1312, 1, 0, 0, 0, 1310, 1308, 1, 0, 0, 0, 1310, 1311,
		1, 0, 0, 0, 1311, 187, 1, 0, 0, 0, 1312, 1310, 1, 0, 0, 0, 1313, 1314,
		5, 122, 0, 0, 1314, 1316, 5, 50, 0, 0, 1315, 1317, 3, 56, 28, 0, 1316,
		1315, 1, 0, 0, 0, 1316, 1317, 1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318,
		1319, 5, 51, 0, 0, 1319, 189, 1, 0, 0, 0, 1320, 1322, 3, 192, 96, 0, 1321,
		1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1321, 1, 0, 0, 0, 1323,
		1324, 1, 0, 0, 0, 1324, 191, 1, 0, 0, 0, 1325, 1327, 3, 132, 66, 0, 1326,
		1325, 1, 0, 0, 0, 1327, 1330, 1, 0, 0, 0, 1328, 1326, 1, 0, 0, 0, 1328,
		1329, 1, 0, 0, 0, 1329, 1332, 1, 0, 0, 0, 1330, 1328, 1, 0, 0, 0, 1331,
		1333, 3, 216, 108, 0, 1332, 1331, 1, 0, 0, 0, 1332, 1333, 1, 0, 0, 0, 1333,
		1334, 1, 0, 0, 0, 1334, 1335, 3, 194, 97, 0, 1335, 1352, 3, 196, 98, 0,
		1336, 1338, 3, 200, 100, 0, 1337, 1336, 1, 0, 0, 0, 1337, 1338, 1, 0, 0,
		0, 1338, 1340, 1, 0, 0, 0, 1339, 1341, 5, 29, 0, 0, 1340, 1339, 1, 0, 0,
		0, 1340, 1341, 1, 0, 0, 0, 1341, 1342, 1, 0, 0, 0, 1342, 1353, 3, 2, 1,
		0, 1343, 1345, 3, 200, 100, 0, 1344, 1343, 1, 0, 0, 0, 1344, 1345, 1, 0,
		0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1347, 5, 86, 0, 0, 1347, 1353, 3, 2,
		1, 0, 1348, 1350, 3, 200, 100, 0, 1349, 1348, 1, 0, 0, 0, 1349, 1350, 1,
		0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351, 1353, 5, 91, 0, 0, 1352, 1337, 1,
		0, 0, 0, 1352, 1344, 1, 0, 0, 0, 1352, 1349, 1, 0, 0, 0, 1352, 1353, 1,
		0, 0, 0, 1353, 193, 1, 0, 0, 0, 1354, 1357, 5, 122, 0, 0, 1355, 1356, 5,
		47, 0, 0, 1356, 1358, 5, 122, 0, 0, 1357, 1355, 1, 0, 0, 0, 1357, 1358,
		1, 0, 0, 0, 1358, 195, 1, 0, 0, 0, 1359, 1370, 5, 50, 0, 0, 1360, 1371,
		3, 198, 99, 0, 1361, 1366, 3, 102, 51, 0, 1362, 1363, 5, 49, 0, 0, 1363,
		1365, 3, 198, 99, 0, 1364, 1362, 1, 0, 0, 0, 1365, 1368, 1, 0, 0, 0, 1366,
		1364, 1, 0, 0, 0, 1366, 1367, 1, 0, 0, 0, 1367, 1371, 1, 0, 0, 0, 1368,
		1366, 1, 0, 0, 0, 1369, 1371, 3, 102, 51, 0, 1370, 1360, 1, 0, 0, 0, 1370,
		1361, 1, 0, 0, 0, 1370, 1369, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371,
		1372, 1, 0, 0, 0, 1372, 1373, 5, 51, 0, 0, 1373, 197, 1, 0, 0, 0, 1374,
		1375, 3, 50, 25, 0, 1375, 1376, 5, 68, 0, 0, 1376, 1377, 3, 54, 27, 0,
		1377, 199, 1, 0, 0, 0, 1378, 1379, 5, 88, 0, 0, 1379, 1380, 3, 198, 99,
		0, 1380, 201, 1, 0, 0, 0, 1381, 1383, 3, 208, 104, 0, 1382, 1381, 1, 0,
		0, 0, 1383, 1384, 1, 0, 0, 0, 1384, 1382, 1, 0, 0, 0, 1384, 1385, 1, 0,
		0, 0, 1385, 203, 1, 0, 0, 0, 1386, 1387, 5, 122, 0, 0, 1387, 1388, 5, 54,
		0, 0, 1388, 1393, 3, 184, 92, 0, 1389, 1390, 5, 49, 0, 0, 1390, 1392, 3,
		184, 92, 0, 1391, 1389, 1, 0, 0, 0, 1392, 1395, 1, 0, 0, 0, 1393, 1391,
		1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394, 1396, 1, 0, 0, 0, 1395, 1393,
		1, 0, 0, 0, 1396, 1397, 5, 55, 0, 0, 1397, 205, 1, 0, 0, 0, 1398, 1400,
		3, 208, 104, 0, 1399, 1398, 1, 0, 0, 0, 1400, 1401, 1, 0, 0, 0, 1401, 1399,
		1, 0, 0, 0, 1401, 1402, 1, 0, 0, 0, 1402, 207, 1, 0, 0, 0, 1403, 1405,
		3, 132, 66, 0, 1404, 1403, 1, 0, 0, 0, 1405, 1408, 1, 0, 0, 0, 1406, 1404,
		1, 0, 0, 0, 1406, 1407, 1, 0, 0, 0, 1407, 1412, 1, 0, 0, 0, 1408, 1406,
		1, 0, 0, 0, 1409, 1411, 3, 210, 105, 0, 1410, 1409, 1, 0, 0, 0, 1411, 1414,
		1, 0, 0, 0, 1412, 1410, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413, 1417,
		1, 0, 0, 0, 1414, 1412, 1, 0, 0, 0, 1415, 1418, 3, 118, 59, 0, 1416, 1418,
		3, 122, 61, 0, 1417, 1415, 1, 0, 0, 0, 1417, 1416, 1, 0, 0, 0, 1418, 209,
		1, 0, 0, 0, 1419, 1420, 7, 18, 0, 0, 1420, 211, 1, 0, 0, 0, 1421, 1423,
		3, 132, 66, 0, 1422, 1421, 1, 0, 0, 0, 1423, 1426, 1, 0, 0, 0, 1424, 1422,
		1, 0, 0, 0, 1424, 1425, 1, 0, 0, 0, 1425, 1430, 1, 0, 0, 0, 1426, 1424,
		1, 0, 0, 0, 1427, 1429, 3, 214, 107, 0, 1428, 1427, 1, 0, 0, 0, 1429, 1432,
		1, 0, 0, 0, 1430, 1428, 1, 0, 0, 0, 1430, 1431, 1, 0, 0, 0, 1431, 1433,
		1, 0, 0, 0, 1432, 1430, 1, 0, 0, 0, 1433, 1434, 5, 122, 0, 0, 1434, 1435,
		5, 88, 0, 0, 1435, 1436, 3, 286, 143, 0, 1436, 213, 1, 0, 0, 0, 1437, 1438,
		7, 20, 0, 0, 1438, 215, 1, 0, 0, 0, 1439, 1440, 5, 20, 0, 0, 1440, 217,
		1, 0, 0, 0, 1441, 1442, 3, 220, 110, 0, 1442, 1443, 5, 49, 0, 0, 1443,
		1445, 1, 0, 0, 0, 1444, 1441, 1, 0, 0, 0, 1445, 1448, 1, 0, 0, 0, 1446,
		1444, 1, 0, 0, 0, 1446, 1447, 1, 0, 0, 0, 1447, 1449, 1, 0, 0, 0, 1448,
		1446, 1, 0, 0, 0, 1449, 1450, 3, 220, 110, 0, 1450, 1451, 5, 91, 0, 0,
		1451, 219, 1, 0, 0, 0, 1452, 1453, 5, 122, 0, 0, 1453, 1455, 5, 50, 0,
		0, 1454, 1456, 3, 56, 28, 0, 1455, 1454, 1, 0, 0, 0, 1455, 1456, 1, 0,
		0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1458, 5, 51, 0, 0, 1458, 221, 1, 0,
		0, 0, 1459, 1461, 3, 132, 66, 0, 1460, 1459, 1, 0, 0, 0, 1461, 1464, 1,
		0, 0, 0, 1462, 1460, 1, 0, 0, 0, 1462, 1463, 1, 0, 0, 0, 1463, 1466, 1,
		0, 0, 0, 1464, 1462, 1, 0, 0, 0, 1465, 1467, 3, 224, 112, 0, 1466, 1465,
		1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467, 1468, 1, 0, 0, 0, 1468, 1469,
		5, 35, 0, 0, 1469, 1471, 5, 122, 0, 0, 1470, 1472, 3, 278, 139, 0, 1471,
		1470, 1, 0, 0, 0, 1471, 1472, 1, 0, 0, 0, 1472, 1473, 1, 0, 0, 0, 1473,
		1474, 3, 226, 113, 0, 1474, 223, 1, 0, 0, 0, 1475, 1476, 5, 23, 0, 0, 1476,
		225, 1, 0, 0, 0, 1477, 1490, 5, 54, 0, 0, 1478, 1481, 3, 4, 2, 0, 1479,
		1481, 3, 228, 114, 0, 1480, 1478, 1, 0, 0, 0, 1480, 1479, 1, 0, 0, 0, 1481,
		1485, 1, 0, 0, 0, 1482, 1484, 5, 91, 0, 0, 1483, 1482, 1, 0, 0, 0, 1484,
		1487, 1, 0, 0, 0, 1485, 1483, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486,
		1489, 1, 0, 0, 0, 1487, 1485, 1, 0, 0, 0, 1488, 1480, 1, 0, 0, 0, 1489,
		1492, 1, 0, 0, 0, 1490, 1488, 1, 0, 0, 0, 1490, 1491, 1, 0, 0, 0, 1491,
		1493, 1, 0, 0, 0, 1492, 1490, 1, 0, 0, 0, 1493, 1494, 5, 55, 0, 0, 1494,
		227, 1, 0, 0, 0, 1495, 1497, 3, 230, 115, 0, 1496, 1495, 1, 0, 0, 0, 1497,
		1500, 1, 0, 0, 0, 1498, 1496, 1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499,
		1503, 1, 0, 0, 0, 1500, 1498, 1, 0, 0, 0, 1501, 1504, 5, 122, 0, 0, 1502,
		1504, 3, 116, 58, 0, 1503, 1501, 1, 0, 0, 0, 1503, 1502, 1, 0, 0, 0, 1504,
		1505, 1, 0, 0, 0, 1505, 1506, 5, 88, 0, 0, 1506, 1507, 3, 286, 143, 0,
		1507, 229, 1, 0, 0, 0, 1508, 1509, 7, 17, 0, 0, 1509, 231, 1, 0, 0, 0,
		1510, 1511, 5, 36, 0, 0, 1511, 1512, 3, 58, 29, 0, 1512, 1515, 5, 37, 0,
		0, 1513, 1516, 3, 236, 118, 0, 1514, 1516, 3, 234, 117, 0, 1515, 1513,
		1, 0, 0, 0, 1515, 1514, 1, 0, 0, 0, 1516, 233, 1, 0, 0, 0, 1517, 1522,
		3, 58, 29, 0, 1518, 1519, 5, 49, 0, 0, 1519, 1521, 3, 58, 29, 0, 1520,
		1518, 1, 0, 0, 0, 1521, 1524, 1, 0, 0, 0, 1522, 1520, 1, 0, 0, 0, 1522,
		1523, 1, 0, 0, 0, 1523, 235, 1, 0, 0, 0, 1524, 1522, 1, 0, 0, 0, 1525,
		1526, 3, 58, 29, 0, 1526, 1527, 3, 140, 70, 0, 1527, 237, 1, 0, 0, 0, 1528,
		1534, 5, 40, 0, 0, 1529, 1535, 3, 240, 120, 0, 1530, 1535, 3, 242, 121,
		0, 1531, 1535, 3, 244, 122, 0, 1532, 1535, 3, 246, 123, 0, 1533, 1535,
		3, 248, 124, 0, 1534, 1529, 1, 0, 0, 0, 1534, 1530, 1, 0, 0, 0, 1534, 1531,
		1, 0, 0, 0, 1534, 1532, 1, 0, 0, 0, 1534, 1533, 1, 0, 0, 0, 1535, 239,
		1, 0, 0, 0, 1536, 1537, 5, 33, 0, 0, 1537, 1541, 5, 122, 0, 0, 1538, 1542,
		3, 170, 85, 0, 1539, 1542, 3, 172, 86, 0, 1540, 1542, 3, 174, 87, 0, 1541,
		1538, 1, 0, 0, 0, 1541, 1539, 1, 0, 0, 0, 1541, 1540, 1, 0, 0, 0, 1542,
		241, 1, 0, 0, 0, 1543, 1544, 5, 34, 0, 0, 1544, 1545, 5, 122, 0, 0, 1545,
		1546, 3, 140, 70, 0, 1546, 243, 1, 0, 0, 0, 1547, 1548, 5, 35, 0, 0, 1548,
		1549, 5, 122, 0, 0, 1549, 1550, 3, 226, 113, 0, 1550, 245, 1, 0, 0, 0,
		1551, 1552, 5, 5, 0, 0, 1552, 1553, 5, 122, 0, 0, 1553, 1555, 5, 54, 0,
		0, 1554, 1556, 3, 286, 143, 0, 1555, 1554, 1, 0, 0, 0, 1555, 1556, 1, 0,
		0, 0, 1556, 1557, 1, 0, 0, 0, 1557, 1558, 5, 55, 0, 0, 1558, 247, 1, 0,
		0, 0, 1559, 1560, 5, 1, 0, 0, 1560, 1561, 5, 122, 0, 0, 1561, 1565, 5,
		54, 0, 0, 1562, 1564, 3, 264, 132, 0, 1563, 1562, 1, 0, 0, 0, 1564, 1567,
		1, 0, 0, 0, 1565, 1563, 1, 0, 0, 0, 1565, 1566, 1, 0, 0, 0, 1566, 1568,
		1, 0, 0, 0, 1567, 1565, 1, 0, 0, 0, 1568, 1569, 5, 55, 0, 0, 1569, 249,
		1, 0, 0, 0, 1570, 1574, 5, 3, 0, 0, 1571, 1575, 3, 254, 127, 0, 1572, 1575,
		3, 252, 126, 0, 1573, 1575, 3, 256, 128, 0, 1574, 1571, 1, 0, 0, 0, 1574,
		1572, 1, 0, 0, 0, 1574, 1573, 1, 0, 0, 0, 1575, 251, 1, 0, 0, 0, 1576,
		1578, 5, 114, 0, 0, 1577, 1579, 3, 258, 129, 0, 1578, 1577, 1, 0, 0, 0,
		1578, 1579, 1, 0, 0, 0, 1579, 253, 1, 0, 0, 0, 1580, 1582, 5, 57, 0, 0,
		1581, 1583, 3, 258, 129, 0, 1582, 1581, 1, 0, 0, 0, 1582, 1583, 1, 0, 0,
		0, 1583, 1584, 1, 0, 0, 0, 1584, 1585, 5, 4, 0, 0, 1585, 1586, 5, 114,
		0, 0, 1586, 255, 1, 0, 0, 0, 1587, 1596, 5, 54, 0, 0, 1588, 1593, 3, 260,
		130, 0, 1589, 1590, 5, 49, 0, 0, 1590, 1592, 3, 260, 130, 0, 1591, 1589,
		1, 0, 0, 0, 1592, 1595, 1, 0, 0, 0, 1593, 1591, 1, 0, 0, 0, 1593, 1594,
		1, 0, 0, 0, 1594, 1597, 1, 0, 0, 0, 1595, 1593, 1, 0, 0, 0, 1596, 1588,
		1, 0, 0, 0, 1596, 1597, 1, 0, 0, 0, 1597, 1598, 1, 0, 0, 0, 1598, 1599,
		5, 55, 0, 0, 1599, 1600, 5, 4, 0, 0, 1600, 1601, 5, 114, 0, 0, 1601, 257,
		1, 0, 0, 0, 1602, 1603, 5, 7, 0, 0, 1603, 1604, 5, 122, 0, 0, 1604, 259,
		1, 0, 0, 0, 1605, 1607, 5, 122, 0, 0, 1606, 1608, 3, 258, 129, 0, 1607,
		1606, 1, 0, 0, 0, 1607, 1608, 1, 0, 0, 0, 1608, 261, 1, 0, 0, 0, 1609,
		1611, 5, 23, 0, 0, 1610, 1609, 1, 0, 0, 0, 1610, 1611, 1, 0, 0, 0, 1611,
		1612, 1, 0, 0, 0, 1612, 1613, 5, 1, 0, 0, 1613, 1614, 5, 122, 0, 0, 1614,
		1618, 5, 54, 0, 0, 1615, 1617, 3, 264, 132, 0, 1616, 1615, 1, 0, 0, 0,
		1617, 1620, 1, 0, 0, 0, 1618, 1616, 1, 0, 0, 0, 1618, 1619, 1, 0, 0, 0,
		1619, 1621, 1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1621, 1622, 5, 55, 0, 0,
		1622, 263, 1, 0, 0, 0, 1623, 1632, 3, 266, 133, 0, 1624, 1632, 3, 262,
		131, 0, 1625, 1632, 3, 134, 67, 0, 1626, 1632, 3, 166, 83, 0, 1627, 1632,
		3, 222, 111, 0, 1628, 1632, 3, 114, 57, 0, 1629, 1632, 3, 238, 119, 0,
		1630, 1632, 3, 8, 4, 0, 1631, 1623, 1, 0, 0, 0, 1631, 1624, 1, 0, 0, 0,
		1631, 1625, 1, 0, 0, 0, 1631, 1626, 1, 0, 0, 0, 1631, 1627, 1, 0, 0, 0,
		1631, 1628, 1, 0, 0, 0, 1631, 1629, 1, 0, 0, 0, 1631, 1630, 1, 0, 0, 0,
		1632, 265, 1, 0, 0, 0, 1633, 1637, 5, 2, 0, 0, 1634, 1638, 3, 268, 134,
		0, 1635, 1638, 3, 270, 135, 0, 1636, 1638, 3, 272, 136, 0, 1637, 1634,
		1, 0, 0, 0, 1637, 1635, 1, 0, 0, 0, 1637, 1636, 1, 0, 0, 0, 1638, 267,
		1, 0, 0, 0, 1639, 1641, 5, 122, 0, 0, 1640, 1642, 3, 258, 129, 0, 1641,
		1640, 1, 0, 0, 0, 1641, 1642, 1, 0, 0, 0, 1642, 269, 1, 0, 0, 0, 1643,
		1644, 5, 54, 0, 0, 1644, 1649, 3, 260, 130, 0, 1645, 1646, 5, 49, 0, 0,
		1646, 1648, 3, 260, 130, 0, 1647, 1645, 1, 0, 0, 0, 1648, 1651, 1, 0, 0,
		0, 1649, 1647, 1, 0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650, 1652, 1, 0, 0,
		0, 1651, 1649, 1, 0, 0, 0, 1652, 1653, 5, 55, 0, 0, 1653, 1654, 5, 4, 0,
		0, 1654, 1655, 5, 114, 0, 0, 1655, 271, 1, 0, 0, 0, 1656, 1658, 5, 57,
		0, 0, 1657, 1659, 3, 258, 129, 0, 1658, 1657, 1, 0, 0, 0, 1658, 1659, 1,
		0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1661, 5, 4, 0, 0, 1661, 1662, 5,
		114, 0, 0, 1662, 273, 1, 0, 0, 0, 1663, 1664, 5, 5, 0, 0, 1664, 1666, 5,
		122, 0, 0, 1665, 1667, 3, 278, 139, 0, 1666, 1665, 1, 0, 0, 0, 1666, 1667,
		1, 0, 0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 1669, 5, 68, 0, 0, 1669, 1670,
		3, 286, 143, 0, 1670, 275, 1, 0, 0, 0, 1671, 1673, 5, 76, 0, 0, 1672, 1674,
		3, 300, 150, 0, 1673, 1672, 1, 0, 0, 0, 1673, 1674, 1, 0, 0, 0, 1674, 1675,
		1, 0, 0, 0, 1675, 1676, 5, 77, 0, 0, 1676, 277, 1, 0, 0, 0, 1677, 1678,
		5, 76, 0, 0, 1678, 1679, 3, 280, 140, 0, 1679, 1680, 5, 77, 0, 0, 1680,
		279, 1, 0, 0, 0, 1681, 1686, 3, 282, 141, 0, 1682, 1683, 5, 49, 0, 0, 1683,
		1685, 3, 282, 141, 0, 1684, 1682, 1, 0, 0, 0, 1685, 1688, 1, 0, 0, 0, 1686,
		1684, 1, 0, 0, 0, 1686, 1687, 1, 0, 0, 0, 1687, 281, 1, 0, 0, 0, 1688,
		1686, 1, 0, 0, 0, 1689, 1692, 5, 122, 0, 0, 1690, 1691, 5, 88, 0, 0, 1691,
		1693, 3, 286, 143, 0, 1692, 1690, 1, 0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693,
		283, 1, 0, 0, 0, 1694, 1695, 5, 99, 0, 0, 1695, 1699, 3, 286, 143, 0, 1696,
		1697, 5, 98, 0, 0, 1697, 1699, 3, 286, 143, 0, 1698, 1694, 1, 0, 0, 0,
		1698, 1696, 1, 0, 0, 0, 1699, 1701, 1, 0, 0, 0, 1700, 1702, 3, 284, 142,
		0, 1701, 1700, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 0, 1702, 285, 1, 0, 0,
		0, 1703, 1705, 7, 22, 0, 0, 1704, 1706, 3, 298, 149, 0, 1705, 1704, 1,
		0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706, 1713, 1, 0, 0, 0, 1707, 1713, 3,
		58, 29, 0, 1708, 1713, 5, 114, 0, 0, 1709, 1713, 3, 312, 156, 0, 1710,
		1713, 3, 306, 153, 0, 1711, 1713, 3, 310, 155, 0, 1712, 1703, 1, 0, 0,
		0, 1712, 1707, 1, 0, 0, 0, 1712, 1708, 1, 0, 0, 0, 1712, 1709, 1, 0, 0,
		0, 1712, 1710, 1, 0, 0, 0, 1712, 1711, 1, 0, 0, 0, 1713, 1715, 1, 0, 0,
		0, 1714, 1716, 5, 64, 0, 0, 1715, 1714, 1, 0, 0, 0, 1715, 1716, 1, 0, 0,
		0, 1716, 1718, 1, 0, 0, 0, 1717, 1719, 3, 4, 2, 0, 1718, 1717, 1, 0, 0,
		0, 1718, 1719, 1, 0, 0, 0, 1719, 1721, 1, 0, 0, 0, 1720, 1722, 3, 284,
		142, 0, 1721, 1720, 1, 0, 0, 0, 1721, 1722, 1, 0, 0, 0, 1722, 287, 1, 0,
		0, 0, 1723, 1724, 7, 23, 0, 0, 1724, 289, 1, 0, 0, 0, 1725, 1726, 3, 286,
		143, 0, 1726, 1727, 5, 64, 0, 0, 1727, 291, 1, 0, 0, 0, 1728, 1733, 3,
		286, 143, 0, 1729, 1730, 5, 99, 0, 0, 1730, 1732, 3, 286, 143, 0, 1731,
		1729, 1, 0, 0, 0, 1732, 1735, 1, 0, 0, 0, 1733, 1731, 1, 0, 0, 0, 1733,
		1734, 1, 0, 0, 0, 1734, 293, 1, 0, 0, 0, 1735, 1733, 1, 0, 0, 0, 1736,
		1741, 3, 286, 143, 0, 1737, 1738, 5, 98, 0, 0, 1738, 1740, 3, 286, 143,
		0, 1739, 1737, 1, 0, 0, 0, 1740, 1743, 1, 0, 0, 0, 1741, 1739, 1, 0, 0,
		0, 1741, 1742, 1, 0, 0, 0, 1742, 295, 1, 0, 0, 0, 1743, 1741, 1, 0, 0,
		0, 1744, 1745, 3, 286, 143, 0, 1745, 1747, 5, 52, 0, 0, 1746, 1748, 5,
		113, 0, 0, 1747, 1746, 1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 1749,
		1, 0, 0, 0, 1749, 1750, 5, 53, 0, 0, 1750, 297, 1, 0, 0, 0, 1751, 1753,
		5, 52, 0, 0, 1752, 1754, 5, 113, 0, 0, 1753, 1752, 1, 0, 0, 0, 1753, 1754,
		1, 0, 0, 0, 1754, 1755, 1, 0, 0, 0, 1755, 1757, 5, 53, 0, 0, 1756, 1758,
		3, 298, 149, 0, 1757, 1756, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0, 1758, 299,
		1, 0, 0, 0, 1759, 1764, 3, 286, 143, 0, 1760, 1761, 5, 49, 0, 0, 1761,
		1763, 3, 286, 143, 0, 1762, 1760, 1, 0, 0, 0, 1763, 1766, 1, 0, 0, 0, 1764,
		1762, 1, 0, 0, 0, 1764, 1765, 1, 0, 0, 0, 1765, 301, 1, 0, 0, 0, 1766,
		1764, 1, 0, 0, 0, 1767, 1768, 5, 6, 0, 0, 1768, 1769, 3, 54, 27, 0, 1769,
		303, 1, 0, 0, 0, 1770, 1771, 3, 50, 25, 0, 1771, 1772, 5, 7, 0, 0, 1772,
		1773, 3, 286, 143, 0, 1773, 305, 1, 0, 0, 0, 1774, 1775, 5, 54, 0, 0, 1775,
		1780, 3, 308, 154, 0, 1776, 1777, 5, 49, 0, 0, 1777, 1779, 3, 308, 154,
		0, 1778, 1776, 1, 0, 0, 0, 1779, 1782, 1, 0, 0, 0, 1780, 1778, 1, 0, 0,
		0, 1780, 1781, 1, 0, 0, 0, 1781, 1783, 1, 0, 0, 0, 1782, 1780, 1, 0, 0,
		0, 1783, 1784, 5, 55, 0, 0, 1784, 307, 1, 0, 0, 0, 1785, 1786, 5, 122,
		0, 0, 1786, 1787, 5, 88, 0, 0, 1787, 1788, 3, 286, 143, 0, 1788, 309, 1,
		0, 0, 0, 1789, 1790, 5, 52, 0, 0, 1790, 1791, 3, 300, 150, 0, 1791, 1792,
		5, 53, 0, 0, 1792, 311, 1, 0, 0, 0, 1793, 1795, 3, 100, 50, 0, 1794, 1796,
		5, 29, 0, 0, 1795, 1794, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796, 1799,
		1, 0, 0, 0, 1797, 1798, 5, 84, 0, 0, 1798, 1800, 3, 120, 60, 0, 1799, 1797,
		1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 313, 1, 0, 0, 0, 1801, 1802,
		5, 25, 0, 0, 1802, 1806, 3, 2, 1, 0, 1803, 1805, 3, 316, 158, 0, 1804,
		1803, 1, 0, 0, 0, 1805, 1808, 1, 0, 0, 0, 1806, 1804, 1, 0, 0, 0, 1806,
		1807, 1, 0, 0, 0, 1807, 1810, 1, 0, 0, 0, 1808, 1806, 1, 0, 0, 0, 1809,
		1811, 3, 320, 160, 0, 1810, 1809, 1, 0, 0, 0, 1810, 1811, 1, 0, 0, 0, 1811,
		315, 1, 0, 0, 0, 1812, 1815, 5, 26, 0, 0, 1813, 1816, 3, 318, 159, 0, 1814,
		1816, 3, 58, 29, 0, 1815, 1813, 1, 0, 0, 0, 1815, 1814, 1, 0, 0, 0, 1815,
		1816, 1, 0, 0, 0, 1816, 1817, 1, 0, 0, 0, 1817, 1818, 3, 2, 1, 0, 1818,
		317, 1, 0, 0, 0, 1819, 1820, 5, 50, 0, 0, 1820, 1823, 5, 122, 0, 0, 1821,
		1822, 5, 88, 0, 0, 1822, 1824, 3, 286, 143, 0, 1823, 1821, 1, 0, 0, 0,
		1823, 1824, 1, 0, 0, 0, 1824, 1825, 1, 0, 0, 0, 1825, 1826, 5, 51, 0, 0,
		1826, 319, 1, 0, 0, 0, 1827, 1828, 5, 27, 0, 0, 1828, 1829, 3, 2, 1, 0,
		1829, 321, 1, 0, 0, 0, 1830, 1833, 5, 28, 0, 0, 1831, 1834, 3, 44, 22,
		0, 1832, 1834, 3, 62, 31, 0, 1833, 1831, 1, 0, 0, 0, 1833, 1832, 1, 0,
		0, 0, 1834, 323, 1, 0, 0, 0, 1835, 1837, 5, 17, 0, 0, 1836, 1838, 5, 122,
		0, 0, 1837, 1836, 1, 0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 325, 1, 0,
		0, 0, 1839, 1840, 5, 16, 0, 0, 1840, 327, 1, 0, 0, 0, 1841, 1842, 5, 8,
		0, 0, 1842, 1843, 3, 20, 10, 0, 1843, 1849, 3, 2, 1, 0, 1844, 1847, 5,
		9, 0, 0, 1845, 1848, 3, 328, 164, 0, 1846, 1848, 3, 2, 1, 0, 1847, 1845,
		1, 0, 0, 0, 1847, 1846, 1, 0, 0, 0, 1848, 1850, 1, 0, 0, 0, 1849, 1844,
		1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 329, 1, 0, 0, 0, 1851, 1852,
		5, 10, 0, 0, 1852, 1853, 3, 54, 27, 0, 1853, 1864, 5, 54, 0, 0, 1854, 1855,
		3, 332, 166, 0, 1855, 1859, 5, 49, 0, 0, 1856, 1858, 3, 4, 2, 0, 1857,
		1856, 1, 0, 0, 0, 1858, 1861, 1, 0, 0, 0, 1859, 1857, 1, 0, 0, 0, 1859,
		1860, 1, 0, 0, 0, 1860, 1863, 1, 0, 0, 0, 1861, 1859, 1, 0, 0, 0, 1862,
		1854, 1, 0, 0, 0, 1863, 1866, 1, 0, 0, 0, 1864, 1862, 1, 0, 0, 0, 1864,
		1865, 1, 0, 0, 0, 1865, 1877, 1, 0, 0, 0, 1866, 1864, 1, 0, 0, 0, 1867,
		1869, 3, 344, 172, 0, 1868, 1870, 5, 49, 0, 0, 1869, 1868, 1, 0, 0, 0,
		1869, 1870, 1, 0, 0, 0, 1870, 1874, 1, 0, 0, 0, 1871, 1873, 3, 4, 2, 0,
		1872, 1871, 1, 0, 0, 0, 1873, 1876, 1, 0, 0, 0, 1874, 1872, 1, 0, 0, 0,
		1874, 1875, 1, 0, 0, 0, 1875, 1878, 1, 0, 0, 0, 1876, 1874, 1, 0, 0, 0,
		1877, 1867, 1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 1879, 1, 0, 0, 0,
		1879, 1880, 5, 55, 0, 0, 1880, 331, 1, 0, 0, 0, 1881, 1888, 3, 286, 143,
		0, 1882, 1888, 3, 334, 167, 0, 1883, 1888, 3, 58, 29, 0, 1884, 1888, 3,
		338, 169, 0, 1885, 1888, 3, 54, 27, 0, 1886, 1888, 3, 78, 39, 0, 1887,
		1881, 1, 0, 0, 0, 1887, 1882, 1, 0, 0, 0, 1887, 1883, 1, 0, 0, 0, 1887,
		1884, 1, 0, 0, 0, 1887, 1885, 1, 0, 0, 0, 1887, 1886, 1, 0, 0, 0, 1888,
		1889, 1, 0, 0, 0, 1889, 1890, 5, 86, 0, 0, 1890, 1891, 3, 342, 171, 0,
		1891, 333, 1, 0, 0, 0, 1892, 1893, 3, 58, 29, 0, 1893, 1894, 5, 50, 0,
		0, 1894, 1899, 3, 336, 168, 0, 1895, 1896, 5, 49, 0, 0, 1896, 1898, 3,
		336, 168, 0, 1897, 1895, 1, 0, 0, 0, 1898, 1901, 1, 0, 0, 0, 1899, 1897,
		1, 0, 0, 0, 1899, 1900, 1, 0, 0, 0, 1900, 1902, 1, 0, 0, 0, 1901, 1899,
		1, 0, 0, 0, 1902, 1905, 5, 51, 0, 0, 1903, 1904, 5, 8, 0, 0, 1904, 1906,
		3, 54, 27, 0, 1905, 1903, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 335,
		1, 0, 0, 0, 1907, 1911, 5, 122, 0, 0, 1908, 1911, 3, 68, 34, 0, 1909, 1911,
		5, 67, 0, 0, 1910, 1907, 1, 0, 0, 0, 1910, 1908, 1, 0, 0, 0, 1910, 1909,
		1, 0, 0, 0, 1911, 337, 1, 0, 0, 0, 1912, 1913, 5, 50, 0, 0, 1913, 1918,
		3, 340, 170, 0, 1914, 1915, 5, 49, 0, 0, 1915, 1917, 3, 340, 170, 0, 1916,
		1914, 1, 0, 0, 0, 1917, 1920, 1, 0, 0, 0, 1918, 1916, 1, 0, 0, 0, 1918,
		1919, 1, 0, 0, 0, 1919, 1921, 1, 0, 0, 0, 1920, 1918, 1, 0, 0, 0, 1921,
		1924, 5, 51, 0, 0, 1922, 1923, 5, 8, 0, 0, 1923, 1925, 3, 54, 27, 0, 1924,
		1922, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 339, 1, 0, 0, 0, 1926,
		1927, 7, 24, 0, 0, 1927, 341, 1, 0, 0, 0, 1928, 1932, 3, 54, 27, 0, 1929,
		1932, 3, 112, 56, 0, 1930, 1932, 3, 2, 1, 0, 1931, 1928, 1, 0, 0, 0, 1931,
		1929, 1, 0, 0, 0, 1931, 1930, 1, 0, 0, 0, 1932, 343, 1, 0, 0, 0, 1933,
		1934, 5, 67, 0, 0, 1934, 1935, 5, 86, 0, 0, 1935, 1936, 3, 342, 171, 0,
		1936, 345, 1, 0, 0, 0, 1937, 1939, 3, 348, 174, 0, 1938, 1937, 1, 0, 0,
		0, 1938, 1939, 1, 0, 0, 0, 1939, 1945, 1, 0, 0, 0, 1940, 1946, 3, 366,
		183, 0, 1941, 1946, 3, 364, 182, 0, 1942, 1946, 3, 360, 180, 0, 1943, 1946,
		3, 356, 178, 0, 1944, 1946, 3, 350, 175, 0, 1945, 1940, 1, 0, 0, 0, 1945,
		1941, 1, 0, 0, 0, 1945, 1942, 1, 0, 0, 0, 1945, 1943, 1, 0, 0, 0, 1945,
		1944, 1, 0, 0, 0, 1946, 347, 1, 0, 0, 0, 1947, 1948, 5, 122, 0, 0, 1948,
		1949, 5, 88, 0, 0, 1949, 349, 1, 0, 0, 0, 1950, 1951, 5, 12, 0, 0, 1951,
		1952, 3, 352, 176, 0, 1952, 1953, 7, 25, 0, 0, 1953, 1954, 3, 54, 27, 0,
		1954, 1955, 3, 2, 1, 0, 1955, 351, 1, 0, 0, 0, 1956, 1964, 3, 354, 177,
		0, 1957, 1958, 5, 50, 0, 0, 1958, 1959, 3, 354, 177, 0, 1959, 1960, 5,
		49, 0, 0, 1960, 1961, 3, 354, 177, 0, 1961, 1962, 5, 51, 0, 0, 1962, 1964,
		1, 0, 0, 0, 1963, 1956, 1, 0, 0, 0, 1963, 1957, 1, 0, 0, 0, 1964, 353,
		1, 0, 0, 0, 1965, 1968, 3, 76, 38, 0, 1966, 1968, 3, 50, 25, 0, 1967, 1965,
		1, 0, 0, 0, 1967, 1966, 1, 0, 0, 0, 1968, 355, 1, 0, 0, 0, 1969, 1971,
		5, 12, 0, 0, 1970, 1972, 5, 50, 0, 0, 1971, 1970, 1, 0, 0, 0, 1971, 1972,
		1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973, 1975, 3, 358, 179, 0, 1974, 1976,
		5, 51, 0, 0, 1975, 1974, 1, 0, 0, 0, 1975, 1976, 1, 0, 0, 0, 1976, 1977,
		1, 0, 0, 0, 1977, 1978, 3, 2, 1, 0, 1978, 357, 1, 0, 0, 0, 1979, 1981,
		3, 6, 3, 0, 1980, 1979, 1, 0, 0, 0, 1980, 1981, 1, 0, 0, 0, 1981, 1982,
		1, 0, 0, 0, 1982, 1983, 5, 91, 0, 0, 1983, 1984, 3, 54, 27, 0, 1984, 1986,
		5, 91, 0, 0, 1985, 1987, 3, 54, 27, 0, 1986, 1985, 1, 0, 0, 0, 1986, 1987,
		1, 0, 0, 0, 1987, 359, 1, 0, 0, 0, 1988, 1989, 5, 12, 0, 0, 1989, 1990,
		5, 122, 0, 0, 1990, 1991, 5, 13, 0, 0, 1991, 1992, 3, 362, 181, 0, 1992,
		1993, 3, 2, 1, 0, 1993, 361, 1, 0, 0, 0, 1994, 1995, 5, 15, 0, 0, 1995,
		1996, 5, 50, 0, 0, 1996, 1997, 3, 54, 27, 0, 1997, 1998, 5, 49, 0, 0, 1998,
		2001, 3, 54, 27, 0, 1999, 2000, 5, 49, 0, 0, 2000, 2002, 3, 54, 27, 0,
		2001, 1999, 1, 0, 0, 0, 2001, 2002, 1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0,
		2003, 2004, 5, 51, 0, 0, 2004, 363, 1, 0, 0, 0, 2005, 2006, 5, 11, 0, 0,
		2006, 2007, 3, 2, 1, 0, 2007, 2008, 5, 12, 0, 0, 2008, 2009, 5, 50, 0,
		0, 2009, 2010, 3, 54, 27, 0, 2010, 2011, 5, 51, 0, 0, 2011, 365, 1, 0,
		0, 0, 2012, 2014, 5, 12, 0, 0, 2013, 2015, 3, 54, 27, 0, 2014, 2013, 1,
		0, 0, 0, 2014, 2015, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2017, 3,
		2, 1, 0, 2017, 367, 1, 0, 0, 0, 2018, 2019, 5, 42, 0, 0, 2019, 2020, 3,
		62, 31, 0, 2020, 369, 1, 0, 0, 0, 2021, 2029, 5, 41, 0, 0, 2022, 2030,
		3, 2, 1, 0, 2023, 2030, 3, 134, 67, 0, 2024, 2030, 3, 166, 83, 0, 2025,
		2030, 3, 222, 111, 0, 2026, 2030, 3, 114, 57, 0, 2027, 2030, 3, 262, 131,
		0, 2028, 2030, 3, 274, 137, 0, 2029, 2022, 1, 0, 0, 0, 2029, 2023, 1, 0,
		0, 0, 2029, 2024, 1, 0, 0, 0, 2029, 2025, 1, 0, 0, 0, 2029, 2026, 1, 0,
		0, 0, 2029, 2027, 1, 0, 0, 0, 2029, 2028, 1, 0, 0, 0, 2030, 371, 1, 0,
		0, 0, 2031, 2032, 3, 50, 25, 0, 2032, 2033, 5, 85, 0, 0, 2033, 2035, 7,
		26, 0, 0, 2034, 2036, 5, 98, 0, 0, 2035, 2034, 1, 0, 0, 0, 2035, 2036,
		1, 0, 0, 0, 2036, 373, 1, 0, 0, 0, 2037, 2038, 5, 85, 0, 0, 2038, 2039,
		3, 50, 25, 0, 2039, 375, 1, 0, 0, 0, 2040, 2041, 5, 112, 0, 0, 2041, 377,
		1, 0, 0, 0, 2042, 2043, 5, 43, 0, 0, 2043, 2058, 3, 2, 1, 0, 2044, 2045,
		5, 43, 0, 0, 2045, 2046, 5, 44, 0, 0, 2046, 2047, 3, 20, 10, 0, 2047, 2051,
		3, 2, 1, 0, 2048, 2050, 3, 380, 190, 0, 2049, 2048, 1, 0, 0, 0, 2050, 2053,
		1, 0, 0, 0, 2051, 2049, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2055,
		1, 0, 0, 0, 2053, 2051, 1, 0, 0, 0, 2054, 2056, 3, 382, 191, 0, 2055, 2054,
		1, 0, 0, 0, 2055, 2056, 1, 0, 0, 0, 2056, 2058, 1, 0, 0, 0, 2057, 2042,
		1, 0, 0, 0, 2057, 2044, 1, 0, 0, 0, 2058, 379, 1, 0, 0, 0, 2059, 2060,
		5, 9, 0, 0, 2060, 2061, 5, 44, 0, 0, 2061, 2062, 3, 20, 10, 0, 2062, 2063,
		3, 2, 1, 0, 2063, 381, 1, 0, 0, 0, 2064, 2065, 5, 9, 0, 0, 2065, 2066,
		3, 2, 1, 0, 2066, 383, 1, 0, 0, 0, 2067, 2068, 5, 46, 0, 0, 2068, 2069,
		3, 386, 193, 0, 2069, 385, 1, 0, 0, 0, 2070, 2075, 3, 388, 194, 0, 2071,
		2072, 5, 49, 0, 0, 2072, 2074, 3, 388, 194, 0, 2073, 2071, 1, 0, 0, 0,
		2074, 2077, 1, 0, 0, 0, 2075, 2073, 1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0,
		2076, 387, 1, 0, 0, 0, 2077, 2075, 1, 0, 0, 0, 2078, 2081, 5, 122, 0, 0,
		2079, 2080, 5, 88, 0, 0, 2080, 2082, 3, 286, 143, 0, 2081, 2079, 1, 0,
		0, 0, 2081, 2082, 1, 0, 0, 0, 2082, 389, 1, 0, 0, 0, 254, 394, 399, 407,
		412, 446, 451, 455, 460, 462, 466, 471, 473, 479, 486, 491, 502, 511, 518,
		526, 533, 540, 548, 556, 561, 564, 570, 586, 594, 605, 619, 635, 648, 655,
		662, 671, 675, 677, 680, 684, 688, 692, 696, 702, 706, 712, 716, 718, 723,
		729, 734, 739, 745, 747, 754, 757, 764, 775, 777, 787, 797, 802, 806, 809,
		813, 818, 824, 836, 841, 843, 847, 852, 855, 864, 870, 874, 878, 882, 886,
		890, 899, 903, 909, 914, 931, 936, 942, 945, 949, 953, 962, 967, 973, 976,
		990, 995, 1001, 1004, 1008, 1012, 1020, 1023, 1028, 1034, 1040, 1044, 1055,
		1063, 1068, 1073, 1081, 1087, 1095, 1102, 1108, 1113, 1120, 1124, 1129,
		1134, 1140, 1145, 1148, 1154, 1163, 1167, 1171, 1177, 1179, 1184, 1194,
		1198, 1203, 1208, 1218, 1224, 1231, 1234, 1238, 1241, 1251, 1257, 1261,
		1268, 1271, 1278, 1286, 1304, 1310, 1316, 1323, 1328, 1332, 1337, 1340,
		1344, 1349, 1352, 1357, 1366, 1370, 1384, 1393, 1401, 1406, 1412, 1417,
		1424, 1430, 1446, 1455, 1462, 1466, 1471, 1480, 1485, 1490, 1498, 1503,
		1515, 1522, 1534, 1541, 1555, 1565, 1574, 1578, 1582, 1593, 1596, 1607,
		1610, 1618, 1631, 1637, 1641, 1649, 1658, 1666, 1673, 1686, 1692, 1698,
		1701, 1705, 1712, 1715, 1718, 1721, 1733, 1741, 1747, 1753, 1757, 1764,
		1780, 1795, 1799, 1806, 1810, 1815, 1823, 1833, 1837, 1847, 1849, 1859,
		1864, 1869, 1874, 1877, 1887, 1899, 1905, 1910, 1918, 1924, 1931, 1938,
		1945, 1963, 1967, 1971, 1975, 1980, 1986, 2001, 2014, 2029, 2035, 2051,
		2055, 2057, 2075, 2081,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// huloParserInit initializes any static state used to implement huloParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewhuloParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func HuloParserInit() {
	staticData := &HuloParserParserStaticData
	staticData.once.Do(huloparserParserInit)
}

// NewhuloParser produces a new parser instance for the optional input antlr.TokenStream.
func NewhuloParser(input antlr.TokenStream) *huloParser {
	HuloParserInit()
	this := new(huloParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &HuloParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "huloParser.g4"

	return this
}

// huloParser tokens.
const (
	huloParserEOF                  = antlr.TokenEOF
	huloParserMOD_LIT              = 1
	huloParserUSE                  = 2
	huloParserIMPORT               = 3
	huloParserFROM                 = 4
	huloParserTYPE                 = 5
	huloParserTYPEOF               = 6
	huloParserAS                   = 7
	huloParserIF                   = 8
	huloParserELSE                 = 9
	huloParserMATCH                = 10
	huloParserDO                   = 11
	huloParserLOOP                 = 12
	huloParserIN                   = 13
	huloParserOF                   = 14
	huloParserRANGE                = 15
	huloParserCONTINUE             = 16
	huloParserBREAK                = 17
	huloParserLET                  = 18
	huloParserVAR                  = 19
	huloParserCONST                = 20
	huloParserSTATIC               = 21
	huloParserFINAL                = 22
	huloParserPUB                  = 23
	huloParserREQUIRED             = 24
	huloParserTRY                  = 25
	huloParserCATCH                = 26
	huloParserFINALLY              = 27
	huloParserTHROW                = 28
	huloParserTHROWS               = 29
	huloParserFN                   = 30
	huloParserOPERATOR             = 31
	huloParserRETURN               = 32
	huloParserENUM                 = 33
	huloParserCLASS                = 34
	huloParserTRAIT                = 35
	huloParserIMPL                 = 36
	huloParserFOR                  = 37
	huloParserTHIS                 = 38
	huloParserSUPER                = 39
	huloParserEXTEND               = 40
	huloParserDECLARE              = 41
	huloParserDEFER                = 42
	huloParserCOMPTIME             = 43
	huloParserWHEN                 = 44
	huloParserUNSAFE               = 45
	huloParserEXTERN               = 46
	huloParserDOT                  = 47
	huloParserDOUBLE_DOT           = 48
	huloParserCOMMA                = 49
	huloParserLPAREN               = 50
	huloParserRPAREN               = 51
	huloParserLBRACK               = 52
	huloParserRBRACK               = 53
	huloParserLBRACE               = 54
	huloParserRBRACE               = 55
	huloParserEXP                  = 56
	huloParserMUL                  = 57
	huloParserMOD                  = 58
	huloParserDIV                  = 59
	huloParserADD                  = 60
	huloParserSUB                  = 61
	huloParserHASH                 = 62
	huloParserAT                   = 63
	huloParserQUEST                = 64
	huloParserDOLLAR               = 65
	huloParserBACKSLASH            = 66
	huloParserWILDCARD             = 67
	huloParserASSIGN               = 68
	huloParserADD_ASSIGN           = 69
	huloParserSUB_ASSIGN           = 70
	huloParserMUL_ASSIGN           = 71
	huloParserEXP_ASSIGN           = 72
	huloParserDIV_ASSIGN           = 73
	huloParserMOD_ASSIGN           = 74
	huloParserAND_ASSIGN           = 75
	huloParserLT                   = 76
	huloParserGT                   = 77
	huloParserLE                   = 78
	huloParserGE                   = 79
	huloParserNEQ                  = 80
	huloParserEQ                   = 81
	huloParserSHL                  = 82
	huloParserSHR                  = 83
	huloParserARROW                = 84
	huloParserBACKARROW            = 85
	huloParserDOUBLE_ARROW         = 86
	huloParserELLIPSIS             = 87
	huloParserCOLON                = 88
	huloParserDOUBLE_COLON         = 89
	huloParserCOLON_ASSIGN         = 90
	huloParserSEMI                 = 91
	huloParserAND                  = 92
	huloParserOR                   = 93
	huloParserNOT                  = 94
	huloParserINC                  = 95
	huloParserDEC                  = 96
	huloParserTRIPLE_MINUS         = 97
	huloParserBITAND               = 98
	huloParserBITOR                = 99
	huloParserBITXOR               = 100
	huloParserSINGLE_QUOTE         = 101
	huloParserQUOTE                = 102
	huloParserTRIPLE_QUOTE         = 103
	huloParserNEW                  = 104
	huloParserDELETE               = 105
	huloParserNULL                 = 106
	huloParserNUM                  = 107
	huloParserSTR                  = 108
	huloParserBOOL                 = 109
	huloParserANY                  = 110
	huloParserVOID                 = 111
	huloParserUnsafeLiteral        = 112
	huloParserNumberLiteral        = 113
	huloParserStringLiteral        = 114
	huloParserBoolLiteral          = 115
	huloParserRawStringLiteral     = 116
	huloParserFileStringLiteral    = 117
	huloParserCommandStringLiteral = 118
	huloParserESC                  = 119
	huloParserLineComment          = 120
	huloParserBlockComment         = 121
	huloParserIdentifier           = 122
	huloParserWS                   = 123
)

// huloParser rules.
const (
	huloParserRULE_file                           = 0
	huloParserRULE_block                          = 1
	huloParserRULE_comment                        = 2
	huloParserRULE_statement                      = 3
	huloParserRULE_assignStatement                = 4
	huloParserRULE_lambdaAssignStatement          = 5
	huloParserRULE_variableNullableExpressions    = 6
	huloParserRULE_variableNullableExpression     = 7
	huloParserRULE_variableNames                  = 8
	huloParserRULE_variableNameList               = 9
	huloParserRULE_conditionalExpression          = 10
	huloParserRULE_conditionalBoolExpression      = 11
	huloParserRULE_logicalExpression              = 12
	huloParserRULE_shiftExpression                = 13
	huloParserRULE_addSubExpression               = 14
	huloParserRULE_mulDivExpression               = 15
	huloParserRULE_incDecExpression               = 16
	huloParserRULE_preIncDecExpression            = 17
	huloParserRULE_postIncDecExpression           = 18
	huloParserRULE_factor                         = 19
	huloParserRULE_tripleExpression               = 20
	huloParserRULE_listExpression                 = 21
	huloParserRULE_newDelExpression               = 22
	huloParserRULE_mapExpression                  = 23
	huloParserRULE_pair                           = 24
	huloParserRULE_variableExpression             = 25
	huloParserRULE_methodExpression               = 26
	huloParserRULE_expression                     = 27
	huloParserRULE_expressionList                 = 28
	huloParserRULE_memberAccess                   = 29
	huloParserRULE_fileExpression                 = 30
	huloParserRULE_callExpression                 = 31
	huloParserRULE_callExpressionLinkedList       = 32
	huloParserRULE_memberAccessPoint              = 33
	huloParserRULE_literal                        = 34
	huloParserRULE_receiverArgumentList           = 35
	huloParserRULE_namedArgumentList              = 36
	huloParserRULE_namedArgument                  = 37
	huloParserRULE_variableName                   = 38
	huloParserRULE_rangeExpression                = 39
	huloParserRULE_expressionStatement            = 40
	huloParserRULE_option                         = 41
	huloParserRULE_shortOption                    = 42
	huloParserRULE_longOption                     = 43
	huloParserRULE_commandExpression              = 44
	huloParserRULE_commandArgument                = 45
	huloParserRULE_builtinCommandArgument         = 46
	huloParserRULE_commandJoin                    = 47
	huloParserRULE_commandStream                  = 48
	huloParserRULE_commandAccessPoint             = 49
	huloParserRULE_receiverParameters             = 50
	huloParserRULE_receiverParameterList          = 51
	huloParserRULE_receiverParameter              = 52
	huloParserRULE_namedParameters                = 53
	huloParserRULE_namedParameterList             = 54
	huloParserRULE_namedParameter                 = 55
	huloParserRULE_returnStatement                = 56
	huloParserRULE_functionDeclaration            = 57
	huloParserRULE_operatorIdentifier             = 58
	huloParserRULE_standardFunctionDeclaration    = 59
	huloParserRULE_functionReturnValue            = 60
	huloParserRULE_lambdaFunctionDeclaration      = 61
	huloParserRULE_lambdaExpression               = 62
	huloParserRULE_lambdaBody                     = 63
	huloParserRULE_functionSignature              = 64
	huloParserRULE_functionModifier               = 65
	huloParserRULE_macroStatement                 = 66
	huloParserRULE_classDeclaration               = 67
	huloParserRULE_classModifier                  = 68
	huloParserRULE_classSuper                     = 69
	huloParserRULE_classBody                      = 70
	huloParserRULE_classMember                    = 71
	huloParserRULE_classMemberModifier            = 72
	huloParserRULE_classMethod                    = 73
	huloParserRULE_classMethodModifier            = 74
	huloParserRULE_classBuiltinMethod             = 75
	huloParserRULE_classBuiltinMethodModifier     = 76
	huloParserRULE_classBuiltinParameters         = 77
	huloParserRULE_classNamedParameters           = 78
	huloParserRULE_classNamedParameterList        = 79
	huloParserRULE_classNamedParameter            = 80
	huloParserRULE_classNamedParameterAccessPoint = 81
	huloParserRULE_classInitializeExpression      = 82
	huloParserRULE_enumDeclaration                = 83
	huloParserRULE_enumModifier                   = 84
	huloParserRULE_enumBodySimple                 = 85
	huloParserRULE_enumBodyAssociated             = 86
	huloParserRULE_enumBodyADT                    = 87
	huloParserRULE_enumValue                      = 88
	huloParserRULE_enumAssociatedFields           = 89
	huloParserRULE_enumAssociatedField            = 90
	huloParserRULE_enumFieldModifier              = 91
	huloParserRULE_enumField                      = 92
	huloParserRULE_enumAssociatedValues           = 93
	huloParserRULE_enumAssociatedValue            = 94
	huloParserRULE_enumAssociatedConstructor      = 95
	huloParserRULE_enumConstructor                = 96
	huloParserRULE_enumConstructorName            = 97
	huloParserRULE_enumConstructorParameters      = 98
	huloParserRULE_enumConstructorDirectInit      = 99
	huloParserRULE_enumConstructorInit            = 100
	huloParserRULE_enumAssociatedMethods          = 101
	huloParserRULE_enumVariant                    = 102
	huloParserRULE_enumMethods                    = 103
	huloParserRULE_enumMethod                     = 104
	huloParserRULE_enumMethodModifier             = 105
	huloParserRULE_enumMember                     = 106
	huloParserRULE_enumMemberModifier             = 107
	huloParserRULE_enumBuiltinMethodModifier      = 108
	huloParserRULE_enumInitialize                 = 109
	huloParserRULE_enumInitializeMember           = 110
	huloParserRULE_traitDeclaration               = 111
	huloParserRULE_traitModifier                  = 112
	huloParserRULE_traitBody                      = 113
	huloParserRULE_traitMember                    = 114
	huloParserRULE_traitMemberModifier            = 115
	huloParserRULE_implDeclaration                = 116
	huloParserRULE_implDeclarationBinding         = 117
	huloParserRULE_implDeclarationBody            = 118
	huloParserRULE_extendDeclaration              = 119
	huloParserRULE_extendEnum                     = 120
	huloParserRULE_extendClass                    = 121
	huloParserRULE_extendTrait                    = 122
	huloParserRULE_extendType                     = 123
	huloParserRULE_extendMod                      = 124
	huloParserRULE_importDeclaration              = 125
	huloParserRULE_importSingle                   = 126
	huloParserRULE_importAll                      = 127
	huloParserRULE_importMulti                    = 128
	huloParserRULE_asIdentifier                   = 129
	huloParserRULE_identifierAsIdentifier         = 130
	huloParserRULE_moduleDeclaration              = 131
	huloParserRULE_moduleStatement                = 132
	huloParserRULE_useDeclaration                 = 133
	huloParserRULE_useSingle                      = 134
	huloParserRULE_useMulti                       = 135
	huloParserRULE_useAll                         = 136
	huloParserRULE_typeDeclaration                = 137
	huloParserRULE_genericArguments               = 138
	huloParserRULE_genericParameters              = 139
	huloParserRULE_genericParameterList           = 140
	huloParserRULE_genericParameter               = 141
	huloParserRULE_compositeType                  = 142
	huloParserRULE_type                           = 143
	huloParserRULE_typeLiteral                    = 144
	huloParserRULE_nullableType                   = 145
	huloParserRULE_unionType                      = 146
	huloParserRULE_intersectionType               = 147
	huloParserRULE_arrayType                      = 148
	huloParserRULE_typeAccessPoint                = 149
	huloParserRULE_typeList                       = 150
	huloParserRULE_typeofExpression               = 151
	huloParserRULE_asExpression                   = 152
	huloParserRULE_objectType                     = 153
	huloParserRULE_objectTypeMember               = 154
	huloParserRULE_tupleType                      = 155
	huloParserRULE_functionType                   = 156
	huloParserRULE_tryStatement                   = 157
	huloParserRULE_catchClause                    = 158
	huloParserRULE_catchClauseReceiver            = 159
	huloParserRULE_finallyClause                  = 160
	huloParserRULE_throwStatement                 = 161
	huloParserRULE_breakStatement                 = 162
	huloParserRULE_continueStatement              = 163
	huloParserRULE_ifStatement                    = 164
	huloParserRULE_matchStatement                 = 165
	huloParserRULE_matchCaseClause                = 166
	huloParserRULE_matchEnum                      = 167
	huloParserRULE_matchEnumMember                = 168
	huloParserRULE_matchTriple                    = 169
	huloParserRULE_matchTripleValue               = 170
	huloParserRULE_matchCaseBody                  = 171
	huloParserRULE_matchDefaultClause             = 172
	huloParserRULE_loopStatement                  = 173
	huloParserRULE_loopLabel                      = 174
	huloParserRULE_foreachStatement               = 175
	huloParserRULE_foreachClause                  = 176
	huloParserRULE_foreachVariableName            = 177
	huloParserRULE_forStatement                   = 178
	huloParserRULE_forClause                      = 179
	huloParserRULE_rangeStatement                 = 180
	huloParserRULE_rangeClause                    = 181
	huloParserRULE_doWhileStatement               = 182
	huloParserRULE_whileStatement                 = 183
	huloParserRULE_deferStatement                 = 184
	huloParserRULE_declareStatement               = 185
	huloParserRULE_channelInputStatement          = 186
	huloParserRULE_channelOutputExpression        = 187
	huloParserRULE_unsafeExpression               = 188
	huloParserRULE_comptimeExpression             = 189
	huloParserRULE_comptimeCaseClause             = 190
	huloParserRULE_comptimeDefaultClause          = 191
	huloParserRULE_externDeclaration              = 192
	huloParserRULE_externList                     = 193
	huloParserRULE_externItem                     = 194
)

// IFileContext is an interface to support dynamic dispatch.
type IFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsFileContext differentiates from other interfaces.
	IsFileContext()
}

type FileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileContext() *FileContext {
	var p = new(FileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_file
	return p
}

func InitEmptyFileContext(p *FileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_file
}

func (*FileContext) IsFileContext() {}

func NewFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileContext {
	var p = new(FileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_file

	return p
}

func (s *FileContext) GetParser() antlr.Parser { return s.parser }

func (s *FileContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *FileContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *FileContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(huloParserSEMI)
}

func (s *FileContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, i)
}

func (s *FileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) File() (localctx IFileContext) {
	localctx = NewFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, huloParserRULE_file)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6893797309010731670) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&267858078178738181) != 0) {
		{
			p.SetState(390)
			p.Statement()
		}
		p.SetState(394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserSEMI {
			{
				p.SetState(391)
				p.Match(huloParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(396)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(huloParserSEMI)
}

func (s *BlockContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, huloParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6893797309010731670) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&267858078178738181) != 0) {
		{
			p.SetState(403)
			p.Statement()
		}
		p.SetState(407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserSEMI {
			{
				p.SetState(404)
				p.Match(huloParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(409)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(415)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LineComment() antlr.TerminalNode
	BlockComment() antlr.TerminalNode

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) LineComment() antlr.TerminalNode {
	return s.GetToken(huloParserLineComment, 0)
}

func (s *CommentContext) BlockComment() antlr.TerminalNode {
	return s.GetToken(huloParserBlockComment, 0)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, huloParserRULE_comment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserLineComment || _la == huloParserBlockComment) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Comment() ICommentContext
	ImportDeclaration() IImportDeclarationContext
	ModuleDeclaration() IModuleDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	TraitDeclaration() ITraitDeclarationContext
	ImplDeclaration() IImplDeclarationContext
	TypeDeclaration() ITypeDeclarationContext
	ExtendDeclaration() IExtendDeclarationContext
	ExternDeclaration() IExternDeclarationContext
	MacroStatement() IMacroStatementContext
	AssignStatement() IAssignStatementContext
	LambdaAssignStatement() ILambdaAssignStatementContext
	TryStatement() ITryStatementContext
	ThrowStatement() IThrowStatementContext
	ReturnStatement() IReturnStatementContext
	BreakStatement() IBreakStatementContext
	ContinueStatement() IContinueStatementContext
	IfStatement() IIfStatementContext
	MatchStatement() IMatchStatementContext
	LoopStatement() ILoopStatementContext
	DeferStatement() IDeferStatementContext
	DeclareStatement() IDeclareStatementContext
	ChannelInputStatement() IChannelInputStatementContext
	ExpressionStatement() IExpressionStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *StatementContext) ImportDeclaration() IImportDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *StatementContext) ModuleDeclaration() IModuleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *StatementContext) TraitDeclaration() ITraitDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitDeclarationContext)
}

func (s *StatementContext) ImplDeclaration() IImplDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplDeclarationContext)
}

func (s *StatementContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *StatementContext) ExtendDeclaration() IExtendDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendDeclarationContext)
}

func (s *StatementContext) ExternDeclaration() IExternDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternDeclarationContext)
}

func (s *StatementContext) MacroStatement() IMacroStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *StatementContext) AssignStatement() IAssignStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignStatementContext)
}

func (s *StatementContext) LambdaAssignStatement() ILambdaAssignStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaAssignStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaAssignStatementContext)
}

func (s *StatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *StatementContext) LoopStatement() ILoopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *StatementContext) DeferStatement() IDeferStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStatementContext)
}

func (s *StatementContext) DeclareStatement() IDeclareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareStatementContext)
}

func (s *StatementContext) ChannelInputStatement() IChannelInputStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelInputStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelInputStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, huloParserRULE_statement)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)
			p.Comment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(420)
			p.ImportDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(421)
			p.ModuleDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(422)
			p.FunctionDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(423)
			p.ClassDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(424)
			p.EnumDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(425)
			p.TraitDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(426)
			p.ImplDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(427)
			p.TypeDeclaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(428)
			p.ExtendDeclaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(429)
			p.ExternDeclaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(430)
			p.MacroStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(431)
			p.AssignStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(432)
			p.LambdaAssignStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(433)
			p.TryStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(434)
			p.ThrowStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(435)
			p.ReturnStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(436)
			p.BreakStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(437)
			p.ContinueStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(438)
			p.IfStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(439)
			p.MatchStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(440)
			p.LoopStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(441)
			p.ReturnStatement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(442)
			p.DeferStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(443)
			p.DeclareStatement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(444)
			p.ChannelInputStatement()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(445)
			p.ExpressionStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignStatementContext is an interface to support dynamic dispatch.
type IAssignStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAssignModifier returns the assignModifier token.
	GetAssignModifier() antlr.Token

	// SetAssignModifier sets the assignModifier token.
	SetAssignModifier(antlr.Token)

	// Getter signatures
	LET() antlr.TerminalNode
	CONST() antlr.TerminalNode
	VAR() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	VariableNames() IVariableNamesContext
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	MatchStatement() IMatchStatementContext
	ADD_ASSIGN() antlr.TerminalNode
	SUB_ASSIGN() antlr.TerminalNode
	MUL_ASSIGN() antlr.TerminalNode
	DIV_ASSIGN() antlr.TerminalNode
	MOD_ASSIGN() antlr.TerminalNode
	AND_ASSIGN() antlr.TerminalNode
	EXP_ASSIGN() antlr.TerminalNode
	VariableExpression() IVariableExpressionContext
	VariableNullableExpressions() IVariableNullableExpressionsContext

	// IsAssignStatementContext differentiates from other interfaces.
	IsAssignStatementContext()
}

type AssignStatementContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	assignModifier antlr.Token
}

func NewEmptyAssignStatementContext() *AssignStatementContext {
	var p = new(AssignStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_assignStatement
	return p
}

func InitEmptyAssignStatementContext(p *AssignStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_assignStatement
}

func (*AssignStatementContext) IsAssignStatementContext() {}

func NewAssignStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignStatementContext {
	var p = new(AssignStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_assignStatement

	return p
}

func (s *AssignStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignStatementContext) GetAssignModifier() antlr.Token { return s.assignModifier }

func (s *AssignStatementContext) SetAssignModifier(v antlr.Token) { s.assignModifier = v }

func (s *AssignStatementContext) LET() antlr.TerminalNode {
	return s.GetToken(huloParserLET, 0)
}

func (s *AssignStatementContext) CONST() antlr.TerminalNode {
	return s.GetToken(huloParserCONST, 0)
}

func (s *AssignStatementContext) VAR() antlr.TerminalNode {
	return s.GetToken(huloParserVAR, 0)
}

func (s *AssignStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *AssignStatementContext) VariableNames() IVariableNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNamesContext)
}

func (s *AssignStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *AssignStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AssignStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *AssignStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignStatementContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *AssignStatementContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserADD_ASSIGN, 0)
}

func (s *AssignStatementContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserSUB_ASSIGN, 0)
}

func (s *AssignStatementContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserMUL_ASSIGN, 0)
}

func (s *AssignStatementContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserDIV_ASSIGN, 0)
}

func (s *AssignStatementContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserMOD_ASSIGN, 0)
}

func (s *AssignStatementContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserAND_ASSIGN, 0)
}

func (s *AssignStatementContext) EXP_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserEXP_ASSIGN, 0)
}

func (s *AssignStatementContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *AssignStatementContext) VariableNullableExpressions() IVariableNullableExpressionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNullableExpressionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNullableExpressionsContext)
}

func (s *AssignStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitAssignStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) AssignStatement() (localctx IAssignStatementContext) {
	localctx = NewAssignStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, huloParserRULE_assignStatement)
	var _la int

	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserLET, huloParserVAR, huloParserCONST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(448)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AssignStatementContext).assignModifier = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1835008) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AssignStatementContext).assignModifier = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case huloParserIdentifier:
			{
				p.SetState(449)
				p.Match(huloParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case huloParserLBRACE:
			{
				p.SetState(450)
				p.VariableNames()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOLON {
			{
				p.SetState(453)
				p.Match(huloParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(454)
				p.Type_()
			}

		}
		p.SetState(462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserASSIGN {
			{
				p.SetState(457)
				p.Match(huloParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case huloParserTYPEOF, huloParserTHIS, huloParserSUPER, huloParserCOMPTIME, huloParserLPAREN, huloParserLBRACK, huloParserLBRACE, huloParserSUB, huloParserDOLLAR, huloParserBACKARROW, huloParserINC, huloParserDEC, huloParserNEW, huloParserDELETE, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserUnsafeLiteral, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserFileStringLiteral, huloParserCommandStringLiteral, huloParserIdentifier:
				{
					p.SetState(458)
					p.Expression()
				}

			case huloParserMATCH:
				{
					p.SetState(459)
					p.MatchStatement()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case huloParserDOLLAR, huloParserWILDCARD:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(464)
				p.VariableExpression()
			}

		case 2:
			{
				p.SetState(465)
				p.VariableNullableExpressions()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(468)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&255) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case huloParserTYPEOF, huloParserTHIS, huloParserSUPER, huloParserCOMPTIME, huloParserLPAREN, huloParserLBRACK, huloParserLBRACE, huloParserSUB, huloParserDOLLAR, huloParserBACKARROW, huloParserINC, huloParserDEC, huloParserNEW, huloParserDELETE, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserUnsafeLiteral, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserFileStringLiteral, huloParserCommandStringLiteral, huloParserIdentifier:
			{
				p.SetState(469)
				p.Expression()
			}

		case huloParserMATCH:
			{
				p.SetState(470)
				p.MatchStatement()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaAssignStatementContext is an interface to support dynamic dispatch.
type ILambdaAssignStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableExpression() IVariableExpressionContext
	COLON_ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	MatchStatement() IMatchStatementContext

	// IsLambdaAssignStatementContext differentiates from other interfaces.
	IsLambdaAssignStatementContext()
}

type LambdaAssignStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaAssignStatementContext() *LambdaAssignStatementContext {
	var p = new(LambdaAssignStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaAssignStatement
	return p
}

func InitEmptyLambdaAssignStatementContext(p *LambdaAssignStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaAssignStatement
}

func (*LambdaAssignStatementContext) IsLambdaAssignStatementContext() {}

func NewLambdaAssignStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaAssignStatementContext {
	var p = new(LambdaAssignStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_lambdaAssignStatement

	return p
}

func (s *LambdaAssignStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaAssignStatementContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *LambdaAssignStatementContext) COLON_ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON_ASSIGN, 0)
}

func (s *LambdaAssignStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaAssignStatementContext) MatchStatement() IMatchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchStatementContext)
}

func (s *LambdaAssignStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaAssignStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaAssignStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLambdaAssignStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LambdaAssignStatement() (localctx ILambdaAssignStatementContext) {
	localctx = NewLambdaAssignStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, huloParserRULE_lambdaAssignStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(475)
		p.VariableExpression()
	}
	{
		p.SetState(476)
		p.Match(huloParserCOLON_ASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserTYPEOF, huloParserTHIS, huloParserSUPER, huloParserCOMPTIME, huloParserLPAREN, huloParserLBRACK, huloParserLBRACE, huloParserSUB, huloParserDOLLAR, huloParserBACKARROW, huloParserINC, huloParserDEC, huloParserNEW, huloParserDELETE, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserUnsafeLiteral, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserFileStringLiteral, huloParserCommandStringLiteral, huloParserIdentifier:
		{
			p.SetState(477)
			p.Expression()
		}

	case huloParserMATCH:
		{
			p.SetState(478)
			p.MatchStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNullableExpressionsContext is an interface to support dynamic dispatch.
type IVariableNullableExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableNullableExpression() []IVariableNullableExpressionContext
	VariableNullableExpression(i int) IVariableNullableExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableNullableExpressionsContext differentiates from other interfaces.
	IsVariableNullableExpressionsContext()
}

type VariableNullableExpressionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNullableExpressionsContext() *VariableNullableExpressionsContext {
	var p = new(VariableNullableExpressionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNullableExpressions
	return p
}

func InitEmptyVariableNullableExpressionsContext(p *VariableNullableExpressionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNullableExpressions
}

func (*VariableNullableExpressionsContext) IsVariableNullableExpressionsContext() {}

func NewVariableNullableExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNullableExpressionsContext {
	var p = new(VariableNullableExpressionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_variableNullableExpressions

	return p
}

func (s *VariableNullableExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNullableExpressionsContext) AllVariableNullableExpression() []IVariableNullableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableNullableExpressionContext); ok {
			len++
		}
	}

	tst := make([]IVariableNullableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableNullableExpressionContext); ok {
			tst[i] = t.(IVariableNullableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableNullableExpressionsContext) VariableNullableExpression(i int) IVariableNullableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNullableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNullableExpressionContext)
}

func (s *VariableNullableExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *VariableNullableExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *VariableNullableExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNullableExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNullableExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitVariableNullableExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) VariableNullableExpressions() (localctx IVariableNullableExpressionsContext) {
	localctx = NewVariableNullableExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, huloParserRULE_variableNullableExpressions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.VariableNullableExpression()
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(482)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(483)
			p.VariableNullableExpression()
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNullableExpressionContext is an interface to support dynamic dispatch.
type IVariableNullableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableExpression() IVariableExpressionContext
	WILDCARD() antlr.TerminalNode

	// IsVariableNullableExpressionContext differentiates from other interfaces.
	IsVariableNullableExpressionContext()
}

type VariableNullableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNullableExpressionContext() *VariableNullableExpressionContext {
	var p = new(VariableNullableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNullableExpression
	return p
}

func InitEmptyVariableNullableExpressionContext(p *VariableNullableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNullableExpression
}

func (*VariableNullableExpressionContext) IsVariableNullableExpressionContext() {}

func NewVariableNullableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNullableExpressionContext {
	var p = new(VariableNullableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_variableNullableExpression

	return p
}

func (s *VariableNullableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNullableExpressionContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *VariableNullableExpressionContext) WILDCARD() antlr.TerminalNode {
	return s.GetToken(huloParserWILDCARD, 0)
}

func (s *VariableNullableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNullableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNullableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitVariableNullableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) VariableNullableExpression() (localctx IVariableNullableExpressionContext) {
	localctx = NewVariableNullableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, huloParserRULE_variableNullableExpression)
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserDOLLAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(489)
			p.VariableExpression()
		}

	case huloParserWILDCARD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(490)
			p.Match(huloParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNamesContext is an interface to support dynamic dispatch.
type IVariableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	VariableNameList() IVariableNameListContext
	RBRACE() antlr.TerminalNode

	// IsVariableNamesContext differentiates from other interfaces.
	IsVariableNamesContext()
}

type VariableNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNamesContext() *VariableNamesContext {
	var p = new(VariableNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNames
	return p
}

func InitEmptyVariableNamesContext(p *VariableNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNames
}

func (*VariableNamesContext) IsVariableNamesContext() {}

func NewVariableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNamesContext {
	var p = new(VariableNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_variableNames

	return p
}

func (s *VariableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNamesContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *VariableNamesContext) VariableNameList() IVariableNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameListContext)
}

func (s *VariableNamesContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *VariableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitVariableNames(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) VariableNames() (localctx IVariableNamesContext) {
	localctx = NewVariableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, huloParserRULE_variableNames)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(494)
		p.VariableNameList()
	}
	{
		p.SetState(495)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNameListContext is an interface to support dynamic dispatch.
type IVariableNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableName() []IVariableNameContext
	VariableName(i int) IVariableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsVariableNameListContext differentiates from other interfaces.
	IsVariableNameListContext()
}

type VariableNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameListContext() *VariableNameListContext {
	var p = new(VariableNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNameList
	return p
}

func InitEmptyVariableNameListContext(p *VariableNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableNameList
}

func (*VariableNameListContext) IsVariableNameListContext() {}

func NewVariableNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameListContext {
	var p = new(VariableNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_variableNameList

	return p
}

func (s *VariableNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameListContext) AllVariableName() []IVariableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableNameContext); ok {
			len++
		}
	}

	tst := make([]IVariableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableNameContext); ok {
			tst[i] = t.(IVariableNameContext)
			i++
		}
	}

	return tst
}

func (s *VariableNameListContext) VariableName(i int) IVariableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *VariableNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *VariableNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitVariableNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) VariableNameList() (localctx IVariableNameListContext) {
	localctx = NewVariableNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, huloParserRULE_variableNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.VariableName()
	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(498)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(499)
			p.VariableName()
		}

		p.SetState(504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalBoolExpression() IConditionalBoolExpressionContext
	QUEST() antlr.TerminalNode
	AllConditionalExpression() []IConditionalExpressionContext
	ConditionalExpression(i int) IConditionalExpressionContext
	COLON() antlr.TerminalNode

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_conditionalExpression
	return p
}

func InitEmptyConditionalExpressionContext(p *ConditionalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_conditionalExpression
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) ConditionalBoolExpression() IConditionalBoolExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalBoolExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalBoolExpressionContext)
}

func (s *ConditionalExpressionContext) QUEST() antlr.TerminalNode {
	return s.GetToken(huloParserQUEST, 0)
}

func (s *ConditionalExpressionContext) AllConditionalExpression() []IConditionalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			len++
		}
	}

	tst := make([]IConditionalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionalExpressionContext); ok {
			tst[i] = t.(IConditionalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalExpressionContext) ConditionalExpression(i int) IConditionalExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ConditionalExpressionContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitConditionalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, huloParserRULE_conditionalExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(505)
		p.ConditionalBoolExpression()
	}
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserQUEST {
		{
			p.SetState(506)
			p.Match(huloParserQUEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(507)
			p.ConditionalExpression()
		}
		{
			p.SetState(508)
			p.Match(huloParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(509)
			p.ConditionalExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalBoolExpressionContext is an interface to support dynamic dispatch.
type IConditionalBoolExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConditionalOp returns the conditionalOp token.
	GetConditionalOp() antlr.Token

	// SetConditionalOp sets the conditionalOp token.
	SetConditionalOp(antlr.Token)

	// Getter signatures
	AllLogicalExpression() []ILogicalExpressionContext
	LogicalExpression(i int) ILogicalExpressionContext
	AllBITAND() []antlr.TerminalNode
	BITAND(i int) antlr.TerminalNode
	AllBITOR() []antlr.TerminalNode
	BITOR(i int) antlr.TerminalNode
	AllBITXOR() []antlr.TerminalNode
	BITXOR(i int) antlr.TerminalNode
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsConditionalBoolExpressionContext differentiates from other interfaces.
	IsConditionalBoolExpressionContext()
}

type ConditionalBoolExpressionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	conditionalOp antlr.Token
}

func NewEmptyConditionalBoolExpressionContext() *ConditionalBoolExpressionContext {
	var p = new(ConditionalBoolExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_conditionalBoolExpression
	return p
}

func InitEmptyConditionalBoolExpressionContext(p *ConditionalBoolExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_conditionalBoolExpression
}

func (*ConditionalBoolExpressionContext) IsConditionalBoolExpressionContext() {}

func NewConditionalBoolExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalBoolExpressionContext {
	var p = new(ConditionalBoolExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_conditionalBoolExpression

	return p
}

func (s *ConditionalBoolExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalBoolExpressionContext) GetConditionalOp() antlr.Token { return s.conditionalOp }

func (s *ConditionalBoolExpressionContext) SetConditionalOp(v antlr.Token) { s.conditionalOp = v }

func (s *ConditionalBoolExpressionContext) AllLogicalExpression() []ILogicalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILogicalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalExpressionContext); ok {
			tst[i] = t.(ILogicalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionalBoolExpressionContext) LogicalExpression(i int) ILogicalExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *ConditionalBoolExpressionContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(huloParserBITAND)
}

func (s *ConditionalBoolExpressionContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(huloParserBITAND, i)
}

func (s *ConditionalBoolExpressionContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(huloParserBITOR)
}

func (s *ConditionalBoolExpressionContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(huloParserBITOR, i)
}

func (s *ConditionalBoolExpressionContext) AllBITXOR() []antlr.TerminalNode {
	return s.GetTokens(huloParserBITXOR)
}

func (s *ConditionalBoolExpressionContext) BITXOR(i int) antlr.TerminalNode {
	return s.GetToken(huloParserBITXOR, i)
}

func (s *ConditionalBoolExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(huloParserAND)
}

func (s *ConditionalBoolExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(huloParserAND, i)
}

func (s *ConditionalBoolExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(huloParserOR)
}

func (s *ConditionalBoolExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(huloParserOR, i)
}

func (s *ConditionalBoolExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalBoolExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalBoolExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitConditionalBoolExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ConditionalBoolExpression() (localctx IConditionalBoolExpressionContext) {
	localctx = NewConditionalBoolExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, huloParserRULE_conditionalBoolExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.LogicalExpression()
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(514)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ConditionalBoolExpressionContext).conditionalOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-92)) & ^0x3f) == 0 && ((int64(1)<<(_la-92))&451) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ConditionalBoolExpressionContext).conditionalOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(515)
				p.LogicalExpression()
			}

		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalExpressionContext is an interface to support dynamic dispatch.
type ILogicalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLogicalOp returns the logicalOp token.
	GetLogicalOp() antlr.Token

	// SetLogicalOp sets the logicalOp token.
	SetLogicalOp(antlr.Token)

	// Getter signatures
	AllShiftExpression() []IShiftExpressionContext
	ShiftExpression(i int) IShiftExpressionContext
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode
	AllLT() []antlr.TerminalNode
	LT(i int) antlr.TerminalNode
	AllGE() []antlr.TerminalNode
	GE(i int) antlr.TerminalNode
	AllLE() []antlr.TerminalNode
	LE(i int) antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	AllNEQ() []antlr.TerminalNode
	NEQ(i int) antlr.TerminalNode
	AllMOD() []antlr.TerminalNode
	MOD(i int) antlr.TerminalNode
	TypeofExpression() ITypeofExpressionContext
	StringLiteral() antlr.TerminalNode

	// IsLogicalExpressionContext differentiates from other interfaces.
	IsLogicalExpressionContext()
}

type LogicalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	logicalOp antlr.Token
}

func NewEmptyLogicalExpressionContext() *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_logicalExpression
	return p
}

func InitEmptyLogicalExpressionContext(p *LogicalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_logicalExpression
}

func (*LogicalExpressionContext) IsLogicalExpressionContext() {}

func NewLogicalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_logicalExpression

	return p
}

func (s *LogicalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalExpressionContext) GetLogicalOp() antlr.Token { return s.logicalOp }

func (s *LogicalExpressionContext) SetLogicalOp(v antlr.Token) { s.logicalOp = v }

func (s *LogicalExpressionContext) AllShiftExpression() []IShiftExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShiftExpressionContext); ok {
			len++
		}
	}

	tst := make([]IShiftExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShiftExpressionContext); ok {
			tst[i] = t.(IShiftExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) ShiftExpression(i int) IShiftExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *LogicalExpressionContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(huloParserGT)
}

func (s *LogicalExpressionContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(huloParserGT, i)
}

func (s *LogicalExpressionContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(huloParserLT)
}

func (s *LogicalExpressionContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(huloParserLT, i)
}

func (s *LogicalExpressionContext) AllGE() []antlr.TerminalNode {
	return s.GetTokens(huloParserGE)
}

func (s *LogicalExpressionContext) GE(i int) antlr.TerminalNode {
	return s.GetToken(huloParserGE, i)
}

func (s *LogicalExpressionContext) AllLE() []antlr.TerminalNode {
	return s.GetTokens(huloParserLE)
}

func (s *LogicalExpressionContext) LE(i int) antlr.TerminalNode {
	return s.GetToken(huloParserLE, i)
}

func (s *LogicalExpressionContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(huloParserEQ)
}

func (s *LogicalExpressionContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(huloParserEQ, i)
}

func (s *LogicalExpressionContext) AllNEQ() []antlr.TerminalNode {
	return s.GetTokens(huloParserNEQ)
}

func (s *LogicalExpressionContext) NEQ(i int) antlr.TerminalNode {
	return s.GetToken(huloParserNEQ, i)
}

func (s *LogicalExpressionContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(huloParserMOD)
}

func (s *LogicalExpressionContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(huloParserMOD, i)
}

func (s *LogicalExpressionContext) TypeofExpression() ITypeofExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeofExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeofExpressionContext)
}

func (s *LogicalExpressionContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LogicalExpression() (localctx ILogicalExpressionContext) {
	localctx = NewLogicalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, huloParserRULE_logicalExpression)
	var _la int

	var _alt int

	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserTHIS, huloParserSUPER, huloParserLPAREN, huloParserLBRACK, huloParserLBRACE, huloParserSUB, huloParserDOLLAR, huloParserINC, huloParserDEC, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserFileStringLiteral, huloParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(521)
			p.ShiftExpression()
		}
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(522)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalExpressionContext).logicalOp = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-58)) & ^0x3f) == 0 && ((int64(1)<<(_la-58))&16515073) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalExpressionContext).logicalOp = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(523)
					p.ShiftExpression()
				}

			}
			p.SetState(528)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case huloParserTYPEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(529)
			p.TypeofExpression()
		}
		{
			p.SetState(530)
			_la = p.GetTokenStream().LA(1)

			if !(_la == huloParserNEQ || _la == huloParserEQ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(531)
			p.Match(huloParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExpressionContext is an interface to support dynamic dispatch.
type IShiftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetShiftOp returns the shiftOp token.
	GetShiftOp() antlr.Token

	// SetShiftOp sets the shiftOp token.
	SetShiftOp(antlr.Token)

	// Getter signatures
	AllAddSubExpression() []IAddSubExpressionContext
	AddSubExpression(i int) IAddSubExpressionContext
	AllSHL() []antlr.TerminalNode
	SHL(i int) antlr.TerminalNode
	AllSHR() []antlr.TerminalNode
	SHR(i int) antlr.TerminalNode

	// IsShiftExpressionContext differentiates from other interfaces.
	IsShiftExpressionContext()
}

type ShiftExpressionContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	shiftOp antlr.Token
}

func NewEmptyShiftExpressionContext() *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_shiftExpression
	return p
}

func InitEmptyShiftExpressionContext(p *ShiftExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_shiftExpression
}

func (*ShiftExpressionContext) IsShiftExpressionContext() {}

func NewShiftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_shiftExpression

	return p
}

func (s *ShiftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExpressionContext) GetShiftOp() antlr.Token { return s.shiftOp }

func (s *ShiftExpressionContext) SetShiftOp(v antlr.Token) { s.shiftOp = v }

func (s *ShiftExpressionContext) AllAddSubExpression() []IAddSubExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddSubExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAddSubExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddSubExpressionContext); ok {
			tst[i] = t.(IAddSubExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExpressionContext) AddSubExpression(i int) IAddSubExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddSubExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddSubExpressionContext)
}

func (s *ShiftExpressionContext) AllSHL() []antlr.TerminalNode {
	return s.GetTokens(huloParserSHL)
}

func (s *ShiftExpressionContext) SHL(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSHL, i)
}

func (s *ShiftExpressionContext) AllSHR() []antlr.TerminalNode {
	return s.GetTokens(huloParserSHR)
}

func (s *ShiftExpressionContext) SHR(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSHR, i)
}

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ShiftExpression() (localctx IShiftExpressionContext) {
	localctx = NewShiftExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, huloParserRULE_shiftExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.AddSubExpression()
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(536)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShiftExpressionContext).shiftOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == huloParserSHL || _la == huloParserSHR) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShiftExpressionContext).shiftOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(537)
				p.AddSubExpression()
			}

		}
		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddSubExpressionContext is an interface to support dynamic dispatch.
type IAddSubExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAddSubOp returns the addSubOp token.
	GetAddSubOp() antlr.Token

	// SetAddSubOp sets the addSubOp token.
	SetAddSubOp(antlr.Token)

	// Getter signatures
	AllMulDivExpression() []IMulDivExpressionContext
	MulDivExpression(i int) IMulDivExpressionContext
	AllADD() []antlr.TerminalNode
	ADD(i int) antlr.TerminalNode
	AllSUB() []antlr.TerminalNode
	SUB(i int) antlr.TerminalNode

	// IsAddSubExpressionContext differentiates from other interfaces.
	IsAddSubExpressionContext()
}

type AddSubExpressionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	addSubOp antlr.Token
}

func NewEmptyAddSubExpressionContext() *AddSubExpressionContext {
	var p = new(AddSubExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_addSubExpression
	return p
}

func InitEmptyAddSubExpressionContext(p *AddSubExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_addSubExpression
}

func (*AddSubExpressionContext) IsAddSubExpressionContext() {}

func NewAddSubExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSubExpressionContext {
	var p = new(AddSubExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_addSubExpression

	return p
}

func (s *AddSubExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSubExpressionContext) GetAddSubOp() antlr.Token { return s.addSubOp }

func (s *AddSubExpressionContext) SetAddSubOp(v antlr.Token) { s.addSubOp = v }

func (s *AddSubExpressionContext) AllMulDivExpression() []IMulDivExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMulDivExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMulDivExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMulDivExpressionContext); ok {
			tst[i] = t.(IMulDivExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AddSubExpressionContext) MulDivExpression(i int) IMulDivExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMulDivExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMulDivExpressionContext)
}

func (s *AddSubExpressionContext) AllADD() []antlr.TerminalNode {
	return s.GetTokens(huloParserADD)
}

func (s *AddSubExpressionContext) ADD(i int) antlr.TerminalNode {
	return s.GetToken(huloParserADD, i)
}

func (s *AddSubExpressionContext) AllSUB() []antlr.TerminalNode {
	return s.GetTokens(huloParserSUB)
}

func (s *AddSubExpressionContext) SUB(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSUB, i)
}

func (s *AddSubExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSubExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSubExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitAddSubExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) AddSubExpression() (localctx IAddSubExpressionContext) {
	localctx = NewAddSubExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, huloParserRULE_addSubExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.MulDivExpression()
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(544)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AddSubExpressionContext).addSubOp = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == huloParserADD || _la == huloParserSUB) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AddSubExpressionContext).addSubOp = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(545)
				p.MulDivExpression()
			}

		}
		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMulDivExpressionContext is an interface to support dynamic dispatch.
type IMulDivExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMulDivOp returns the mulDivOp token.
	GetMulDivOp() antlr.Token

	// SetMulDivOp sets the mulDivOp token.
	SetMulDivOp(antlr.Token)

	// Getter signatures
	AllIncDecExpression() []IIncDecExpressionContext
	IncDecExpression(i int) IIncDecExpressionContext
	AllMUL() []antlr.TerminalNode
	MUL(i int) antlr.TerminalNode
	AllDIV() []antlr.TerminalNode
	DIV(i int) antlr.TerminalNode

	// IsMulDivExpressionContext differentiates from other interfaces.
	IsMulDivExpressionContext()
}

type MulDivExpressionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	mulDivOp antlr.Token
}

func NewEmptyMulDivExpressionContext() *MulDivExpressionContext {
	var p = new(MulDivExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_mulDivExpression
	return p
}

func InitEmptyMulDivExpressionContext(p *MulDivExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_mulDivExpression
}

func (*MulDivExpressionContext) IsMulDivExpressionContext() {}

func NewMulDivExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MulDivExpressionContext {
	var p = new(MulDivExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_mulDivExpression

	return p
}

func (s *MulDivExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MulDivExpressionContext) GetMulDivOp() antlr.Token { return s.mulDivOp }

func (s *MulDivExpressionContext) SetMulDivOp(v antlr.Token) { s.mulDivOp = v }

func (s *MulDivExpressionContext) AllIncDecExpression() []IIncDecExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIncDecExpressionContext); ok {
			len++
		}
	}

	tst := make([]IIncDecExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIncDecExpressionContext); ok {
			tst[i] = t.(IIncDecExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MulDivExpressionContext) IncDecExpression(i int) IIncDecExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncDecExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncDecExpressionContext)
}

func (s *MulDivExpressionContext) AllMUL() []antlr.TerminalNode {
	return s.GetTokens(huloParserMUL)
}

func (s *MulDivExpressionContext) MUL(i int) antlr.TerminalNode {
	return s.GetToken(huloParserMUL, i)
}

func (s *MulDivExpressionContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(huloParserDIV)
}

func (s *MulDivExpressionContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(huloParserDIV, i)
}

func (s *MulDivExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MulDivExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MulDivExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMulDivExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MulDivExpression() (localctx IMulDivExpressionContext) {
	localctx = NewMulDivExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, huloParserRULE_mulDivExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.IncDecExpression()
	}
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserMUL || _la == huloParserDIV {
		{
			p.SetState(552)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MulDivExpressionContext).mulDivOp = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == huloParserMUL || _la == huloParserDIV) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MulDivExpressionContext).mulDivOp = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(553)
			p.IncDecExpression()
		}

		p.SetState(558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIncDecExpressionContext is an interface to support dynamic dispatch.
type IIncDecExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PreIncDecExpression() IPreIncDecExpressionContext
	PostIncDecExpression() IPostIncDecExpressionContext

	// IsIncDecExpressionContext differentiates from other interfaces.
	IsIncDecExpressionContext()
}

type IncDecExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncDecExpressionContext() *IncDecExpressionContext {
	var p = new(IncDecExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_incDecExpression
	return p
}

func InitEmptyIncDecExpressionContext(p *IncDecExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_incDecExpression
}

func (*IncDecExpressionContext) IsIncDecExpressionContext() {}

func NewIncDecExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncDecExpressionContext {
	var p = new(IncDecExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_incDecExpression

	return p
}

func (s *IncDecExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IncDecExpressionContext) PreIncDecExpression() IPreIncDecExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreIncDecExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreIncDecExpressionContext)
}

func (s *IncDecExpressionContext) PostIncDecExpression() IPostIncDecExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostIncDecExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostIncDecExpressionContext)
}

func (s *IncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncDecExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) IncDecExpression() (localctx IIncDecExpressionContext) {
	localctx = NewIncDecExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, huloParserRULE_incDecExpression)
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(559)
			p.PreIncDecExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(560)
			p.PostIncDecExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreIncDecExpressionContext is an interface to support dynamic dispatch.
type IPreIncDecExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	INC() antlr.TerminalNode
	DEC() antlr.TerminalNode

	// IsPreIncDecExpressionContext differentiates from other interfaces.
	IsPreIncDecExpressionContext()
}

type PreIncDecExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreIncDecExpressionContext() *PreIncDecExpressionContext {
	var p = new(PreIncDecExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_preIncDecExpression
	return p
}

func InitEmptyPreIncDecExpressionContext(p *PreIncDecExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_preIncDecExpression
}

func (*PreIncDecExpressionContext) IsPreIncDecExpressionContext() {}

func NewPreIncDecExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreIncDecExpressionContext {
	var p = new(PreIncDecExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_preIncDecExpression

	return p
}

func (s *PreIncDecExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PreIncDecExpressionContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PreIncDecExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(huloParserINC, 0)
}

func (s *PreIncDecExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(huloParserDEC, 0)
}

func (s *PreIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreIncDecExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreIncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitPreIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) PreIncDecExpression() (localctx IPreIncDecExpressionContext) {
	localctx = NewPreIncDecExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, huloParserRULE_preIncDecExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserINC || _la == huloParserDEC {
		{
			p.SetState(563)
			_la = p.GetTokenStream().LA(1)

			if !(_la == huloParserINC || _la == huloParserDEC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(566)
		p.Factor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostIncDecExpressionContext is an interface to support dynamic dispatch.
type IPostIncDecExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Factor() IFactorContext
	INC() antlr.TerminalNode
	DEC() antlr.TerminalNode

	// IsPostIncDecExpressionContext differentiates from other interfaces.
	IsPostIncDecExpressionContext()
}

type PostIncDecExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostIncDecExpressionContext() *PostIncDecExpressionContext {
	var p = new(PostIncDecExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_postIncDecExpression
	return p
}

func InitEmptyPostIncDecExpressionContext(p *PostIncDecExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_postIncDecExpression
}

func (*PostIncDecExpressionContext) IsPostIncDecExpressionContext() {}

func NewPostIncDecExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostIncDecExpressionContext {
	var p = new(PostIncDecExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_postIncDecExpression

	return p
}

func (s *PostIncDecExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostIncDecExpressionContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *PostIncDecExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(huloParserINC, 0)
}

func (s *PostIncDecExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(huloParserDEC, 0)
}

func (s *PostIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostIncDecExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostIncDecExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitPostIncDecExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) PostIncDecExpression() (localctx IPostIncDecExpressionContext) {
	localctx = NewPostIncDecExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, huloParserRULE_postIncDecExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)
		p.Factor()
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(569)
			_la = p.GetTokenStream().LA(1)

			if !(_la == huloParserINC || _la == huloParserDEC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFactorContext is an interface to support dynamic dispatch.
type IFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Factor() IFactorContext
	RPAREN() antlr.TerminalNode
	SUB() antlr.TerminalNode
	Literal() ILiteralContext
	ListExpression() IListExpressionContext
	TripleExpression() ITripleExpressionContext
	MapExpression() IMapExpressionContext
	MethodExpression() IMethodExpressionContext
	VariableExpression() IVariableExpressionContext
	CallExpression() ICallExpressionContext
	FileExpression() IFileExpressionContext

	// IsFactorContext differentiates from other interfaces.
	IsFactorContext()
}

type FactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactorContext() *FactorContext {
	var p = new(FactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_factor
	return p
}

func InitEmptyFactorContext(p *FactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_factor
}

func (*FactorContext) IsFactorContext() {}

func NewFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FactorContext {
	var p = new(FactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_factor

	return p
}

func (s *FactorContext) GetParser() antlr.Parser { return s.parser }

func (s *FactorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *FactorContext) Factor() IFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFactorContext)
}

func (s *FactorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *FactorContext) SUB() antlr.TerminalNode {
	return s.GetToken(huloParserSUB, 0)
}

func (s *FactorContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *FactorContext) ListExpression() IListExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListExpressionContext)
}

func (s *FactorContext) TripleExpression() ITripleExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITripleExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITripleExpressionContext)
}

func (s *FactorContext) MapExpression() IMapExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionContext)
}

func (s *FactorContext) MethodExpression() IMethodExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodExpressionContext)
}

func (s *FactorContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *FactorContext) CallExpression() ICallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionContext)
}

func (s *FactorContext) FileExpression() IFileExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileExpressionContext)
}

func (s *FactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Factor() (localctx IFactorContext) {
	localctx = NewFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, huloParserRULE_factor)
	p.SetState(586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(572)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(573)
			p.Factor()
		}
		{
			p.SetState(574)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(576)
			p.Match(huloParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(577)
			p.Factor()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(578)
			p.Literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(579)
			p.ListExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(580)
			p.TripleExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(581)
			p.MapExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(582)
			p.MethodExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(583)
			p.VariableExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(584)
			p.CallExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(585)
			p.FileExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITripleExpressionContext is an interface to support dynamic dispatch.
type ITripleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTripleExpressionContext differentiates from other interfaces.
	IsTripleExpressionContext()
}

type TripleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTripleExpressionContext() *TripleExpressionContext {
	var p = new(TripleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_tripleExpression
	return p
}

func InitEmptyTripleExpressionContext(p *TripleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_tripleExpression
}

func (*TripleExpressionContext) IsTripleExpressionContext() {}

func NewTripleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TripleExpressionContext {
	var p = new(TripleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_tripleExpression

	return p
}

func (s *TripleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TripleExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *TripleExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TripleExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TripleExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *TripleExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *TripleExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *TripleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TripleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TripleExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTripleExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TripleExpression() (localctx ITripleExpressionContext) {
	localctx = NewTripleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, huloParserRULE_tripleExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(588)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(589)
		p.Expression()
	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(590)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(591)
			p.Expression()
		}

		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(597)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListExpressionContext is an interface to support dynamic dispatch.
type IListExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACK() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsListExpressionContext differentiates from other interfaces.
	IsListExpressionContext()
}

type ListExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListExpressionContext() *ListExpressionContext {
	var p = new(ListExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_listExpression
	return p
}

func InitEmptyListExpressionContext(p *ListExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_listExpression
}

func (*ListExpressionContext) IsListExpressionContext() {}

func NewListExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListExpressionContext {
	var p = new(ListExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_listExpression

	return p
}

func (s *ListExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListExpressionContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACK, 0)
}

func (s *ListExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListExpressionContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACK, 0)
}

func (s *ListExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ListExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ListExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitListExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ListExpression() (localctx IListExpressionContext) {
	localctx = NewListExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, huloParserRULE_listExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(huloParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(600)
		p.Expression()
	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(601)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(602)
			p.Expression()
		}

		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(608)
		p.Match(huloParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewDelExpressionContext is an interface to support dynamic dispatch.
type INewDelExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CallExpression() ICallExpressionContext
	NEW() antlr.TerminalNode
	DELETE() antlr.TerminalNode

	// IsNewDelExpressionContext differentiates from other interfaces.
	IsNewDelExpressionContext()
}

type NewDelExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewDelExpressionContext() *NewDelExpressionContext {
	var p = new(NewDelExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_newDelExpression
	return p
}

func InitEmptyNewDelExpressionContext(p *NewDelExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_newDelExpression
}

func (*NewDelExpressionContext) IsNewDelExpressionContext() {}

func NewNewDelExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewDelExpressionContext {
	var p = new(NewDelExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_newDelExpression

	return p
}

func (s *NewDelExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NewDelExpressionContext) CallExpression() ICallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionContext)
}

func (s *NewDelExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(huloParserNEW, 0)
}

func (s *NewDelExpressionContext) DELETE() antlr.TerminalNode {
	return s.GetToken(huloParserDELETE, 0)
}

func (s *NewDelExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewDelExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewDelExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNewDelExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NewDelExpression() (localctx INewDelExpressionContext) {
	localctx = NewNewDelExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, huloParserRULE_newDelExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserNEW || _la == huloParserDELETE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(611)
		p.CallExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionContext is an interface to support dynamic dispatch.
type IMapExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllPair() []IPairContext
	Pair(i int) IPairContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapExpressionContext differentiates from other interfaces.
	IsMapExpressionContext()
}

type MapExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpressionContext() *MapExpressionContext {
	var p = new(MapExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_mapExpression
	return p
}

func InitEmptyMapExpressionContext(p *MapExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_mapExpression
}

func (*MapExpressionContext) IsMapExpressionContext() {}

func NewMapExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionContext {
	var p = new(MapExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_mapExpression

	return p
}

func (s *MapExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *MapExpressionContext) AllPair() []IPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPairContext); ok {
			len++
		}
	}

	tst := make([]IPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPairContext); ok {
			tst[i] = t.(IPairContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionContext) Pair(i int) IPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPairContext)
}

func (s *MapExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *MapExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *MapExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *MapExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMapExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MapExpression() (localctx IMapExpressionContext) {
	localctx = NewMapExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, huloParserRULE_mapExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(614)
		p.Pair()
	}
	p.SetState(619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(615)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.Pair()
		}

		p.SetState(621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(622)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPairContext is an interface to support dynamic dispatch.
type IPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Expression() IExpressionContext
	NumberLiteral() antlr.TerminalNode
	BoolLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsPairContext differentiates from other interfaces.
	IsPairContext()
}

type PairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPairContext() *PairContext {
	var p = new(PairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_pair
	return p
}

func InitEmptyPairContext(p *PairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_pair
}

func (*PairContext) IsPairContext() {}

func NewPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PairContext {
	var p = new(PairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_pair

	return p
}

func (s *PairContext) GetParser() antlr.Parser { return s.parser }

func (s *PairContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *PairContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PairContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserNumberLiteral, 0)
}

func (s *PairContext) BoolLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserBoolLiteral, 0)
}

func (s *PairContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *PairContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *PairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitPair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Pair() (localctx IPairContext) {
	localctx = NewPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, huloParserRULE_pair)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&519) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(625)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(626)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableExpressionContext is an interface to support dynamic dispatch.
type IVariableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOLLAR() antlr.TerminalNode
	MemberAccess() IMemberAccessContext

	// IsVariableExpressionContext differentiates from other interfaces.
	IsVariableExpressionContext()
}

type VariableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableExpressionContext() *VariableExpressionContext {
	var p = new(VariableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableExpression
	return p
}

func InitEmptyVariableExpressionContext(p *VariableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableExpression
}

func (*VariableExpressionContext) IsVariableExpressionContext() {}

func NewVariableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableExpressionContext {
	var p = new(VariableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_variableExpression

	return p
}

func (s *VariableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableExpressionContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(huloParserDOLLAR, 0)
}

func (s *VariableExpressionContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *VariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitVariableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) VariableExpression() (localctx IVariableExpressionContext) {
	localctx = NewVariableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, huloParserRULE_variableExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(huloParserDOLLAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(629)
		p.MemberAccess()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodExpressionContext is an interface to support dynamic dispatch.
type IMethodExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOLLAR() antlr.TerminalNode
	MemberAccess() IMemberAccessContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverArgumentList() IReceiverArgumentListContext

	// IsMethodExpressionContext differentiates from other interfaces.
	IsMethodExpressionContext()
}

type MethodExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodExpressionContext() *MethodExpressionContext {
	var p = new(MethodExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_methodExpression
	return p
}

func InitEmptyMethodExpressionContext(p *MethodExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_methodExpression
}

func (*MethodExpressionContext) IsMethodExpressionContext() {}

func NewMethodExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodExpressionContext {
	var p = new(MethodExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_methodExpression

	return p
}

func (s *MethodExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodExpressionContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(huloParserDOLLAR, 0)
}

func (s *MethodExpressionContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *MethodExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *MethodExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *MethodExpressionContext) ReceiverArgumentList() IReceiverArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverArgumentListContext)
}

func (s *MethodExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMethodExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MethodExpression() (localctx IMethodExpressionContext) {
	localctx = NewMethodExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, huloParserRULE_methodExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(huloParserDOLLAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(632)
		p.MemberAccess()
	}
	{
		p.SetState(633)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
		{
			p.SetState(634)
			p.ReceiverArgumentList()
		}

	}
	{
		p.SetState(637)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaExpression() ILambdaExpressionContext
	ConditionalExpression() IConditionalExpressionContext
	NewDelExpression() INewDelExpressionContext
	ClassInitializeExpression() IClassInitializeExpressionContext
	TypeofExpression() ITypeofExpressionContext
	ChannelOutputExpression() IChannelOutputExpressionContext
	CommandExpression() ICommandExpressionContext
	UnsafeExpression() IUnsafeExpressionContext
	ComptimeExpression() IComptimeExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ExpressionContext) NewDelExpression() INewDelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewDelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewDelExpressionContext)
}

func (s *ExpressionContext) ClassInitializeExpression() IClassInitializeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassInitializeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassInitializeExpressionContext)
}

func (s *ExpressionContext) TypeofExpression() ITypeofExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeofExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeofExpressionContext)
}

func (s *ExpressionContext) ChannelOutputExpression() IChannelOutputExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelOutputExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelOutputExpressionContext)
}

func (s *ExpressionContext) CommandExpression() ICommandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandExpressionContext)
}

func (s *ExpressionContext) UnsafeExpression() IUnsafeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsafeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsafeExpressionContext)
}

func (s *ExpressionContext) ComptimeExpression() IComptimeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComptimeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComptimeExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, huloParserRULE_expression)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(639)
			p.LambdaExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(640)
			p.ConditionalExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(641)
			p.NewDelExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(642)
			p.ClassInitializeExpression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(643)
			p.TypeofExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(644)
			p.ChannelOutputExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(645)
			p.CommandExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(646)
			p.UnsafeExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(647)
			p.ComptimeExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, huloParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Expression()
	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(651)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(652)
				p.Expression()
			}

		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberAccessContext is an interface to support dynamic dispatch.
type IMemberAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	GenericArguments() IGenericArgumentsContext
	MemberAccessPoint() IMemberAccessPointContext
	Literal() ILiteralContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	STR() antlr.TerminalNode
	NUM() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsMemberAccessContext differentiates from other interfaces.
	IsMemberAccessContext()
}

type MemberAccessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessContext() *MemberAccessContext {
	var p = new(MemberAccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_memberAccess
	return p
}

func InitEmptyMemberAccessContext(p *MemberAccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_memberAccess
}

func (*MemberAccessContext) IsMemberAccessContext() {}

func NewMemberAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessContext {
	var p = new(MemberAccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_memberAccess

	return p
}

func (s *MemberAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *MemberAccessContext) GenericArguments() IGenericArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentsContext)
}

func (s *MemberAccessContext) MemberAccessPoint() IMemberAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessPointContext)
}

func (s *MemberAccessContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MemberAccessContext) THIS() antlr.TerminalNode {
	return s.GetToken(huloParserTHIS, 0)
}

func (s *MemberAccessContext) SUPER() antlr.TerminalNode {
	return s.GetToken(huloParserSUPER, 0)
}

func (s *MemberAccessContext) STR() antlr.TerminalNode {
	return s.GetToken(huloParserSTR, 0)
}

func (s *MemberAccessContext) NUM() antlr.TerminalNode {
	return s.GetToken(huloParserNUM, 0)
}

func (s *MemberAccessContext) BOOL() antlr.TerminalNode {
	return s.GetToken(huloParserBOOL, 0)
}

func (s *MemberAccessContext) NOT() antlr.TerminalNode {
	return s.GetToken(huloParserNOT, 0)
}

func (s *MemberAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMemberAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MemberAccess() (localctx IMemberAccessContext) {
	localctx = NewMemberAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, huloParserRULE_memberAccess)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(658)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(659)
			p.GenericArguments()
		}

	case 2:
		{
			p.SetState(660)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(661)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(664)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(665)
			p.MemberAccessPoint()
		}

	case 4:
		{
			p.SetState(666)
			p.Literal()
		}
		{
			p.SetState(667)
			p.MemberAccessPoint()
		}

	case 5:
		{
			p.SetState(669)
			p.Match(huloParserTHIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(670)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		{
			p.SetState(673)
			p.Match(huloParserSUPER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(674)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(679)
			p.Match(huloParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileExpressionContext is an interface to support dynamic dispatch.
type IFileExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FileStringLiteral() antlr.TerminalNode
	CallExpressionLinkedList() ICallExpressionLinkedListContext

	// IsFileExpressionContext differentiates from other interfaces.
	IsFileExpressionContext()
}

type FileExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileExpressionContext() *FileExpressionContext {
	var p = new(FileExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_fileExpression
	return p
}

func InitEmptyFileExpressionContext(p *FileExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_fileExpression
}

func (*FileExpressionContext) IsFileExpressionContext() {}

func NewFileExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileExpressionContext {
	var p = new(FileExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_fileExpression

	return p
}

func (s *FileExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FileExpressionContext) FileStringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserFileStringLiteral, 0)
}

func (s *FileExpressionContext) CallExpressionLinkedList() ICallExpressionLinkedListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionLinkedListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionLinkedListContext)
}

func (s *FileExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFileExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FileExpression() (localctx IFileExpressionContext) {
	localctx = NewFileExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, huloParserRULE_fileExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Match(huloParserFileStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserDOT || _la == huloParserDOUBLE_DOT {
		{
			p.SetState(683)
			p.CallExpressionLinkedList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallExpressionContext is an interface to support dynamic dispatch.
type ICallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccess() IMemberAccessContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	NOT() antlr.TerminalNode
	ReceiverArgumentList() IReceiverArgumentListContext
	CallExpressionLinkedList() ICallExpressionLinkedListContext

	// IsCallExpressionContext differentiates from other interfaces.
	IsCallExpressionContext()
}

type CallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallExpressionContext() *CallExpressionContext {
	var p = new(CallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_callExpression
	return p
}

func InitEmptyCallExpressionContext(p *CallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_callExpression
}

func (*CallExpressionContext) IsCallExpressionContext() {}

func NewCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallExpressionContext {
	var p = new(CallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_callExpression

	return p
}

func (s *CallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CallExpressionContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *CallExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *CallExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *CallExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(huloParserNOT, 0)
}

func (s *CallExpressionContext) ReceiverArgumentList() IReceiverArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverArgumentListContext)
}

func (s *CallExpressionContext) CallExpressionLinkedList() ICallExpressionLinkedListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionLinkedListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionLinkedListContext)
}

func (s *CallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CallExpression() (localctx ICallExpressionContext) {
	localctx = NewCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, huloParserRULE_callExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(686)
		p.MemberAccess()
	}
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserNOT {
		{
			p.SetState(687)
			p.Match(huloParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(690)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
		{
			p.SetState(691)
			p.ReceiverArgumentList()
		}

	}
	{
		p.SetState(694)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserDOT || _la == huloParserDOUBLE_DOT {
		{
			p.SetState(695)
			p.CallExpressionLinkedList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallExpressionLinkedListContext is an interface to support dynamic dispatch.
type ICallExpressionLinkedListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverArgumentList() IReceiverArgumentListContext
	CallExpressionLinkedList() ICallExpressionLinkedListContext
	DOUBLE_DOT() antlr.TerminalNode

	// IsCallExpressionLinkedListContext differentiates from other interfaces.
	IsCallExpressionLinkedListContext()
}

type CallExpressionLinkedListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallExpressionLinkedListContext() *CallExpressionLinkedListContext {
	var p = new(CallExpressionLinkedListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_callExpressionLinkedList
	return p
}

func InitEmptyCallExpressionLinkedListContext(p *CallExpressionLinkedListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_callExpressionLinkedList
}

func (*CallExpressionLinkedListContext) IsCallExpressionLinkedListContext() {}

func NewCallExpressionLinkedListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallExpressionLinkedListContext {
	var p = new(CallExpressionLinkedListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_callExpressionLinkedList

	return p
}

func (s *CallExpressionLinkedListContext) GetParser() antlr.Parser { return s.parser }

func (s *CallExpressionLinkedListContext) DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOT, 0)
}

func (s *CallExpressionLinkedListContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *CallExpressionLinkedListContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *CallExpressionLinkedListContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *CallExpressionLinkedListContext) ReceiverArgumentList() IReceiverArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverArgumentListContext)
}

func (s *CallExpressionLinkedListContext) CallExpressionLinkedList() ICallExpressionLinkedListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionLinkedListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionLinkedListContext)
}

func (s *CallExpressionLinkedListContext) DOUBLE_DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_DOT, 0)
}

func (s *CallExpressionLinkedListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallExpressionLinkedListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallExpressionLinkedListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCallExpressionLinkedList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CallExpressionLinkedList() (localctx ICallExpressionLinkedListContext) {
	localctx = NewCallExpressionLinkedListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, huloParserRULE_callExpressionLinkedList)
	var _la int

	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)
			p.Match(huloParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(699)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(700)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
			{
				p.SetState(701)
				p.ReceiverArgumentList()
			}

		}
		{
			p.SetState(704)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserDOT || _la == huloParserDOUBLE_DOT {
			{
				p.SetState(705)
				p.CallExpressionLinkedList()
			}

		}

	case huloParserDOUBLE_DOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(708)
			p.Match(huloParserDOUBLE_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(709)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(710)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
			{
				p.SetState(711)
				p.ReceiverArgumentList()
			}

		}
		{
			p.SetState(714)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserDOT || _la == huloParserDOUBLE_DOT {
			{
				p.SetState(715)
				p.CallExpressionLinkedList()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberAccessPointContext is an interface to support dynamic dispatch.
type IMemberAccessPointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	MemberAccessPoint() IMemberAccessPointContext
	GenericArguments() IGenericArgumentsContext
	DOUBLE_COLON() antlr.TerminalNode
	VariableExpression() IVariableExpressionContext
	LBRACK() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACK() antlr.TerminalNode

	// IsMemberAccessPointContext differentiates from other interfaces.
	IsMemberAccessPointContext()
}

type MemberAccessPointContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessPointContext() *MemberAccessPointContext {
	var p = new(MemberAccessPointContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_memberAccessPoint
	return p
}

func InitEmptyMemberAccessPointContext(p *MemberAccessPointContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_memberAccessPoint
}

func (*MemberAccessPointContext) IsMemberAccessPointContext() {}

func NewMemberAccessPointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessPointContext {
	var p = new(MemberAccessPointContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_memberAccessPoint

	return p
}

func (s *MemberAccessPointContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessPointContext) DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOT, 0)
}

func (s *MemberAccessPointContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *MemberAccessPointContext) MemberAccessPoint() IMemberAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessPointContext)
}

func (s *MemberAccessPointContext) GenericArguments() IGenericArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericArgumentsContext)
}

func (s *MemberAccessPointContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_COLON, 0)
}

func (s *MemberAccessPointContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *MemberAccessPointContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACK, 0)
}

func (s *MemberAccessPointContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MemberAccessPointContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACK, 0)
}

func (s *MemberAccessPointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessPointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessPointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMemberAccessPoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MemberAccessPoint() (localctx IMemberAccessPointContext) {
	localctx = NewMemberAccessPointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, huloParserRULE_memberAccessPoint)
	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.Match(huloParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(721)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(723)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(722)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(725)
			p.Match(huloParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(727)
			p.GenericArguments()
		}
		p.SetState(729)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(728)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(731)
			p.Match(huloParserDOUBLE_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(734)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(733)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(736)
			p.Match(huloParserDOUBLE_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(737)
			p.VariableExpression()
		}
		p.SetState(739)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(738)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(741)
			p.Match(huloParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(742)
			p.Expression()
		}
		{
			p.SetState(743)
			p.Match(huloParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(745)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(744)
				p.MemberAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NumberLiteral() antlr.TerminalNode
	BoolLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserNumberLiteral, 0)
}

func (s *LiteralContext) BoolLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserBoolLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(huloParserNULL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, huloParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&897) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverArgumentListContext is an interface to support dynamic dispatch.
type IReceiverArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext
	COMMA() antlr.TerminalNode
	NamedArgumentList() INamedArgumentListContext

	// IsReceiverArgumentListContext differentiates from other interfaces.
	IsReceiverArgumentListContext()
}

type ReceiverArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverArgumentListContext() *ReceiverArgumentListContext {
	var p = new(ReceiverArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverArgumentList
	return p
}

func InitEmptyReceiverArgumentListContext(p *ReceiverArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverArgumentList
}

func (*ReceiverArgumentListContext) IsReceiverArgumentListContext() {}

func NewReceiverArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverArgumentListContext {
	var p = new(ReceiverArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_receiverArgumentList

	return p
}

func (s *ReceiverArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverArgumentListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ReceiverArgumentListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, 0)
}

func (s *ReceiverArgumentListContext) NamedArgumentList() INamedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentListContext)
}

func (s *ReceiverArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitReceiverArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ReceiverArgumentList() (localctx IReceiverArgumentListContext) {
	localctx = NewReceiverArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, huloParserRULE_receiverArgumentList)
	var _la int

	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.ExpressionList()
		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOMMA {
			{
				p.SetState(752)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(753)
				p.NamedArgumentList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.NamedArgumentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentListContext is an interface to support dynamic dispatch.
type INamedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedArgument() []INamedArgumentContext
	NamedArgument(i int) INamedArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedArgumentListContext differentiates from other interfaces.
	IsNamedArgumentListContext()
}

type NamedArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentListContext() *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedArgumentList
	return p
}

func InitEmptyNamedArgumentListContext(p *NamedArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedArgumentList
}

func (*NamedArgumentListContext) IsNamedArgumentListContext() {}

func NewNamedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_namedArgumentList

	return p
}

func (s *NamedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *NamedArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *NamedArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *NamedArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *NamedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNamedArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NamedArgumentList() (localctx INamedArgumentListContext) {
	localctx = NewNamedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, huloParserRULE_namedArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.NamedArgument()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(760)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(761)
			p.NamedArgument()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedArgument
	return p
}

func InitEmptyNamedArgumentContext(p *NamedArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedArgument
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *NamedArgumentContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *NamedArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNamedArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NamedArgument() (localctx INamedArgumentContext) {
	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, huloParserRULE_namedArgument)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(768)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(769)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WILDCARD() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableName
	return p
}

func InitEmptyVariableNameContext(p *VariableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_variableName
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) WILDCARD() antlr.TerminalNode {
	return s.GetToken(huloParserWILDCARD, 0)
}

func (s *VariableNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *VariableNameContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *VariableNameContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) VariableName() (localctx IVariableNameContext) {
	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, huloParserRULE_variableName)
	var _la int

	p.SetState(777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserWILDCARD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(771)
			p.Match(huloParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(772)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOLON {
			{
				p.SetState(773)
				p.Match(huloParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(774)
				p.Type_()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNumberLiteral() []antlr.TerminalNode
	NumberLiteral(i int) antlr.TerminalNode
	DOUBLE_DOT() antlr.TerminalNode

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_rangeExpression
	return p
}

func InitEmptyRangeExpressionContext(p *RangeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_rangeExpression
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllNumberLiteral() []antlr.TerminalNode {
	return s.GetTokens(huloParserNumberLiteral)
}

func (s *RangeExpressionContext) NumberLiteral(i int) antlr.TerminalNode {
	return s.GetToken(huloParserNumberLiteral, i)
}

func (s *RangeExpressionContext) DOUBLE_DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_DOT, 0)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitRangeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) RangeExpression() (localctx IRangeExpressionContext) {
	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, huloParserRULE_rangeExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(huloParserNumberLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(780)
		p.Match(huloParserDOUBLE_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Match(huloParserNumberLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, huloParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionContext is an interface to support dynamic dispatch.
type IOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ShortOption() IShortOptionContext
	LongOption() ILongOptionContext

	// IsOptionContext differentiates from other interfaces.
	IsOptionContext()
}

type OptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionContext() *OptionContext {
	var p = new(OptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_option
	return p
}

func InitEmptyOptionContext(p *OptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_option
}

func (*OptionContext) IsOptionContext() {}

func NewOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionContext {
	var p = new(OptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_option

	return p
}

func (s *OptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionContext) ShortOption() IShortOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShortOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShortOptionContext)
}

func (s *OptionContext) LongOption() ILongOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILongOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILongOptionContext)
}

func (s *OptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Option() (localctx IOptionContext) {
	localctx = NewOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, huloParserRULE_option)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserSUB:
		{
			p.SetState(785)
			p.ShortOption()
		}

	case huloParserDEC:
		{
			p.SetState(786)
			p.LongOption()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShortOptionContext is an interface to support dynamic dispatch.
type IShortOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUB() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsShortOptionContext differentiates from other interfaces.
	IsShortOptionContext()
}

type ShortOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShortOptionContext() *ShortOptionContext {
	var p = new(ShortOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_shortOption
	return p
}

func InitEmptyShortOptionContext(p *ShortOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_shortOption
}

func (*ShortOptionContext) IsShortOptionContext() {}

func NewShortOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShortOptionContext {
	var p = new(ShortOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_shortOption

	return p
}

func (s *ShortOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShortOptionContext) SUB() antlr.TerminalNode {
	return s.GetToken(huloParserSUB, 0)
}

func (s *ShortOptionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ShortOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShortOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShortOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitShortOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ShortOption() (localctx IShortOptionContext) {
	localctx = NewShortOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, huloParserRULE_shortOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.Match(huloParserSUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(790)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILongOptionContext is an interface to support dynamic dispatch.
type ILongOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEC() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsLongOptionContext differentiates from other interfaces.
	IsLongOptionContext()
}

type LongOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLongOptionContext() *LongOptionContext {
	var p = new(LongOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_longOption
	return p
}

func InitEmptyLongOptionContext(p *LongOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_longOption
}

func (*LongOptionContext) IsLongOptionContext() {}

func NewLongOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LongOptionContext {
	var p = new(LongOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_longOption

	return p
}

func (s *LongOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LongOptionContext) DEC() antlr.TerminalNode {
	return s.GetToken(huloParserDEC, 0)
}

func (s *LongOptionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *LongOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LongOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLongOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LongOption() (localctx ILongOptionContext) {
	localctx = NewLongOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, huloParserRULE_longOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(huloParserDEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandExpressionContext is an interface to support dynamic dispatch.
type ICommandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccess() IMemberAccessContext
	CommandStringLiteral() antlr.TerminalNode
	AllCommandArgument() []ICommandArgumentContext
	CommandArgument(i int) ICommandArgumentContext
	BITAND() antlr.TerminalNode
	BuiltinCommandArgument() IBuiltinCommandArgumentContext
	CommandJoin() ICommandJoinContext
	CommandStream() ICommandStreamContext

	// IsCommandExpressionContext differentiates from other interfaces.
	IsCommandExpressionContext()
}

type CommandExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandExpressionContext() *CommandExpressionContext {
	var p = new(CommandExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandExpression
	return p
}

func InitEmptyCommandExpressionContext(p *CommandExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandExpression
}

func (*CommandExpressionContext) IsCommandExpressionContext() {}

func NewCommandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandExpressionContext {
	var p = new(CommandExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_commandExpression

	return p
}

func (s *CommandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandExpressionContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *CommandExpressionContext) CommandStringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserCommandStringLiteral, 0)
}

func (s *CommandExpressionContext) AllCommandArgument() []ICommandArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICommandArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommandArgumentContext); ok {
			tst[i] = t.(ICommandArgumentContext)
			i++
		}
	}

	return tst
}

func (s *CommandExpressionContext) CommandArgument(i int) ICommandArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandArgumentContext)
}

func (s *CommandExpressionContext) BITAND() antlr.TerminalNode {
	return s.GetToken(huloParserBITAND, 0)
}

func (s *CommandExpressionContext) BuiltinCommandArgument() IBuiltinCommandArgumentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuiltinCommandArgumentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuiltinCommandArgumentContext)
}

func (s *CommandExpressionContext) CommandJoin() ICommandJoinContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandJoinContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandJoinContext)
}

func (s *CommandExpressionContext) CommandStream() ICommandStreamContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandStreamContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandStreamContext)
}

func (s *CommandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCommandExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CommandExpression() (localctx ICommandExpressionContext) {
	localctx = NewCommandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, huloParserRULE_commandExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserTHIS, huloParserSUPER, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserIdentifier:
		{
			p.SetState(795)
			p.MemberAccess()
		}

	case huloParserCommandStringLiteral:
		{
			p.SetState(796)
			p.Match(huloParserCommandStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(799)
				p.CommandArgument()
			}

		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserBITAND {
		{
			p.SetState(805)
			p.Match(huloParserBITAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserTRIPLE_MINUS {
		{
			p.SetState(808)
			p.BuiltinCommandArgument()
		}

	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case huloParserAND, huloParserOR:
		{
			p.SetState(811)
			p.CommandJoin()
		}

	case huloParserLT, huloParserGT, huloParserSHL, huloParserSHR, huloParserBITOR:
		{
			p.SetState(812)
			p.CommandStream()
		}

	case huloParserEOF, huloParserMOD_LIT, huloParserUSE, huloParserIMPORT, huloParserTYPE, huloParserTYPEOF, huloParserIF, huloParserMATCH, huloParserDO, huloParserLOOP, huloParserCONTINUE, huloParserBREAK, huloParserLET, huloParserVAR, huloParserCONST, huloParserSTATIC, huloParserFINAL, huloParserPUB, huloParserTRY, huloParserTHROW, huloParserTHROWS, huloParserFN, huloParserRETURN, huloParserENUM, huloParserCLASS, huloParserTRAIT, huloParserIMPL, huloParserTHIS, huloParserSUPER, huloParserEXTEND, huloParserDECLARE, huloParserDEFER, huloParserCOMPTIME, huloParserEXTERN, huloParserCOMMA, huloParserLPAREN, huloParserRPAREN, huloParserLBRACK, huloParserRBRACK, huloParserLBRACE, huloParserRBRACE, huloParserSUB, huloParserAT, huloParserDOLLAR, huloParserWILDCARD, huloParserNEQ, huloParserEQ, huloParserBACKARROW, huloParserDOUBLE_ARROW, huloParserSEMI, huloParserINC, huloParserDEC, huloParserNEW, huloParserDELETE, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserUnsafeLiteral, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserFileStringLiteral, huloParserCommandStringLiteral, huloParserLineComment, huloParserBlockComment, huloParserIdentifier:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandArgumentContext is an interface to support dynamic dispatch.
type ICommandArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Option() IOptionContext
	ConditionalExpression() IConditionalExpressionContext
	MemberAccess() IMemberAccessContext

	// IsCommandArgumentContext differentiates from other interfaces.
	IsCommandArgumentContext()
}

type CommandArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandArgumentContext() *CommandArgumentContext {
	var p = new(CommandArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandArgument
	return p
}

func InitEmptyCommandArgumentContext(p *CommandArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandArgument
}

func (*CommandArgumentContext) IsCommandArgumentContext() {}

func NewCommandArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandArgumentContext {
	var p = new(CommandArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_commandArgument

	return p
}

func (s *CommandArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandArgumentContext) Option() IOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionContext)
}

func (s *CommandArgumentContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *CommandArgumentContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *CommandArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCommandArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CommandArgument() (localctx ICommandArgumentContext) {
	localctx = NewCommandArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, huloParserRULE_commandArgument)
	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.Option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(816)
			p.ConditionalExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(817)
			p.MemberAccess()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuiltinCommandArgumentContext is an interface to support dynamic dispatch.
type IBuiltinCommandArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIPLE_MINUS() antlr.TerminalNode
	AllCommandArgument() []ICommandArgumentContext
	CommandArgument(i int) ICommandArgumentContext

	// IsBuiltinCommandArgumentContext differentiates from other interfaces.
	IsBuiltinCommandArgumentContext()
}

type BuiltinCommandArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinCommandArgumentContext() *BuiltinCommandArgumentContext {
	var p = new(BuiltinCommandArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_builtinCommandArgument
	return p
}

func InitEmptyBuiltinCommandArgumentContext(p *BuiltinCommandArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_builtinCommandArgument
}

func (*BuiltinCommandArgumentContext) IsBuiltinCommandArgumentContext() {}

func NewBuiltinCommandArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinCommandArgumentContext {
	var p = new(BuiltinCommandArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_builtinCommandArgument

	return p
}

func (s *BuiltinCommandArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinCommandArgumentContext) TRIPLE_MINUS() antlr.TerminalNode {
	return s.GetToken(huloParserTRIPLE_MINUS, 0)
}

func (s *BuiltinCommandArgumentContext) AllCommandArgument() []ICommandArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			len++
		}
	}

	tst := make([]ICommandArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommandArgumentContext); ok {
			tst[i] = t.(ICommandArgumentContext)
			i++
		}
	}

	return tst
}

func (s *BuiltinCommandArgumentContext) CommandArgument(i int) ICommandArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandArgumentContext)
}

func (s *BuiltinCommandArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinCommandArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinCommandArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitBuiltinCommandArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) BuiltinCommandArgument() (localctx IBuiltinCommandArgumentContext) {
	localctx = NewBuiltinCommandArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, huloParserRULE_builtinCommandArgument)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Match(huloParserTRIPLE_MINUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(821)
				p.CommandArgument()
			}

		}
		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandJoinContext is an interface to support dynamic dispatch.
type ICommandJoinContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommandExpression() ICommandExpressionContext
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsCommandJoinContext differentiates from other interfaces.
	IsCommandJoinContext()
}

type CommandJoinContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandJoinContext() *CommandJoinContext {
	var p = new(CommandJoinContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandJoin
	return p
}

func InitEmptyCommandJoinContext(p *CommandJoinContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandJoin
}

func (*CommandJoinContext) IsCommandJoinContext() {}

func NewCommandJoinContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandJoinContext {
	var p = new(CommandJoinContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_commandJoin

	return p
}

func (s *CommandJoinContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandJoinContext) CommandExpression() ICommandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandExpressionContext)
}

func (s *CommandJoinContext) AND() antlr.TerminalNode {
	return s.GetToken(huloParserAND, 0)
}

func (s *CommandJoinContext) OR() antlr.TerminalNode {
	return s.GetToken(huloParserOR, 0)
}

func (s *CommandJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandJoinContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCommandJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CommandJoin() (localctx ICommandJoinContext) {
	localctx = NewCommandJoinContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, huloParserRULE_commandJoin)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserAND || _la == huloParserOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(828)
		p.CommandExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandStreamContext is an interface to support dynamic dispatch.
type ICommandStreamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommandExpression() ICommandExpressionContext
	BITOR() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	SHL() antlr.TerminalNode
	SHR() antlr.TerminalNode

	// IsCommandStreamContext differentiates from other interfaces.
	IsCommandStreamContext()
}

type CommandStreamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandStreamContext() *CommandStreamContext {
	var p = new(CommandStreamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandStream
	return p
}

func InitEmptyCommandStreamContext(p *CommandStreamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandStream
}

func (*CommandStreamContext) IsCommandStreamContext() {}

func NewCommandStreamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandStreamContext {
	var p = new(CommandStreamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_commandStream

	return p
}

func (s *CommandStreamContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandStreamContext) CommandExpression() ICommandExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandExpressionContext)
}

func (s *CommandStreamContext) BITOR() antlr.TerminalNode {
	return s.GetToken(huloParserBITOR, 0)
}

func (s *CommandStreamContext) LT() antlr.TerminalNode {
	return s.GetToken(huloParserLT, 0)
}

func (s *CommandStreamContext) GT() antlr.TerminalNode {
	return s.GetToken(huloParserGT, 0)
}

func (s *CommandStreamContext) SHL() antlr.TerminalNode {
	return s.GetToken(huloParserSHL, 0)
}

func (s *CommandStreamContext) SHR() antlr.TerminalNode {
	return s.GetToken(huloParserSHR, 0)
}

func (s *CommandStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandStreamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandStreamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCommandStream(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CommandStream() (localctx ICommandStreamContext) {
	localctx = NewCommandStreamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, huloParserRULE_commandStream)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&8388803) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(831)
		p.CommandExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommandAccessPointContext is an interface to support dynamic dispatch.
type ICommandAccessPointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	CommandAccessPoint() ICommandAccessPointContext
	DOUBLE_COLON() antlr.TerminalNode

	// IsCommandAccessPointContext differentiates from other interfaces.
	IsCommandAccessPointContext()
}

type CommandAccessPointContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandAccessPointContext() *CommandAccessPointContext {
	var p = new(CommandAccessPointContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandAccessPoint
	return p
}

func InitEmptyCommandAccessPointContext(p *CommandAccessPointContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_commandAccessPoint
}

func (*CommandAccessPointContext) IsCommandAccessPointContext() {}

func NewCommandAccessPointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandAccessPointContext {
	var p = new(CommandAccessPointContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_commandAccessPoint

	return p
}

func (s *CommandAccessPointContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandAccessPointContext) DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOT, 0)
}

func (s *CommandAccessPointContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *CommandAccessPointContext) CommandAccessPoint() ICommandAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommandAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommandAccessPointContext)
}

func (s *CommandAccessPointContext) DOUBLE_COLON() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_COLON, 0)
}

func (s *CommandAccessPointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandAccessPointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandAccessPointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCommandAccessPoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CommandAccessPoint() (localctx ICommandAccessPointContext) {
	localctx = NewCommandAccessPointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, huloParserRULE_commandAccessPoint)
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(833)
			p.Match(huloParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(834)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(835)
				p.CommandAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case huloParserDOUBLE_COLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(838)
			p.Match(huloParserDOUBLE_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(839)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(841)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(840)
				p.CommandAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverParametersContext is an interface to support dynamic dispatch.
type IReceiverParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverParameterList() IReceiverParameterListContext
	NamedParameters() INamedParametersContext
	COMMA() antlr.TerminalNode

	// IsReceiverParametersContext differentiates from other interfaces.
	IsReceiverParametersContext()
}

type ReceiverParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParametersContext() *ReceiverParametersContext {
	var p = new(ReceiverParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverParameters
	return p
}

func InitEmptyReceiverParametersContext(p *ReceiverParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverParameters
}

func (*ReceiverParametersContext) IsReceiverParametersContext() {}

func NewReceiverParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParametersContext {
	var p = new(ReceiverParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_receiverParameters

	return p
}

func (s *ReceiverParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *ReceiverParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *ReceiverParametersContext) ReceiverParameterList() IReceiverParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterListContext)
}

func (s *ReceiverParametersContext) NamedParameters() INamedParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedParametersContext)
}

func (s *ReceiverParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, 0)
}

func (s *ReceiverParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitReceiverParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ReceiverParameters() (localctx IReceiverParametersContext) {
	localctx = NewReceiverParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, huloParserRULE_receiverParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&60129542145) != 0 {
			{
				p.SetState(846)
				p.ReceiverParameterList()
			}

		}

	case 2:
		{
			p.SetState(849)
			p.ReceiverParameterList()
		}
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOMMA {
			{
				p.SetState(850)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(851)
				p.NamedParameters()
			}

		}

	case 3:
		{
			p.SetState(854)
			p.NamedParameters()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(857)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverParameterListContext is an interface to support dynamic dispatch.
type IReceiverParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReceiverParameter() []IReceiverParameterContext
	ReceiverParameter(i int) IReceiverParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReceiverParameterListContext differentiates from other interfaces.
	IsReceiverParameterListContext()
}

type ReceiverParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParameterListContext() *ReceiverParameterListContext {
	var p = new(ReceiverParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverParameterList
	return p
}

func InitEmptyReceiverParameterListContext(p *ReceiverParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverParameterList
}

func (*ReceiverParameterListContext) IsReceiverParameterListContext() {}

func NewReceiverParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParameterListContext {
	var p = new(ReceiverParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_receiverParameterList

	return p
}

func (s *ReceiverParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParameterListContext) AllReceiverParameter() []IReceiverParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			len++
		}
	}

	tst := make([]IReceiverParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReceiverParameterContext); ok {
			tst[i] = t.(IReceiverParameterContext)
			i++
		}
	}

	return tst
}

func (s *ReceiverParameterListContext) ReceiverParameter(i int) IReceiverParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *ReceiverParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ReceiverParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ReceiverParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitReceiverParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ReceiverParameterList() (localctx IReceiverParameterListContext) {
	localctx = NewReceiverParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, huloParserRULE_receiverParameterList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.ReceiverParameter()
	}
	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(860)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(861)
				p.ReceiverParameter()
			}

		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReceiverParameterContext is an interface to support dynamic dispatch.
type IReceiverParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AllComment() []ICommentContext
	Comment(i int) ICommentContext
	ELLIPSIS() antlr.TerminalNode
	QUEST() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsReceiverParameterContext differentiates from other interfaces.
	IsReceiverParameterContext()
}

type ReceiverParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiverParameterContext() *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverParameter
	return p
}

func InitEmptyReceiverParameterContext(p *ReceiverParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_receiverParameter
}

func (*ReceiverParameterContext) IsReceiverParameterContext() {}

func NewReceiverParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiverParameterContext {
	var p = new(ReceiverParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_receiverParameter

	return p
}

func (s *ReceiverParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiverParameterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ReceiverParameterContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *ReceiverParameterContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ReceiverParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(huloParserELLIPSIS, 0)
}

func (s *ReceiverParameterContext) QUEST() antlr.TerminalNode {
	return s.GetToken(huloParserQUEST, 0)
}

func (s *ReceiverParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *ReceiverParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ReceiverParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *ReceiverParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReceiverParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiverParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiverParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitReceiverParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ReceiverParameter() (localctx IReceiverParameterContext) {
	localctx = NewReceiverParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, huloParserRULE_receiverParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserLineComment || _la == huloParserBlockComment {
		{
			p.SetState(867)
			p.Comment()
		}

		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserELLIPSIS {
		{
			p.SetState(873)
			p.Match(huloParserELLIPSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(876)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserQUEST {
		{
			p.SetState(877)
			p.Match(huloParserQUEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCOLON {
		{
			p.SetState(880)
			p.Match(huloParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(881)
			p.Type_()
		}

	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserASSIGN {
		{
			p.SetState(884)
			p.Match(huloParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(885)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedParametersContext is an interface to support dynamic dispatch.
type INamedParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	NamedParameterList() INamedParameterListContext

	// IsNamedParametersContext differentiates from other interfaces.
	IsNamedParametersContext()
}

type NamedParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedParametersContext() *NamedParametersContext {
	var p = new(NamedParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedParameters
	return p
}

func InitEmptyNamedParametersContext(p *NamedParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedParameters
}

func (*NamedParametersContext) IsNamedParametersContext() {}

func NewNamedParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedParametersContext {
	var p = new(NamedParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_namedParameters

	return p
}

func (s *NamedParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedParametersContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *NamedParametersContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *NamedParametersContext) NamedParameterList() INamedParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedParameterListContext)
}

func (s *NamedParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNamedParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NamedParameters() (localctx INamedParametersContext) {
	localctx = NewNamedParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, huloParserRULE_namedParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserREQUIRED || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&60129542145) != 0) {
		{
			p.SetState(889)
			p.NamedParameterList()
		}

	}
	{
		p.SetState(892)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedParameterListContext is an interface to support dynamic dispatch.
type INamedParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedParameter() []INamedParameterContext
	NamedParameter(i int) INamedParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedParameterListContext differentiates from other interfaces.
	IsNamedParameterListContext()
}

type NamedParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedParameterListContext() *NamedParameterListContext {
	var p = new(NamedParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedParameterList
	return p
}

func InitEmptyNamedParameterListContext(p *NamedParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedParameterList
}

func (*NamedParameterListContext) IsNamedParameterListContext() {}

func NewNamedParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedParameterListContext {
	var p = new(NamedParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_namedParameterList

	return p
}

func (s *NamedParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedParameterListContext) AllNamedParameter() []INamedParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedParameterContext); ok {
			len++
		}
	}

	tst := make([]INamedParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedParameterContext); ok {
			tst[i] = t.(INamedParameterContext)
			i++
		}
	}

	return tst
}

func (s *NamedParameterListContext) NamedParameter(i int) INamedParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedParameterContext)
}

func (s *NamedParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *NamedParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *NamedParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNamedParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NamedParameterList() (localctx INamedParameterListContext) {
	localctx = NewNamedParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, huloParserRULE_namedParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(894)
		p.NamedParameter()
	}
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(895)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(896)
			p.NamedParameter()
		}

		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedParameterContext is an interface to support dynamic dispatch.
type INamedParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReceiverParameter() IReceiverParameterContext
	REQUIRED() antlr.TerminalNode

	// IsNamedParameterContext differentiates from other interfaces.
	IsNamedParameterContext()
}

type NamedParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedParameterContext() *NamedParameterContext {
	var p = new(NamedParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedParameter
	return p
}

func InitEmptyNamedParameterContext(p *NamedParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_namedParameter
}

func (*NamedParameterContext) IsNamedParameterContext() {}

func NewNamedParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedParameterContext {
	var p = new(NamedParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_namedParameter

	return p
}

func (s *NamedParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedParameterContext) ReceiverParameter() IReceiverParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *NamedParameterContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(huloParserREQUIRED, 0)
}

func (s *NamedParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNamedParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NamedParameter() (localctx INamedParameterContext) {
	localctx = NewNamedParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, huloParserRULE_namedParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserREQUIRED {
		{
			p.SetState(902)
			p.Match(huloParserREQUIRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(905)
		p.ReceiverParameter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(huloParserRETURN, 0)
}

func (s *ReturnStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, huloParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.Match(huloParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(909)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(908)
			p.ExpressionList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StandardFunctionDeclaration() IStandardFunctionDeclarationContext
	LambdaFunctionDeclaration() ILambdaFunctionDeclarationContext
	FunctionSignature() IFunctionSignatureContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) StandardFunctionDeclaration() IStandardFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFunctionDeclarationContext)
}

func (s *FunctionDeclarationContext) LambdaFunctionDeclaration() ILambdaFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionDeclarationContext)
}

func (s *FunctionDeclarationContext) FunctionSignature() IFunctionSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSignatureContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, huloParserRULE_functionDeclaration)
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(911)
			p.StandardFunctionDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(912)
			p.LambdaFunctionDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(913)
			p.FunctionSignature()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorIdentifierContext is an interface to support dynamic dispatch.
type IOperatorIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPERATOR() antlr.TerminalNode
	ADD() antlr.TerminalNode
	SUB() antlr.TerminalNode
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode
	MOD() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	SHL() antlr.TerminalNode
	SHR() antlr.TerminalNode
	HASH() antlr.TerminalNode
	NEW() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode

	// IsOperatorIdentifierContext differentiates from other interfaces.
	IsOperatorIdentifierContext()
}

type OperatorIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorIdentifierContext() *OperatorIdentifierContext {
	var p = new(OperatorIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_operatorIdentifier
	return p
}

func InitEmptyOperatorIdentifierContext(p *OperatorIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_operatorIdentifier
}

func (*OperatorIdentifierContext) IsOperatorIdentifierContext() {}

func NewOperatorIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorIdentifierContext {
	var p = new(OperatorIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_operatorIdentifier

	return p
}

func (s *OperatorIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorIdentifierContext) OPERATOR() antlr.TerminalNode {
	return s.GetToken(huloParserOPERATOR, 0)
}

func (s *OperatorIdentifierContext) ADD() antlr.TerminalNode {
	return s.GetToken(huloParserADD, 0)
}

func (s *OperatorIdentifierContext) SUB() antlr.TerminalNode {
	return s.GetToken(huloParserSUB, 0)
}

func (s *OperatorIdentifierContext) MUL() antlr.TerminalNode {
	return s.GetToken(huloParserMUL, 0)
}

func (s *OperatorIdentifierContext) DIV() antlr.TerminalNode {
	return s.GetToken(huloParserDIV, 0)
}

func (s *OperatorIdentifierContext) MOD() antlr.TerminalNode {
	return s.GetToken(huloParserMOD, 0)
}

func (s *OperatorIdentifierContext) LT() antlr.TerminalNode {
	return s.GetToken(huloParserLT, 0)
}

func (s *OperatorIdentifierContext) GT() antlr.TerminalNode {
	return s.GetToken(huloParserGT, 0)
}

func (s *OperatorIdentifierContext) SHL() antlr.TerminalNode {
	return s.GetToken(huloParserSHL, 0)
}

func (s *OperatorIdentifierContext) SHR() antlr.TerminalNode {
	return s.GetToken(huloParserSHR, 0)
}

func (s *OperatorIdentifierContext) HASH() antlr.TerminalNode {
	return s.GetToken(huloParserHASH, 0)
}

func (s *OperatorIdentifierContext) NEW() antlr.TerminalNode {
	return s.GetToken(huloParserNEW, 0)
}

func (s *OperatorIdentifierContext) DELETE() antlr.TerminalNode {
	return s.GetToken(huloParserDELETE, 0)
}

func (s *OperatorIdentifierContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACK, 0)
}

func (s *OperatorIdentifierContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACK, 0)
}

func (s *OperatorIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitOperatorIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) OperatorIdentifier() (localctx IOperatorIdentifierContext) {
	localctx = NewOperatorIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, huloParserRULE_operatorIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.Match(huloParserOPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserADD:
		{
			p.SetState(917)
			p.Match(huloParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserSUB:
		{
			p.SetState(918)
			p.Match(huloParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserMUL:
		{
			p.SetState(919)
			p.Match(huloParserMUL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserDIV:
		{
			p.SetState(920)
			p.Match(huloParserDIV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserMOD:
		{
			p.SetState(921)
			p.Match(huloParserMOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserLT:
		{
			p.SetState(922)
			p.Match(huloParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserGT:
		{
			p.SetState(923)
			p.Match(huloParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserSHL:
		{
			p.SetState(924)
			p.Match(huloParserSHL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserSHR:
		{
			p.SetState(925)
			p.Match(huloParserSHR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserHASH:
		{
			p.SetState(926)
			p.Match(huloParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserNEW:
		{
			p.SetState(927)
			p.Match(huloParserNEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserDELETE:
		{
			p.SetState(928)
			p.Match(huloParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserLBRACK:
		{
			p.SetState(929)
			p.Match(huloParserLBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.Match(huloParserRBRACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardFunctionDeclarationContext is an interface to support dynamic dispatch.
type IStandardFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	ReceiverParameters() IReceiverParametersContext
	Block() IBlockContext
	Identifier() antlr.TerminalNode
	OperatorIdentifier() IOperatorIdentifierContext
	AllFunctionModifier() []IFunctionModifierContext
	FunctionModifier(i int) IFunctionModifierContext
	GenericParameters() IGenericParametersContext
	THROWS() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	FunctionReturnValue() IFunctionReturnValueContext

	// IsStandardFunctionDeclarationContext differentiates from other interfaces.
	IsStandardFunctionDeclarationContext()
}

type StandardFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardFunctionDeclarationContext() *StandardFunctionDeclarationContext {
	var p = new(StandardFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_standardFunctionDeclaration
	return p
}

func InitEmptyStandardFunctionDeclarationContext(p *StandardFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_standardFunctionDeclaration
}

func (*StandardFunctionDeclarationContext) IsStandardFunctionDeclarationContext() {}

func NewStandardFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardFunctionDeclarationContext {
	var p = new(StandardFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_standardFunctionDeclaration

	return p
}

func (s *StandardFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardFunctionDeclarationContext) FN() antlr.TerminalNode {
	return s.GetToken(huloParserFN, 0)
}

func (s *StandardFunctionDeclarationContext) ReceiverParameters() IReceiverParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParametersContext)
}

func (s *StandardFunctionDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StandardFunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *StandardFunctionDeclarationContext) OperatorIdentifier() IOperatorIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorIdentifierContext)
}

func (s *StandardFunctionDeclarationContext) AllFunctionModifier() []IFunctionModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			len++
		}
	}

	tst := make([]IFunctionModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionModifierContext); ok {
			tst[i] = t.(IFunctionModifierContext)
			i++
		}
	}

	return tst
}

func (s *StandardFunctionDeclarationContext) FunctionModifier(i int) IFunctionModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *StandardFunctionDeclarationContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *StandardFunctionDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(huloParserTHROWS, 0)
}

func (s *StandardFunctionDeclarationContext) ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserARROW, 0)
}

func (s *StandardFunctionDeclarationContext) FunctionReturnValue() IFunctionReturnValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionReturnValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionReturnValueContext)
}

func (s *StandardFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitStandardFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) StandardFunctionDeclaration() (localctx IStandardFunctionDeclarationContext) {
	localctx = NewStandardFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, huloParserRULE_standardFunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserPUB || _la == huloParserCOMPTIME {
		{
			p.SetState(933)
			p.FunctionModifier()
		}

		p.SetState(938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(939)
		p.Match(huloParserFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserIdentifier:
		{
			p.SetState(940)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserOPERATOR:
		{
			p.SetState(941)
			p.OperatorIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(944)
			p.GenericParameters()
		}

	}
	{
		p.SetState(947)
		p.ReceiverParameters()
	}
	p.SetState(949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserTHROWS {
		{
			p.SetState(948)
			p.Match(huloParserTHROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserARROW {
		{
			p.SetState(951)
			p.Match(huloParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(952)
			p.FunctionReturnValue()
		}

	}
	{
		p.SetState(955)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionReturnValueContext is an interface to support dynamic dispatch.
type IFunctionReturnValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	LPAREN() antlr.TerminalNode
	TypeList() ITypeListContext
	RPAREN() antlr.TerminalNode

	// IsFunctionReturnValueContext differentiates from other interfaces.
	IsFunctionReturnValueContext()
}

type FunctionReturnValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionReturnValueContext() *FunctionReturnValueContext {
	var p = new(FunctionReturnValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionReturnValue
	return p
}

func InitEmptyFunctionReturnValueContext(p *FunctionReturnValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionReturnValue
}

func (*FunctionReturnValueContext) IsFunctionReturnValueContext() {}

func NewFunctionReturnValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionReturnValueContext {
	var p = new(FunctionReturnValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_functionReturnValue

	return p
}

func (s *FunctionReturnValueContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionReturnValueContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *FunctionReturnValueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *FunctionReturnValueContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *FunctionReturnValueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *FunctionReturnValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionReturnValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionReturnValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFunctionReturnValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FunctionReturnValue() (localctx IFunctionReturnValueContext) {
	localctx = NewFunctionReturnValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, huloParserRULE_functionReturnValue)
	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(957)
			p.Type_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(958)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.TypeList()
		}
		{
			p.SetState(960)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaFunctionDeclarationContext is an interface to support dynamic dispatch.
type ILambdaFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LambdaExpression() ILambdaExpressionContext
	Identifier() antlr.TerminalNode
	OperatorIdentifier() IOperatorIdentifierContext
	AllFunctionModifier() []IFunctionModifierContext
	FunctionModifier(i int) IFunctionModifierContext
	GenericParameters() IGenericParametersContext

	// IsLambdaFunctionDeclarationContext differentiates from other interfaces.
	IsLambdaFunctionDeclarationContext()
}

type LambdaFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionDeclarationContext() *LambdaFunctionDeclarationContext {
	var p = new(LambdaFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaFunctionDeclaration
	return p
}

func InitEmptyLambdaFunctionDeclarationContext(p *LambdaFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaFunctionDeclaration
}

func (*LambdaFunctionDeclarationContext) IsLambdaFunctionDeclarationContext() {}

func NewLambdaFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionDeclarationContext {
	var p = new(LambdaFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_lambdaFunctionDeclaration

	return p
}

func (s *LambdaFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionDeclarationContext) FN() antlr.TerminalNode {
	return s.GetToken(huloParserFN, 0)
}

func (s *LambdaFunctionDeclarationContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *LambdaFunctionDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *LambdaFunctionDeclarationContext) OperatorIdentifier() IOperatorIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorIdentifierContext)
}

func (s *LambdaFunctionDeclarationContext) AllFunctionModifier() []IFunctionModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			len++
		}
	}

	tst := make([]IFunctionModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionModifierContext); ok {
			tst[i] = t.(IFunctionModifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaFunctionDeclarationContext) FunctionModifier(i int) IFunctionModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *LambdaFunctionDeclarationContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *LambdaFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLambdaFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LambdaFunctionDeclaration() (localctx ILambdaFunctionDeclarationContext) {
	localctx = NewLambdaFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, huloParserRULE_lambdaFunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserPUB || _la == huloParserCOMPTIME {
		{
			p.SetState(964)
			p.FunctionModifier()
		}

		p.SetState(969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(970)
		p.Match(huloParserFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserIdentifier:
		{
			p.SetState(971)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserOPERATOR:
		{
			p.SetState(972)
			p.OperatorIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(975)
			p.GenericParameters()
		}

	}
	{
		p.SetState(978)
		p.LambdaExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReceiverParameters() IReceiverParametersContext
	DOUBLE_ARROW() antlr.TerminalNode
	LambdaBody() ILambdaBodyContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) ReceiverParameters() IReceiverParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParametersContext)
}

func (s *LambdaExpressionContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_ARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, huloParserRULE_lambdaExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.ReceiverParameters()
	}
	{
		p.SetState(981)
		p.Match(huloParserDOUBLE_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(982)
		p.LambdaBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RBRACE() antlr.TerminalNode
	Block() IBlockContext

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaBody
	return p
}

func InitEmptyLambdaBodyContext(p *LambdaBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_lambdaBody
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *LambdaBodyContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *LambdaBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *LambdaBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLambdaBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LambdaBody() (localctx ILambdaBodyContext) {
	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, huloParserRULE_lambdaBody)
	p.SetState(990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(984)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(985)
			p.Match(huloParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(986)
			p.ExpressionList()
		}
		{
			p.SetState(987)
			p.Match(huloParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(989)
			p.Block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionSignatureContext is an interface to support dynamic dispatch.
type IFunctionSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	ReceiverParameters() IReceiverParametersContext
	Identifier() antlr.TerminalNode
	OperatorIdentifier() IOperatorIdentifierContext
	AllFunctionModifier() []IFunctionModifierContext
	FunctionModifier(i int) IFunctionModifierContext
	GenericParameters() IGenericParametersContext
	THROWS() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	FunctionReturnValue() IFunctionReturnValueContext

	// IsFunctionSignatureContext differentiates from other interfaces.
	IsFunctionSignatureContext()
}

type FunctionSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSignatureContext() *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionSignature
	return p
}

func InitEmptyFunctionSignatureContext(p *FunctionSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionSignature
}

func (*FunctionSignatureContext) IsFunctionSignatureContext() {}

func NewFunctionSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSignatureContext {
	var p = new(FunctionSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_functionSignature

	return p
}

func (s *FunctionSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(huloParserFN, 0)
}

func (s *FunctionSignatureContext) ReceiverParameters() IReceiverParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParametersContext)
}

func (s *FunctionSignatureContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *FunctionSignatureContext) OperatorIdentifier() IOperatorIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorIdentifierContext)
}

func (s *FunctionSignatureContext) AllFunctionModifier() []IFunctionModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			len++
		}
	}

	tst := make([]IFunctionModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionModifierContext); ok {
			tst[i] = t.(IFunctionModifierContext)
			i++
		}
	}

	return tst
}

func (s *FunctionSignatureContext) FunctionModifier(i int) IFunctionModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionModifierContext)
}

func (s *FunctionSignatureContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *FunctionSignatureContext) THROWS() antlr.TerminalNode {
	return s.GetToken(huloParserTHROWS, 0)
}

func (s *FunctionSignatureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserARROW, 0)
}

func (s *FunctionSignatureContext) FunctionReturnValue() IFunctionReturnValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionReturnValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionReturnValueContext)
}

func (s *FunctionSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFunctionSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FunctionSignature() (localctx IFunctionSignatureContext) {
	localctx = NewFunctionSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, huloParserRULE_functionSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserPUB || _la == huloParserCOMPTIME {
		{
			p.SetState(992)
			p.FunctionModifier()
		}

		p.SetState(997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(998)
		p.Match(huloParserFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserIdentifier:
		{
			p.SetState(999)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserOPERATOR:
		{
			p.SetState(1000)
			p.OperatorIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(1003)
			p.GenericParameters()
		}

	}
	{
		p.SetState(1006)
		p.ReceiverParameters()
	}
	p.SetState(1008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserTHROWS {
		{
			p.SetState(1007)
			p.Match(huloParserTHROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserARROW {
		{
			p.SetState(1010)
			p.Match(huloParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1011)
			p.FunctionReturnValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionModifierContext is an interface to support dynamic dispatch.
type IFunctionModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	COMPTIME() antlr.TerminalNode

	// IsFunctionModifierContext differentiates from other interfaces.
	IsFunctionModifierContext()
}

type FunctionModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionModifierContext() *FunctionModifierContext {
	var p = new(FunctionModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionModifier
	return p
}

func InitEmptyFunctionModifierContext(p *FunctionModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionModifier
}

func (*FunctionModifierContext) IsFunctionModifierContext() {}

func NewFunctionModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionModifierContext {
	var p = new(FunctionModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_functionModifier

	return p
}

func (s *FunctionModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *FunctionModifierContext) COMPTIME() antlr.TerminalNode {
	return s.GetToken(huloParserCOMPTIME, 0)
}

func (s *FunctionModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFunctionModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FunctionModifier() (localctx IFunctionModifierContext) {
	localctx = NewFunctionModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, huloParserRULE_functionModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1014)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserPUB || _la == huloParserCOMPTIME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMacroStatementContext is an interface to support dynamic dispatch.
type IMacroStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	MemberAccess() IMemberAccessContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverArgumentList() IReceiverArgumentListContext

	// IsMacroStatementContext differentiates from other interfaces.
	IsMacroStatementContext()
}

type MacroStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMacroStatementContext() *MacroStatementContext {
	var p = new(MacroStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_macroStatement
	return p
}

func InitEmptyMacroStatementContext(p *MacroStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_macroStatement
}

func (*MacroStatementContext) IsMacroStatementContext() {}

func NewMacroStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MacroStatementContext {
	var p = new(MacroStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_macroStatement

	return p
}

func (s *MacroStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MacroStatementContext) AT() antlr.TerminalNode {
	return s.GetToken(huloParserAT, 0)
}

func (s *MacroStatementContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *MacroStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *MacroStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *MacroStatementContext) ReceiverArgumentList() IReceiverArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverArgumentListContext)
}

func (s *MacroStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MacroStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MacroStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMacroStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MacroStatement() (localctx IMacroStatementContext) {
	localctx = NewMacroStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, huloParserRULE_macroStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1016)
		p.Match(huloParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1017)
		p.MemberAccess()
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1018)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1020)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
			{
				p.SetState(1019)
				p.ReceiverArgumentList()
			}

		}
		{
			p.SetState(1022)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	ClassBody() IClassBodyContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	AllClassModifier() []IClassModifierContext
	ClassModifier(i int) IClassModifierContext
	GenericParameters() IGenericParametersContext
	COLON() antlr.TerminalNode
	ClassSuper() IClassSuperContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(huloParserCLASS, 0)
}

func (s *ClassDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *ClassDeclarationContext) AllClassModifier() []IClassModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassModifierContext); ok {
			tst[i] = t.(IClassModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassModifier(i int) IClassModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassModifierContext)
}

func (s *ClassDeclarationContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *ClassDeclarationContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *ClassDeclarationContext) ClassSuper() IClassSuperContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassSuperContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassSuperContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, huloParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1025)
			p.MacroStatement()
		}

		p.SetState(1030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserPUB {
		{
			p.SetState(1031)
			p.ClassModifier()
		}

		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1037)
		p.Match(huloParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1038)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(1039)
			p.GenericParameters()
		}

	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCOLON {
		{
			p.SetState(1042)
			p.Match(huloParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.ClassSuper()
		}

	}
	{
		p.SetState(1046)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassModifierContext is an interface to support dynamic dispatch.
type IClassModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode

	// IsClassModifierContext differentiates from other interfaces.
	IsClassModifierContext()
}

type ClassModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassModifierContext() *ClassModifierContext {
	var p = new(ClassModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classModifier
	return p
}

func InitEmptyClassModifierContext(p *ClassModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classModifier
}

func (*ClassModifierContext) IsClassModifierContext() {}

func NewClassModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassModifierContext {
	var p = new(ClassModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classModifier

	return p
}

func (s *ClassModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *ClassModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassModifier() (localctx IClassModifierContext) {
	localctx = NewClassModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, huloParserRULE_classModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Match(huloParserPUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassSuperContext is an interface to support dynamic dispatch.
type IClassSuperContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMemberAccess() []IMemberAccessContext
	MemberAccess(i int) IMemberAccessContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClassSuperContext differentiates from other interfaces.
	IsClassSuperContext()
}

type ClassSuperContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassSuperContext() *ClassSuperContext {
	var p = new(ClassSuperContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classSuper
	return p
}

func InitEmptyClassSuperContext(p *ClassSuperContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classSuper
}

func (*ClassSuperContext) IsClassSuperContext() {}

func NewClassSuperContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassSuperContext {
	var p = new(ClassSuperContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classSuper

	return p
}

func (s *ClassSuperContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassSuperContext) AllMemberAccess() []IMemberAccessContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberAccessContext); ok {
			len++
		}
	}

	tst := make([]IMemberAccessContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberAccessContext); ok {
			tst[i] = t.(IMemberAccessContext)
			i++
		}
	}

	return tst
}

func (s *ClassSuperContext) MemberAccess(i int) IMemberAccessContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ClassSuperContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ClassSuperContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ClassSuperContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassSuperContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassSuperContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassSuper(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassSuper() (localctx IClassSuperContext) {
	localctx = NewClassSuperContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, huloParserRULE_classSuper)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		p.MemberAccess()
	}
	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1051)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1052)
			p.MemberAccess()
		}

		p.SetState(1057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllComment() []ICommentContext
	Comment(i int) ICommentContext
	AllClassMember() []IClassMemberContext
	ClassMember(i int) IClassMemberContext
	AllClassMethod() []IClassMethodContext
	ClassMethod(i int) IClassMethodContext
	AllClassBuiltinMethod() []IClassBuiltinMethodContext
	ClassBuiltinMethod(i int) IClassBuiltinMethodContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBody
	return p
}

func InitEmptyClassBodyContext(p *ClassBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBody
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ClassBodyContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ClassBodyContext) AllClassMember() []IClassMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMemberContext); ok {
			len++
		}
	}

	tst := make([]IClassMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMemberContext); ok {
			tst[i] = t.(IClassMemberContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassMember(i int) IClassMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberContext)
}

func (s *ClassBodyContext) AllClassMethod() []IClassMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMethodContext); ok {
			len++
		}
	}

	tst := make([]IClassMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMethodContext); ok {
			tst[i] = t.(IClassMethodContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassMethod(i int) IClassMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodContext)
}

func (s *ClassBodyContext) AllClassBuiltinMethod() []IClassBuiltinMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBuiltinMethodContext); ok {
			len++
		}
	}

	tst := make([]IClassBuiltinMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBuiltinMethodContext); ok {
			tst[i] = t.(IClassBuiltinMethodContext)
			i++
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBuiltinMethod(i int) IClassBuiltinMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBuiltinMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBuiltinMethodContext)
}

func (s *ClassBodyContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(huloParserSEMI)
}

func (s *ClassBodyContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, i)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, huloParserRULE_classBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1058)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223363239672283136) != 0) || ((int64((_la-120)) & ^0x3f) == 0 && ((int64(1)<<(_la-120))&7) != 0) {
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1059)
				p.Comment()
			}

		case 2:
			{
				p.SetState(1060)
				p.ClassMember()
			}

		case 3:
			{
				p.SetState(1061)
				p.ClassMethod()
			}

		case 4:
			{
				p.SetState(1062)
				p.ClassBuiltinMethod()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserSEMI {
			{
				p.SetState(1065)
				p.Match(huloParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1070)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(1075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1076)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMemberContext is an interface to support dynamic dispatch.
type IClassMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	AllClassMemberModifier() []IClassMemberModifierContext
	ClassMemberModifier(i int) IClassMemberModifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsClassMemberContext differentiates from other interfaces.
	IsClassMemberContext()
}

type ClassMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberContext() *ClassMemberContext {
	var p = new(ClassMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMember
	return p
}

func InitEmptyClassMemberContext(p *ClassMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMember
}

func (*ClassMemberContext) IsClassMemberContext() {}

func NewClassMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberContext {
	var p = new(ClassMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classMember

	return p
}

func (s *ClassMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ClassMemberContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *ClassMemberContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ClassMemberContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassMemberContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *ClassMemberContext) AllClassMemberModifier() []IClassMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMemberModifierContext); ok {
			tst[i] = t.(IClassMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassMemberContext) ClassMemberModifier(i int) IClassMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMemberModifierContext)
}

func (s *ClassMemberContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *ClassMemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassMember() (localctx IClassMemberContext) {
	localctx = NewClassMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, huloParserRULE_classMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1078)
			p.MacroStatement()
		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15728640) != 0 {
		{
			p.SetState(1084)
			p.ClassMemberModifier()
		}

		p.SetState(1089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1090)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1091)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1092)
		p.Type_()
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserASSIGN {
		{
			p.SetState(1093)
			p.Match(huloParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1094)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMemberModifierContext is an interface to support dynamic dispatch.
type IClassMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	STATIC() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsClassMemberModifierContext differentiates from other interfaces.
	IsClassMemberModifierContext()
}

type ClassMemberModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMemberModifierContext() *ClassMemberModifierContext {
	var p = new(ClassMemberModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMemberModifier
	return p
}

func InitEmptyClassMemberModifierContext(p *ClassMemberModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMemberModifier
}

func (*ClassMemberModifierContext) IsClassMemberModifierContext() {}

func NewClassMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMemberModifierContext {
	var p = new(ClassMemberModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classMemberModifier

	return p
}

func (s *ClassMemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMemberModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *ClassMemberModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(huloParserSTATIC, 0)
}

func (s *ClassMemberModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(huloParserFINAL, 0)
}

func (s *ClassMemberModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(huloParserCONST, 0)
}

func (s *ClassMemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMemberModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassMemberModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassMemberModifier() (localctx IClassMemberModifierContext) {
	localctx = NewClassMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, huloParserRULE_classMemberModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15728640) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMethodContext is an interface to support dynamic dispatch.
type IClassMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StandardFunctionDeclaration() IStandardFunctionDeclarationContext
	LambdaFunctionDeclaration() ILambdaFunctionDeclarationContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	AllClassMethodModifier() []IClassMethodModifierContext
	ClassMethodModifier(i int) IClassMethodModifierContext

	// IsClassMethodContext differentiates from other interfaces.
	IsClassMethodContext()
}

type ClassMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMethodContext() *ClassMethodContext {
	var p = new(ClassMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMethod
	return p
}

func InitEmptyClassMethodContext(p *ClassMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMethod
}

func (*ClassMethodContext) IsClassMethodContext() {}

func NewClassMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMethodContext {
	var p = new(ClassMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classMethod

	return p
}

func (s *ClassMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMethodContext) StandardFunctionDeclaration() IStandardFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFunctionDeclarationContext)
}

func (s *ClassMethodContext) LambdaFunctionDeclaration() ILambdaFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionDeclarationContext)
}

func (s *ClassMethodContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassMethodContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *ClassMethodContext) AllClassMethodModifier() []IClassMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IClassMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassMethodModifierContext); ok {
			tst[i] = t.(IClassMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *ClassMethodContext) ClassMethodModifier(i int) IClassMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassMethodModifierContext)
}

func (s *ClassMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassMethod() (localctx IClassMethodContext) {
	localctx = NewClassMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, huloParserRULE_classMethod)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1099)
			p.MacroStatement()
		}

		p.SetState(1104)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1105)
				p.ClassMethodModifier()
			}

		}
		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1111)
			p.StandardFunctionDeclaration()
		}

	case 2:
		{
			p.SetState(1112)
			p.LambdaFunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassMethodModifierContext is an interface to support dynamic dispatch.
type IClassMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	STATIC() antlr.TerminalNode

	// IsClassMethodModifierContext differentiates from other interfaces.
	IsClassMethodModifierContext()
}

type ClassMethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassMethodModifierContext() *ClassMethodModifierContext {
	var p = new(ClassMethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMethodModifier
	return p
}

func InitEmptyClassMethodModifierContext(p *ClassMethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classMethodModifier
}

func (*ClassMethodModifierContext) IsClassMethodModifierContext() {}

func NewClassMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassMethodModifierContext {
	var p = new(ClassMethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classMethodModifier

	return p
}

func (s *ClassMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassMethodModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *ClassMethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(huloParserSTATIC, 0)
}

func (s *ClassMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassMethodModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassMethodModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassMethodModifier() (localctx IClassMethodModifierContext) {
	localctx = NewClassMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, huloParserRULE_classMethodModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserSTATIC || _la == huloParserPUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBuiltinMethodContext is an interface to support dynamic dispatch.
type IClassBuiltinMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ClassBuiltinParameters() IClassBuiltinParametersContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	ClassBuiltinMethodModifier() IClassBuiltinMethodModifierContext
	Block() IBlockContext
	DOUBLE_ARROW() antlr.TerminalNode
	THROWS() antlr.TerminalNode

	// IsClassBuiltinMethodContext differentiates from other interfaces.
	IsClassBuiltinMethodContext()
}

type ClassBuiltinMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBuiltinMethodContext() *ClassBuiltinMethodContext {
	var p = new(ClassBuiltinMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBuiltinMethod
	return p
}

func InitEmptyClassBuiltinMethodContext(p *ClassBuiltinMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBuiltinMethod
}

func (*ClassBuiltinMethodContext) IsClassBuiltinMethodContext() {}

func NewClassBuiltinMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBuiltinMethodContext {
	var p = new(ClassBuiltinMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classBuiltinMethod

	return p
}

func (s *ClassBuiltinMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBuiltinMethodContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ClassBuiltinMethodContext) ClassBuiltinParameters() IClassBuiltinParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBuiltinParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBuiltinParametersContext)
}

func (s *ClassBuiltinMethodContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *ClassBuiltinMethodContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *ClassBuiltinMethodContext) ClassBuiltinMethodModifier() IClassBuiltinMethodModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBuiltinMethodModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBuiltinMethodModifierContext)
}

func (s *ClassBuiltinMethodContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBuiltinMethodContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_ARROW, 0)
}

func (s *ClassBuiltinMethodContext) THROWS() antlr.TerminalNode {
	return s.GetToken(huloParserTHROWS, 0)
}

func (s *ClassBuiltinMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBuiltinMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBuiltinMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassBuiltinMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassBuiltinMethod() (localctx IClassBuiltinMethodContext) {
	localctx = NewClassBuiltinMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, huloParserRULE_classBuiltinMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1117)
			p.MacroStatement()
		}

		p.SetState(1122)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCONST {
		{
			p.SetState(1123)
			p.ClassBuiltinMethodModifier()
		}

	}
	{
		p.SetState(1126)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1127)
		p.ClassBuiltinParameters()
	}
	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case huloParserTHROWS, huloParserLBRACE:
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserTHROWS {
			{
				p.SetState(1128)
				p.Match(huloParserTHROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1131)
			p.Block()
		}

	case huloParserDOUBLE_ARROW:
		{
			p.SetState(1132)
			p.Match(huloParserDOUBLE_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1133)
			p.Block()
		}

	case huloParserCONST, huloParserSTATIC, huloParserFINAL, huloParserPUB, huloParserFN, huloParserCOMPTIME, huloParserRBRACE, huloParserAT, huloParserSEMI, huloParserLineComment, huloParserBlockComment, huloParserIdentifier:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBuiltinMethodModifierContext is an interface to support dynamic dispatch.
type IClassBuiltinMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode

	// IsClassBuiltinMethodModifierContext differentiates from other interfaces.
	IsClassBuiltinMethodModifierContext()
}

type ClassBuiltinMethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBuiltinMethodModifierContext() *ClassBuiltinMethodModifierContext {
	var p = new(ClassBuiltinMethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBuiltinMethodModifier
	return p
}

func InitEmptyClassBuiltinMethodModifierContext(p *ClassBuiltinMethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBuiltinMethodModifier
}

func (*ClassBuiltinMethodModifierContext) IsClassBuiltinMethodModifierContext() {}

func NewClassBuiltinMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBuiltinMethodModifierContext {
	var p = new(ClassBuiltinMethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classBuiltinMethodModifier

	return p
}

func (s *ClassBuiltinMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBuiltinMethodModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(huloParserCONST, 0)
}

func (s *ClassBuiltinMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBuiltinMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBuiltinMethodModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassBuiltinMethodModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassBuiltinMethodModifier() (localctx IClassBuiltinMethodModifierContext) {
	localctx = NewClassBuiltinMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, huloParserRULE_classBuiltinMethodModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.Match(huloParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBuiltinParametersContext is an interface to support dynamic dispatch.
type IClassBuiltinParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReceiverParameterList() IReceiverParameterListContext
	ClassNamedParameters() IClassNamedParametersContext
	COMMA() antlr.TerminalNode

	// IsClassBuiltinParametersContext differentiates from other interfaces.
	IsClassBuiltinParametersContext()
}

type ClassBuiltinParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBuiltinParametersContext() *ClassBuiltinParametersContext {
	var p = new(ClassBuiltinParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBuiltinParameters
	return p
}

func InitEmptyClassBuiltinParametersContext(p *ClassBuiltinParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classBuiltinParameters
}

func (*ClassBuiltinParametersContext) IsClassBuiltinParametersContext() {}

func NewClassBuiltinParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBuiltinParametersContext {
	var p = new(ClassBuiltinParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classBuiltinParameters

	return p
}

func (s *ClassBuiltinParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBuiltinParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *ClassBuiltinParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *ClassBuiltinParametersContext) ReceiverParameterList() IReceiverParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterListContext)
}

func (s *ClassBuiltinParametersContext) ClassNamedParameters() IClassNamedParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNamedParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNamedParametersContext)
}

func (s *ClassBuiltinParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, 0)
}

func (s *ClassBuiltinParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBuiltinParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBuiltinParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassBuiltinParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassBuiltinParameters() (localctx IClassBuiltinParametersContext) {
	localctx = NewClassBuiltinParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, huloParserRULE_classBuiltinParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&60129542145) != 0 {
			{
				p.SetState(1139)
				p.ReceiverParameterList()
			}

		}

	case 2:
		{
			p.SetState(1142)
			p.ReceiverParameterList()
		}
		p.SetState(1145)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOMMA {
			{
				p.SetState(1143)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1144)
				p.ClassNamedParameters()
			}

		}

	case 3:
		{
			p.SetState(1147)
			p.ClassNamedParameters()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1150)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassNamedParametersContext is an interface to support dynamic dispatch.
type IClassNamedParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ClassNamedParameterList() IClassNamedParameterListContext

	// IsClassNamedParametersContext differentiates from other interfaces.
	IsClassNamedParametersContext()
}

type ClassNamedParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNamedParametersContext() *ClassNamedParametersContext {
	var p = new(ClassNamedParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameters
	return p
}

func InitEmptyClassNamedParametersContext(p *ClassNamedParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameters
}

func (*ClassNamedParametersContext) IsClassNamedParametersContext() {}

func NewClassNamedParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNamedParametersContext {
	var p = new(ClassNamedParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classNamedParameters

	return p
}

func (s *ClassNamedParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNamedParametersContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ClassNamedParametersContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ClassNamedParametersContext) ClassNamedParameterList() IClassNamedParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNamedParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNamedParameterListContext)
}

func (s *ClassNamedParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNamedParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNamedParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassNamedParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassNamedParameters() (localctx IClassNamedParametersContext) {
	localctx = NewClassNamedParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, huloParserRULE_classNamedParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&824650498048) != 0) || ((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&60129542145) != 0) {
		{
			p.SetState(1153)
			p.ClassNamedParameterList()
		}

	}
	{
		p.SetState(1156)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassNamedParameterListContext is an interface to support dynamic dispatch.
type IClassNamedParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClassNamedParameter() []IClassNamedParameterContext
	ClassNamedParameter(i int) IClassNamedParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsClassNamedParameterListContext differentiates from other interfaces.
	IsClassNamedParameterListContext()
}

type ClassNamedParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNamedParameterListContext() *ClassNamedParameterListContext {
	var p = new(ClassNamedParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameterList
	return p
}

func InitEmptyClassNamedParameterListContext(p *ClassNamedParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameterList
}

func (*ClassNamedParameterListContext) IsClassNamedParameterListContext() {}

func NewClassNamedParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNamedParameterListContext {
	var p = new(ClassNamedParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classNamedParameterList

	return p
}

func (s *ClassNamedParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNamedParameterListContext) AllClassNamedParameter() []IClassNamedParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassNamedParameterContext); ok {
			len++
		}
	}

	tst := make([]IClassNamedParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassNamedParameterContext); ok {
			tst[i] = t.(IClassNamedParameterContext)
			i++
		}
	}

	return tst
}

func (s *ClassNamedParameterListContext) ClassNamedParameter(i int) IClassNamedParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNamedParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNamedParameterContext)
}

func (s *ClassNamedParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ClassNamedParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ClassNamedParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNamedParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNamedParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassNamedParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassNamedParameterList() (localctx IClassNamedParameterListContext) {
	localctx = NewClassNamedParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, huloParserRULE_classNamedParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1158)
		p.ClassNamedParameter()
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1159)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1160)
			p.ClassNamedParameter()
		}

		p.SetState(1165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassNamedParameterContext is an interface to support dynamic dispatch.
type IClassNamedParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReceiverParameter() IReceiverParameterContext
	REQUIRED() antlr.TerminalNode
	ClassNamedParameterAccessPoint() IClassNamedParameterAccessPointContext
	THIS() antlr.TerminalNode
	SUPER() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsClassNamedParameterContext differentiates from other interfaces.
	IsClassNamedParameterContext()
}

type ClassNamedParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNamedParameterContext() *ClassNamedParameterContext {
	var p = new(ClassNamedParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameter
	return p
}

func InitEmptyClassNamedParameterContext(p *ClassNamedParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameter
}

func (*ClassNamedParameterContext) IsClassNamedParameterContext() {}

func NewClassNamedParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNamedParameterContext {
	var p = new(ClassNamedParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classNamedParameter

	return p
}

func (s *ClassNamedParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNamedParameterContext) ReceiverParameter() IReceiverParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterContext)
}

func (s *ClassNamedParameterContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(huloParserREQUIRED, 0)
}

func (s *ClassNamedParameterContext) ClassNamedParameterAccessPoint() IClassNamedParameterAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNamedParameterAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNamedParameterAccessPointContext)
}

func (s *ClassNamedParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(huloParserTHIS, 0)
}

func (s *ClassNamedParameterContext) SUPER() antlr.TerminalNode {
	return s.GetToken(huloParserSUPER, 0)
}

func (s *ClassNamedParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *ClassNamedParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassNamedParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNamedParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNamedParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassNamedParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassNamedParameter() (localctx IClassNamedParameterContext) {
	localctx = NewClassNamedParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, huloParserRULE_classNamedParameter)
	var _la int

	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserREQUIRED {
			{
				p.SetState(1166)
				p.Match(huloParserREQUIRED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1169)
			p.ReceiverParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserREQUIRED {
			{
				p.SetState(1170)
				p.Match(huloParserREQUIRED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1173)
			_la = p.GetTokenStream().LA(1)

			if !(_la == huloParserTHIS || _la == huloParserSUPER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1174)
			p.ClassNamedParameterAccessPoint()
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserASSIGN {
			{
				p.SetState(1175)
				p.Match(huloParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1176)
				p.Expression()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassNamedParameterAccessPointContext is an interface to support dynamic dispatch.
type IClassNamedParameterAccessPointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	ClassNamedParameterAccessPoint() IClassNamedParameterAccessPointContext

	// IsClassNamedParameterAccessPointContext differentiates from other interfaces.
	IsClassNamedParameterAccessPointContext()
}

type ClassNamedParameterAccessPointContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNamedParameterAccessPointContext() *ClassNamedParameterAccessPointContext {
	var p = new(ClassNamedParameterAccessPointContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameterAccessPoint
	return p
}

func InitEmptyClassNamedParameterAccessPointContext(p *ClassNamedParameterAccessPointContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classNamedParameterAccessPoint
}

func (*ClassNamedParameterAccessPointContext) IsClassNamedParameterAccessPointContext() {}

func NewClassNamedParameterAccessPointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNamedParameterAccessPointContext {
	var p = new(ClassNamedParameterAccessPointContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classNamedParameterAccessPoint

	return p
}

func (s *ClassNamedParameterAccessPointContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNamedParameterAccessPointContext) DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOT, 0)
}

func (s *ClassNamedParameterAccessPointContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ClassNamedParameterAccessPointContext) ClassNamedParameterAccessPoint() IClassNamedParameterAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNamedParameterAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNamedParameterAccessPointContext)
}

func (s *ClassNamedParameterAccessPointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNamedParameterAccessPointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNamedParameterAccessPointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassNamedParameterAccessPoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassNamedParameterAccessPoint() (localctx IClassNamedParameterAccessPointContext) {
	localctx = NewClassNamedParameterAccessPointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, huloParserRULE_classNamedParameterAccessPoint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1181)
		p.Match(huloParserDOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1182)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserDOT {
		{
			p.SetState(1183)
			p.ClassNamedParameterAccessPoint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassInitializeExpressionContext is an interface to support dynamic dispatch.
type IClassInitializeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	NamedArgumentList() INamedArgumentListContext
	RBRACE() antlr.TerminalNode

	// IsClassInitializeExpressionContext differentiates from other interfaces.
	IsClassInitializeExpressionContext()
}

type ClassInitializeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassInitializeExpressionContext() *ClassInitializeExpressionContext {
	var p = new(ClassInitializeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classInitializeExpression
	return p
}

func InitEmptyClassInitializeExpressionContext(p *ClassInitializeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_classInitializeExpression
}

func (*ClassInitializeExpressionContext) IsClassInitializeExpressionContext() {}

func NewClassInitializeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassInitializeExpressionContext {
	var p = new(ClassInitializeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_classInitializeExpression

	return p
}

func (s *ClassInitializeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassInitializeExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ClassInitializeExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ClassInitializeExpressionContext) NamedArgumentList() INamedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentListContext)
}

func (s *ClassInitializeExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ClassInitializeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassInitializeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassInitializeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitClassInitializeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ClassInitializeExpression() (localctx IClassInitializeExpressionContext) {
	localctx = NewClassInitializeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, huloParserRULE_classInitializeExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1186)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1187)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1188)
		p.NamedArgumentList()
	}
	{
		p.SetState(1189)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	EnumBodySimple() IEnumBodySimpleContext
	EnumBodyAssociated() IEnumBodyAssociatedContext
	EnumBodyADT() IEnumBodyADTContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	EnumModifier() IEnumModifierContext
	GenericParameters() IGenericParametersContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(huloParserENUM, 0)
}

func (s *EnumDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumDeclarationContext) EnumBodySimple() IEnumBodySimpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodySimpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodySimpleContext)
}

func (s *EnumDeclarationContext) EnumBodyAssociated() IEnumBodyAssociatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyAssociatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyAssociatedContext)
}

func (s *EnumDeclarationContext) EnumBodyADT() IEnumBodyADTContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyADTContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyADTContext)
}

func (s *EnumDeclarationContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclarationContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *EnumDeclarationContext) EnumModifier() IEnumModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumModifierContext)
}

func (s *EnumDeclarationContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, huloParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1191)
			p.MacroStatement()
		}

		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserFINAL || _la == huloParserPUB {
		{
			p.SetState(1197)
			p.EnumModifier()
		}

	}
	{
		p.SetState(1200)
		p.Match(huloParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1201)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(1202)
			p.GenericParameters()
		}

	}
	p.SetState(1208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1205)
			p.EnumBodySimple()
		}

	case 2:
		{
			p.SetState(1206)
			p.EnumBodyAssociated()
		}

	case 3:
		{
			p.SetState(1207)
			p.EnumBodyADT()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumModifierContext is an interface to support dynamic dispatch.
type IEnumModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	FINAL() antlr.TerminalNode

	// IsEnumModifierContext differentiates from other interfaces.
	IsEnumModifierContext()
}

type EnumModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumModifierContext() *EnumModifierContext {
	var p = new(EnumModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumModifier
	return p
}

func InitEmptyEnumModifierContext(p *EnumModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumModifier
}

func (*EnumModifierContext) IsEnumModifierContext() {}

func NewEnumModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumModifierContext {
	var p = new(EnumModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumModifier

	return p
}

func (s *EnumModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *EnumModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(huloParserFINAL, 0)
}

func (s *EnumModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumModifier() (localctx IEnumModifierContext) {
	localctx = NewEnumModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, huloParserRULE_enumModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1210)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserFINAL || _la == huloParserPUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodySimpleContext is an interface to support dynamic dispatch.
type IEnumBodySimpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllEnumValue() []IEnumValueContext
	EnumValue(i int) IEnumValueContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllComment() []ICommentContext
	Comment(i int) ICommentContext

	// IsEnumBodySimpleContext differentiates from other interfaces.
	IsEnumBodySimpleContext()
}

type EnumBodySimpleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodySimpleContext() *EnumBodySimpleContext {
	var p = new(EnumBodySimpleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBodySimple
	return p
}

func InitEmptyEnumBodySimpleContext(p *EnumBodySimpleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBodySimple
}

func (*EnumBodySimpleContext) IsEnumBodySimpleContext() {}

func NewEnumBodySimpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodySimpleContext {
	var p = new(EnumBodySimpleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumBodySimple

	return p
}

func (s *EnumBodySimpleContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodySimpleContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *EnumBodySimpleContext) AllEnumValue() []IEnumValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumValueContext); ok {
			tst[i] = t.(IEnumValueContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodySimpleContext) EnumValue(i int) IEnumValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumValueContext)
}

func (s *EnumBodySimpleContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *EnumBodySimpleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumBodySimpleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumBodySimpleContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodySimpleContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *EnumBodySimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodySimpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodySimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumBodySimple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumBodySimple() (localctx IEnumBodySimpleContext) {
	localctx = NewEnumBodySimpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, huloParserRULE_enumBodySimple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1212)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1213)
		p.EnumValue()
	}
	p.SetState(1224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1214)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserLineComment || _la == huloParserBlockComment {
			{
				p.SetState(1215)
				p.Comment()
			}

			p.SetState(1220)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1221)
			p.EnumValue()
		}

		p.SetState(1226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1227)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyAssociatedContext is an interface to support dynamic dispatch.
type IEnumBodyAssociatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	EnumAssociatedValues() IEnumAssociatedValuesContext
	RBRACE() antlr.TerminalNode
	EnumAssociatedFields() IEnumAssociatedFieldsContext
	EnumAssociatedConstructor() IEnumAssociatedConstructorContext
	SEMI() antlr.TerminalNode
	EnumAssociatedMethods() IEnumAssociatedMethodsContext

	// IsEnumBodyAssociatedContext differentiates from other interfaces.
	IsEnumBodyAssociatedContext()
}

type EnumBodyAssociatedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyAssociatedContext() *EnumBodyAssociatedContext {
	var p = new(EnumBodyAssociatedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBodyAssociated
	return p
}

func InitEmptyEnumBodyAssociatedContext(p *EnumBodyAssociatedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBodyAssociated
}

func (*EnumBodyAssociatedContext) IsEnumBodyAssociatedContext() {}

func NewEnumBodyAssociatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyAssociatedContext {
	var p = new(EnumBodyAssociatedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumBodyAssociated

	return p
}

func (s *EnumBodyAssociatedContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyAssociatedContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *EnumBodyAssociatedContext) EnumAssociatedValues() IEnumAssociatedValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumAssociatedValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumAssociatedValuesContext)
}

func (s *EnumBodyAssociatedContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *EnumBodyAssociatedContext) EnumAssociatedFields() IEnumAssociatedFieldsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumAssociatedFieldsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumAssociatedFieldsContext)
}

func (s *EnumBodyAssociatedContext) EnumAssociatedConstructor() IEnumAssociatedConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumAssociatedConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumAssociatedConstructorContext)
}

func (s *EnumBodyAssociatedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, 0)
}

func (s *EnumBodyAssociatedContext) EnumAssociatedMethods() IEnumAssociatedMethodsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumAssociatedMethodsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumAssociatedMethodsContext)
}

func (s *EnumBodyAssociatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyAssociatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyAssociatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumBodyAssociated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumBodyAssociated() (localctx IEnumBodyAssociatedContext) {
	localctx = NewEnumBodyAssociatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, huloParserRULE_enumBodyAssociated)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1230)
			p.EnumAssociatedFields()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1233)
			p.EnumAssociatedConstructor()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1236)
		p.EnumAssociatedValues()
	}
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserSEMI {
		{
			p.SetState(1237)
			p.Match(huloParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223363239677526016) != 0 {
		{
			p.SetState(1240)
			p.EnumAssociatedMethods()
		}

	}
	{
		p.SetState(1243)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBodyADTContext is an interface to support dynamic dispatch.
type IEnumBodyADTContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllEnumVariant() []IEnumVariantContext
	EnumVariant(i int) IEnumVariantContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	EnumMethods() IEnumMethodsContext
	AllComment() []ICommentContext
	Comment(i int) ICommentContext

	// IsEnumBodyADTContext differentiates from other interfaces.
	IsEnumBodyADTContext()
}

type EnumBodyADTContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyADTContext() *EnumBodyADTContext {
	var p = new(EnumBodyADTContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBodyADT
	return p
}

func InitEmptyEnumBodyADTContext(p *EnumBodyADTContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBodyADT
}

func (*EnumBodyADTContext) IsEnumBodyADTContext() {}

func NewEnumBodyADTContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyADTContext {
	var p = new(EnumBodyADTContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumBodyADT

	return p
}

func (s *EnumBodyADTContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyADTContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *EnumBodyADTContext) AllEnumVariant() []IEnumVariantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumVariantContext); ok {
			len++
		}
	}

	tst := make([]IEnumVariantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumVariantContext); ok {
			tst[i] = t.(IEnumVariantContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodyADTContext) EnumVariant(i int) IEnumVariantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumVariantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumVariantContext)
}

func (s *EnumBodyADTContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *EnumBodyADTContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumBodyADTContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumBodyADTContext) EnumMethods() IEnumMethodsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMethodsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMethodsContext)
}

func (s *EnumBodyADTContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *EnumBodyADTContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *EnumBodyADTContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyADTContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyADTContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumBodyADT(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumBodyADT() (localctx IEnumBodyADTContext) {
	localctx = NewEnumBodyADTContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, huloParserRULE_enumBodyADT)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1245)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1246)
		p.EnumVariant()
	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1247)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserLineComment || _la == huloParserBlockComment {
			{
				p.SetState(1248)
				p.Comment()
			}

			p.SetState(1253)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1254)
			p.EnumVariant()
		}

		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223363239677526016) != 0 {
		{
			p.SetState(1260)
			p.EnumMethods()
		}

	}
	{
		p.SetState(1263)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumValueContext is an interface to support dynamic dispatch.
type IEnumValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	Comment() ICommentContext

	// IsEnumValueContext differentiates from other interfaces.
	IsEnumValueContext()
}

type EnumValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueContext() *EnumValueContext {
	var p = new(EnumValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumValue
	return p
}

func InitEmptyEnumValueContext(p *EnumValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumValue
}

func (*EnumValueContext) IsEnumValueContext() {}

func NewEnumValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueContext {
	var p = new(EnumValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumValue

	return p
}

func (s *EnumValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumValueContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *EnumValueContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumValueContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *EnumValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumValue() (localctx IEnumValueContext) {
	localctx = NewEnumValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, huloParserRULE_enumValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1265)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserASSIGN {
		{
			p.SetState(1266)
			p.Match(huloParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1267)
			p.Expression()
		}

	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLineComment || _la == huloParserBlockComment {
		{
			p.SetState(1270)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumAssociatedFieldsContext is an interface to support dynamic dispatch.
type IEnumAssociatedFieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumAssociatedField() []IEnumAssociatedFieldContext
	EnumAssociatedField(i int) IEnumAssociatedFieldContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumAssociatedFieldsContext differentiates from other interfaces.
	IsEnumAssociatedFieldsContext()
}

type EnumAssociatedFieldsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumAssociatedFieldsContext() *EnumAssociatedFieldsContext {
	var p = new(EnumAssociatedFieldsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedFields
	return p
}

func InitEmptyEnumAssociatedFieldsContext(p *EnumAssociatedFieldsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedFields
}

func (*EnumAssociatedFieldsContext) IsEnumAssociatedFieldsContext() {}

func NewEnumAssociatedFieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumAssociatedFieldsContext {
	var p = new(EnumAssociatedFieldsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumAssociatedFields

	return p
}

func (s *EnumAssociatedFieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumAssociatedFieldsContext) AllEnumAssociatedField() []IEnumAssociatedFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumAssociatedFieldContext); ok {
			len++
		}
	}

	tst := make([]IEnumAssociatedFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumAssociatedFieldContext); ok {
			tst[i] = t.(IEnumAssociatedFieldContext)
			i++
		}
	}

	return tst
}

func (s *EnumAssociatedFieldsContext) EnumAssociatedField(i int) IEnumAssociatedFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumAssociatedFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumAssociatedFieldContext)
}

func (s *EnumAssociatedFieldsContext) SEMI() antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, 0)
}

func (s *EnumAssociatedFieldsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumAssociatedFieldsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumAssociatedFieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumAssociatedFieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumAssociatedFieldsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumAssociatedFields(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumAssociatedFields() (localctx IEnumAssociatedFieldsContext) {
	localctx = NewEnumAssociatedFieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, huloParserRULE_enumAssociatedFields)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.EnumAssociatedField()
	}
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1274)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.EnumAssociatedField()
		}

		p.SetState(1280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1281)
		p.Match(huloParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumAssociatedFieldContext is an interface to support dynamic dispatch.
type IEnumAssociatedFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllEnumFieldModifier() []IEnumFieldModifierContext
	EnumFieldModifier(i int) IEnumFieldModifierContext

	// IsEnumAssociatedFieldContext differentiates from other interfaces.
	IsEnumAssociatedFieldContext()
}

type EnumAssociatedFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumAssociatedFieldContext() *EnumAssociatedFieldContext {
	var p = new(EnumAssociatedFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedField
	return p
}

func InitEmptyEnumAssociatedFieldContext(p *EnumAssociatedFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedField
}

func (*EnumAssociatedFieldContext) IsEnumAssociatedFieldContext() {}

func NewEnumAssociatedFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumAssociatedFieldContext {
	var p = new(EnumAssociatedFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumAssociatedField

	return p
}

func (s *EnumAssociatedFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumAssociatedFieldContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumAssociatedFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *EnumAssociatedFieldContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *EnumAssociatedFieldContext) AllEnumFieldModifier() []IEnumFieldModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumFieldModifierContext); ok {
			len++
		}
	}

	tst := make([]IEnumFieldModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumFieldModifierContext); ok {
			tst[i] = t.(IEnumFieldModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnumAssociatedFieldContext) EnumFieldModifier(i int) IEnumFieldModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumFieldModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumFieldModifierContext)
}

func (s *EnumAssociatedFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumAssociatedFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumAssociatedFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumAssociatedField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumAssociatedField() (localctx IEnumAssociatedFieldContext) {
	localctx = NewEnumAssociatedFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, huloParserRULE_enumAssociatedField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCONST || _la == huloParserFINAL {
		{
			p.SetState(1283)
			p.EnumFieldModifier()
		}

		p.SetState(1288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1289)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1290)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1291)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumFieldModifierContext is an interface to support dynamic dispatch.
type IEnumFieldModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINAL() antlr.TerminalNode
	CONST() antlr.TerminalNode

	// IsEnumFieldModifierContext differentiates from other interfaces.
	IsEnumFieldModifierContext()
}

type EnumFieldModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumFieldModifierContext() *EnumFieldModifierContext {
	var p = new(EnumFieldModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumFieldModifier
	return p
}

func InitEmptyEnumFieldModifierContext(p *EnumFieldModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumFieldModifier
}

func (*EnumFieldModifierContext) IsEnumFieldModifierContext() {}

func NewEnumFieldModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumFieldModifierContext {
	var p = new(EnumFieldModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumFieldModifier

	return p
}

func (s *EnumFieldModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumFieldModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(huloParserFINAL, 0)
}

func (s *EnumFieldModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(huloParserCONST, 0)
}

func (s *EnumFieldModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumFieldModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumFieldModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumFieldModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumFieldModifier() (localctx IEnumFieldModifierContext) {
	localctx = NewEnumFieldModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, huloParserRULE_enumFieldModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1293)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserCONST || _la == huloParserFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumFieldContext is an interface to support dynamic dispatch.
type IEnumFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsEnumFieldContext differentiates from other interfaces.
	IsEnumFieldContext()
}

type EnumFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumFieldContext() *EnumFieldContext {
	var p = new(EnumFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumField
	return p
}

func InitEmptyEnumFieldContext(p *EnumFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumField
}

func (*EnumFieldContext) IsEnumFieldContext() {}

func NewEnumFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumFieldContext {
	var p = new(EnumFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumField

	return p
}

func (s *EnumFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumFieldContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *EnumFieldContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *EnumFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumField() (localctx IEnumFieldContext) {
	localctx = NewEnumFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, huloParserRULE_enumField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1295)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1296)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1297)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumAssociatedValuesContext is an interface to support dynamic dispatch.
type IEnumAssociatedValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumAssociatedValue() []IEnumAssociatedValueContext
	EnumAssociatedValue(i int) IEnumAssociatedValueContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	AllComment() []ICommentContext
	Comment(i int) ICommentContext

	// IsEnumAssociatedValuesContext differentiates from other interfaces.
	IsEnumAssociatedValuesContext()
}

type EnumAssociatedValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumAssociatedValuesContext() *EnumAssociatedValuesContext {
	var p = new(EnumAssociatedValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedValues
	return p
}

func InitEmptyEnumAssociatedValuesContext(p *EnumAssociatedValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedValues
}

func (*EnumAssociatedValuesContext) IsEnumAssociatedValuesContext() {}

func NewEnumAssociatedValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumAssociatedValuesContext {
	var p = new(EnumAssociatedValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumAssociatedValues

	return p
}

func (s *EnumAssociatedValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumAssociatedValuesContext) AllEnumAssociatedValue() []IEnumAssociatedValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumAssociatedValueContext); ok {
			len++
		}
	}

	tst := make([]IEnumAssociatedValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumAssociatedValueContext); ok {
			tst[i] = t.(IEnumAssociatedValueContext)
			i++
		}
	}

	return tst
}

func (s *EnumAssociatedValuesContext) EnumAssociatedValue(i int) IEnumAssociatedValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumAssociatedValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumAssociatedValueContext)
}

func (s *EnumAssociatedValuesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumAssociatedValuesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumAssociatedValuesContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *EnumAssociatedValuesContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *EnumAssociatedValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumAssociatedValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumAssociatedValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumAssociatedValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumAssociatedValues() (localctx IEnumAssociatedValuesContext) {
	localctx = NewEnumAssociatedValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, huloParserRULE_enumAssociatedValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1299)
		p.EnumAssociatedValue()
	}
	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1300)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1304)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserLineComment || _la == huloParserBlockComment {
			{
				p.SetState(1301)
				p.Comment()
			}

			p.SetState(1306)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1307)
			p.EnumAssociatedValue()
		}

		p.SetState(1312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumAssociatedValueContext is an interface to support dynamic dispatch.
type IEnumAssociatedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsEnumAssociatedValueContext differentiates from other interfaces.
	IsEnumAssociatedValueContext()
}

type EnumAssociatedValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumAssociatedValueContext() *EnumAssociatedValueContext {
	var p = new(EnumAssociatedValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedValue
	return p
}

func InitEmptyEnumAssociatedValueContext(p *EnumAssociatedValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedValue
}

func (*EnumAssociatedValueContext) IsEnumAssociatedValueContext() {}

func NewEnumAssociatedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumAssociatedValueContext {
	var p = new(EnumAssociatedValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumAssociatedValue

	return p
}

func (s *EnumAssociatedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumAssociatedValueContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumAssociatedValueContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *EnumAssociatedValueContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *EnumAssociatedValueContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *EnumAssociatedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumAssociatedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumAssociatedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumAssociatedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumAssociatedValue() (localctx IEnumAssociatedValueContext) {
	localctx = NewEnumAssociatedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, huloParserRULE_enumAssociatedValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1313)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1314)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
		{
			p.SetState(1315)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1318)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumAssociatedConstructorContext is an interface to support dynamic dispatch.
type IEnumAssociatedConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumConstructor() []IEnumConstructorContext
	EnumConstructor(i int) IEnumConstructorContext

	// IsEnumAssociatedConstructorContext differentiates from other interfaces.
	IsEnumAssociatedConstructorContext()
}

type EnumAssociatedConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumAssociatedConstructorContext() *EnumAssociatedConstructorContext {
	var p = new(EnumAssociatedConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedConstructor
	return p
}

func InitEmptyEnumAssociatedConstructorContext(p *EnumAssociatedConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedConstructor
}

func (*EnumAssociatedConstructorContext) IsEnumAssociatedConstructorContext() {}

func NewEnumAssociatedConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumAssociatedConstructorContext {
	var p = new(EnumAssociatedConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumAssociatedConstructor

	return p
}

func (s *EnumAssociatedConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumAssociatedConstructorContext) AllEnumConstructor() []IEnumConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstructorContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstructorContext); ok {
			tst[i] = t.(IEnumConstructorContext)
			i++
		}
	}

	return tst
}

func (s *EnumAssociatedConstructorContext) EnumConstructor(i int) IEnumConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstructorContext)
}

func (s *EnumAssociatedConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumAssociatedConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumAssociatedConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumAssociatedConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumAssociatedConstructor() (localctx IEnumAssociatedConstructorContext) {
	localctx = NewEnumAssociatedConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, huloParserRULE_enumAssociatedConstructor)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1320)
				p.EnumConstructor()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1323)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstructorContext is an interface to support dynamic dispatch.
type IEnumConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnumConstructorName() IEnumConstructorNameContext
	EnumConstructorParameters() IEnumConstructorParametersContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	EnumBuiltinMethodModifier() IEnumBuiltinMethodModifierContext
	Block() IBlockContext
	DOUBLE_ARROW() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	EnumConstructorInit() IEnumConstructorInitContext
	THROWS() antlr.TerminalNode

	// IsEnumConstructorContext differentiates from other interfaces.
	IsEnumConstructorContext()
}

type EnumConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstructorContext() *EnumConstructorContext {
	var p = new(EnumConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructor
	return p
}

func InitEmptyEnumConstructorContext(p *EnumConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructor
}

func (*EnumConstructorContext) IsEnumConstructorContext() {}

func NewEnumConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstructorContext {
	var p = new(EnumConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumConstructor

	return p
}

func (s *EnumConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstructorContext) EnumConstructorName() IEnumConstructorNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstructorNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstructorNameContext)
}

func (s *EnumConstructorContext) EnumConstructorParameters() IEnumConstructorParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstructorParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstructorParametersContext)
}

func (s *EnumConstructorContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstructorContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *EnumConstructorContext) EnumBuiltinMethodModifier() IEnumBuiltinMethodModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBuiltinMethodModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBuiltinMethodModifierContext)
}

func (s *EnumConstructorContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *EnumConstructorContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_ARROW, 0)
}

func (s *EnumConstructorContext) SEMI() antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, 0)
}

func (s *EnumConstructorContext) EnumConstructorInit() IEnumConstructorInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstructorInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstructorInitContext)
}

func (s *EnumConstructorContext) THROWS() antlr.TerminalNode {
	return s.GetToken(huloParserTHROWS, 0)
}

func (s *EnumConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumConstructor() (localctx IEnumConstructorContext) {
	localctx = NewEnumConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, huloParserRULE_enumConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1325)
			p.MacroStatement()
		}

		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCONST {
		{
			p.SetState(1331)
			p.EnumBuiltinMethodModifier()
		}

	}
	{
		p.SetState(1334)
		p.EnumConstructorName()
	}
	{
		p.SetState(1335)
		p.EnumConstructorParameters()
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
		p.SetState(1337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOLON {
			{
				p.SetState(1336)
				p.EnumConstructorInit()
			}

		}
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserTHROWS {
			{
				p.SetState(1339)
				p.Match(huloParserTHROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1342)
			p.Block()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 2 {
		p.SetState(1344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOLON {
			{
				p.SetState(1343)
				p.EnumConstructorInit()
			}

		}
		{
			p.SetState(1346)
			p.Match(huloParserDOUBLE_ARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1347)
			p.Block()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 3 {
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOLON {
			{
				p.SetState(1348)
				p.EnumConstructorInit()
			}

		}
		{
			p.SetState(1351)
			p.Match(huloParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstructorNameContext is an interface to support dynamic dispatch.
type IEnumConstructorNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []antlr.TerminalNode
	Identifier(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsEnumConstructorNameContext differentiates from other interfaces.
	IsEnumConstructorNameContext()
}

type EnumConstructorNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstructorNameContext() *EnumConstructorNameContext {
	var p = new(EnumConstructorNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorName
	return p
}

func InitEmptyEnumConstructorNameContext(p *EnumConstructorNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorName
}

func (*EnumConstructorNameContext) IsEnumConstructorNameContext() {}

func NewEnumConstructorNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstructorNameContext {
	var p = new(EnumConstructorNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumConstructorName

	return p
}

func (s *EnumConstructorNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstructorNameContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(huloParserIdentifier)
}

func (s *EnumConstructorNameContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, i)
}

func (s *EnumConstructorNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(huloParserDOT, 0)
}

func (s *EnumConstructorNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstructorNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstructorNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumConstructorName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumConstructorName() (localctx IEnumConstructorNameContext) {
	localctx = NewEnumConstructorNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, huloParserRULE_enumConstructorName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1354)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserDOT {
		{
			p.SetState(1355)
			p.Match(huloParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1356)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstructorParametersContext is an interface to support dynamic dispatch.
type IEnumConstructorParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllEnumConstructorDirectInit() []IEnumConstructorDirectInitContext
	EnumConstructorDirectInit(i int) IEnumConstructorDirectInitContext
	ReceiverParameterList() IReceiverParameterListContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumConstructorParametersContext differentiates from other interfaces.
	IsEnumConstructorParametersContext()
}

type EnumConstructorParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstructorParametersContext() *EnumConstructorParametersContext {
	var p = new(EnumConstructorParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorParameters
	return p
}

func InitEmptyEnumConstructorParametersContext(p *EnumConstructorParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorParameters
}

func (*EnumConstructorParametersContext) IsEnumConstructorParametersContext() {}

func NewEnumConstructorParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstructorParametersContext {
	var p = new(EnumConstructorParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumConstructorParameters

	return p
}

func (s *EnumConstructorParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstructorParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *EnumConstructorParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *EnumConstructorParametersContext) AllEnumConstructorDirectInit() []IEnumConstructorDirectInitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumConstructorDirectInitContext); ok {
			len++
		}
	}

	tst := make([]IEnumConstructorDirectInitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumConstructorDirectInitContext); ok {
			tst[i] = t.(IEnumConstructorDirectInitContext)
			i++
		}
	}

	return tst
}

func (s *EnumConstructorParametersContext) EnumConstructorDirectInit(i int) IEnumConstructorDirectInitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstructorDirectInitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstructorDirectInitContext)
}

func (s *EnumConstructorParametersContext) ReceiverParameterList() IReceiverParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParameterListContext)
}

func (s *EnumConstructorParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumConstructorParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumConstructorParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstructorParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstructorParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumConstructorParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumConstructorParameters() (localctx IEnumConstructorParametersContext) {
	localctx = NewEnumConstructorParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, huloParserRULE_enumConstructorParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1370)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1360)
			p.EnumConstructorDirectInit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1361)
			p.ReceiverParameterList()
		}
		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserCOMMA {
			{
				p.SetState(1362)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1363)
				p.EnumConstructorDirectInit()
			}

			p.SetState(1368)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1369)
			p.ReceiverParameterList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1372)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstructorDirectInitContext is an interface to support dynamic dispatch.
type IEnumConstructorDirectInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableExpression() IVariableExpressionContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsEnumConstructorDirectInitContext differentiates from other interfaces.
	IsEnumConstructorDirectInitContext()
}

type EnumConstructorDirectInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstructorDirectInitContext() *EnumConstructorDirectInitContext {
	var p = new(EnumConstructorDirectInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorDirectInit
	return p
}

func InitEmptyEnumConstructorDirectInitContext(p *EnumConstructorDirectInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorDirectInit
}

func (*EnumConstructorDirectInitContext) IsEnumConstructorDirectInitContext() {}

func NewEnumConstructorDirectInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstructorDirectInitContext {
	var p = new(EnumConstructorDirectInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumConstructorDirectInit

	return p
}

func (s *EnumConstructorDirectInitContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstructorDirectInitContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *EnumConstructorDirectInitContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *EnumConstructorDirectInitContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnumConstructorDirectInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstructorDirectInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstructorDirectInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumConstructorDirectInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumConstructorDirectInit() (localctx IEnumConstructorDirectInitContext) {
	localctx = NewEnumConstructorDirectInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, huloParserRULE_enumConstructorDirectInit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1374)
		p.VariableExpression()
	}
	{
		p.SetState(1375)
		p.Match(huloParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1376)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumConstructorInitContext is an interface to support dynamic dispatch.
type IEnumConstructorInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	EnumConstructorDirectInit() IEnumConstructorDirectInitContext

	// IsEnumConstructorInitContext differentiates from other interfaces.
	IsEnumConstructorInitContext()
}

type EnumConstructorInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstructorInitContext() *EnumConstructorInitContext {
	var p = new(EnumConstructorInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorInit
	return p
}

func InitEmptyEnumConstructorInitContext(p *EnumConstructorInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumConstructorInit
}

func (*EnumConstructorInitContext) IsEnumConstructorInitContext() {}

func NewEnumConstructorInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstructorInitContext {
	var p = new(EnumConstructorInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumConstructorInit

	return p
}

func (s *EnumConstructorInitContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstructorInitContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *EnumConstructorInitContext) EnumConstructorDirectInit() IEnumConstructorDirectInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumConstructorDirectInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumConstructorDirectInitContext)
}

func (s *EnumConstructorInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstructorInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstructorInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumConstructorInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumConstructorInit() (localctx IEnumConstructorInitContext) {
	localctx = NewEnumConstructorInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, huloParserRULE_enumConstructorInit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1378)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1379)
		p.EnumConstructorDirectInit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumAssociatedMethodsContext is an interface to support dynamic dispatch.
type IEnumAssociatedMethodsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumMethod() []IEnumMethodContext
	EnumMethod(i int) IEnumMethodContext

	// IsEnumAssociatedMethodsContext differentiates from other interfaces.
	IsEnumAssociatedMethodsContext()
}

type EnumAssociatedMethodsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumAssociatedMethodsContext() *EnumAssociatedMethodsContext {
	var p = new(EnumAssociatedMethodsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedMethods
	return p
}

func InitEmptyEnumAssociatedMethodsContext(p *EnumAssociatedMethodsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumAssociatedMethods
}

func (*EnumAssociatedMethodsContext) IsEnumAssociatedMethodsContext() {}

func NewEnumAssociatedMethodsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumAssociatedMethodsContext {
	var p = new(EnumAssociatedMethodsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumAssociatedMethods

	return p
}

func (s *EnumAssociatedMethodsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumAssociatedMethodsContext) AllEnumMethod() []IEnumMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMethodContext); ok {
			len++
		}
	}

	tst := make([]IEnumMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMethodContext); ok {
			tst[i] = t.(IEnumMethodContext)
			i++
		}
	}

	return tst
}

func (s *EnumAssociatedMethodsContext) EnumMethod(i int) IEnumMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMethodContext)
}

func (s *EnumAssociatedMethodsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumAssociatedMethodsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumAssociatedMethodsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumAssociatedMethods(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumAssociatedMethods() (localctx IEnumAssociatedMethodsContext) {
	localctx = NewEnumAssociatedMethodsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, huloParserRULE_enumAssociatedMethods)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223363239677526016) != 0) {
		{
			p.SetState(1381)
			p.EnumMethod()
		}

		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumVariantContext is an interface to support dynamic dispatch.
type IEnumVariantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	AllEnumField() []IEnumFieldContext
	EnumField(i int) IEnumFieldContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumVariantContext differentiates from other interfaces.
	IsEnumVariantContext()
}

type EnumVariantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumVariantContext() *EnumVariantContext {
	var p = new(EnumVariantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumVariant
	return p
}

func InitEmptyEnumVariantContext(p *EnumVariantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumVariant
}

func (*EnumVariantContext) IsEnumVariantContext() {}

func NewEnumVariantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumVariantContext {
	var p = new(EnumVariantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumVariant

	return p
}

func (s *EnumVariantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumVariantContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumVariantContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *EnumVariantContext) AllEnumField() []IEnumFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumFieldContext); ok {
			len++
		}
	}

	tst := make([]IEnumFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumFieldContext); ok {
			tst[i] = t.(IEnumFieldContext)
			i++
		}
	}

	return tst
}

func (s *EnumVariantContext) EnumField(i int) IEnumFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumFieldContext)
}

func (s *EnumVariantContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *EnumVariantContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumVariantContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumVariantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumVariantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumVariantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumVariant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumVariant() (localctx IEnumVariantContext) {
	localctx = NewEnumVariantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, huloParserRULE_enumVariant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1386)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1387)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		p.EnumField()
	}
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1389)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1390)
			p.EnumField()
		}

		p.SetState(1395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1396)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMethodsContext is an interface to support dynamic dispatch.
type IEnumMethodsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumMethod() []IEnumMethodContext
	EnumMethod(i int) IEnumMethodContext

	// IsEnumMethodsContext differentiates from other interfaces.
	IsEnumMethodsContext()
}

type EnumMethodsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMethodsContext() *EnumMethodsContext {
	var p = new(EnumMethodsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMethods
	return p
}

func InitEmptyEnumMethodsContext(p *EnumMethodsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMethods
}

func (*EnumMethodsContext) IsEnumMethodsContext() {}

func NewEnumMethodsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMethodsContext {
	var p = new(EnumMethodsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumMethods

	return p
}

func (s *EnumMethodsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMethodsContext) AllEnumMethod() []IEnumMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMethodContext); ok {
			len++
		}
	}

	tst := make([]IEnumMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMethodContext); ok {
			tst[i] = t.(IEnumMethodContext)
			i++
		}
	}

	return tst
}

func (s *EnumMethodsContext) EnumMethod(i int) IEnumMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMethodContext)
}

func (s *EnumMethodsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMethodsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMethodsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumMethods(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumMethods() (localctx IEnumMethodsContext) {
	localctx = NewEnumMethodsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, huloParserRULE_enumMethods)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223363239677526016) != 0) {
		{
			p.SetState(1398)
			p.EnumMethod()
		}

		p.SetState(1401)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMethodContext is an interface to support dynamic dispatch.
type IEnumMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StandardFunctionDeclaration() IStandardFunctionDeclarationContext
	LambdaFunctionDeclaration() ILambdaFunctionDeclarationContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	AllEnumMethodModifier() []IEnumMethodModifierContext
	EnumMethodModifier(i int) IEnumMethodModifierContext

	// IsEnumMethodContext differentiates from other interfaces.
	IsEnumMethodContext()
}

type EnumMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMethodContext() *EnumMethodContext {
	var p = new(EnumMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMethod
	return p
}

func InitEmptyEnumMethodContext(p *EnumMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMethod
}

func (*EnumMethodContext) IsEnumMethodContext() {}

func NewEnumMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMethodContext {
	var p = new(EnumMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumMethod

	return p
}

func (s *EnumMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMethodContext) StandardFunctionDeclaration() IStandardFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFunctionDeclarationContext)
}

func (s *EnumMethodContext) LambdaFunctionDeclaration() ILambdaFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionDeclarationContext)
}

func (s *EnumMethodContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *EnumMethodContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *EnumMethodContext) AllEnumMethodModifier() []IEnumMethodModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMethodModifierContext); ok {
			len++
		}
	}

	tst := make([]IEnumMethodModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMethodModifierContext); ok {
			tst[i] = t.(IEnumMethodModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnumMethodContext) EnumMethodModifier(i int) IEnumMethodModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMethodModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMethodModifierContext)
}

func (s *EnumMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumMethod() (localctx IEnumMethodContext) {
	localctx = NewEnumMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, huloParserRULE_enumMethod)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1403)
			p.MacroStatement()
		}

		p.SetState(1408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1409)
				p.EnumMethodModifier()
			}

		}
		p.SetState(1414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1415)
			p.StandardFunctionDeclaration()
		}

	case 2:
		{
			p.SetState(1416)
			p.LambdaFunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMethodModifierContext is an interface to support dynamic dispatch.
type IEnumMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	STATIC() antlr.TerminalNode

	// IsEnumMethodModifierContext differentiates from other interfaces.
	IsEnumMethodModifierContext()
}

type EnumMethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMethodModifierContext() *EnumMethodModifierContext {
	var p = new(EnumMethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMethodModifier
	return p
}

func InitEmptyEnumMethodModifierContext(p *EnumMethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMethodModifier
}

func (*EnumMethodModifierContext) IsEnumMethodModifierContext() {}

func NewEnumMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMethodModifierContext {
	var p = new(EnumMethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumMethodModifier

	return p
}

func (s *EnumMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMethodModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *EnumMethodModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(huloParserSTATIC, 0)
}

func (s *EnumMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMethodModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumMethodModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumMethodModifier() (localctx IEnumMethodModifierContext) {
	localctx = NewEnumMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, huloParserRULE_enumMethodModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1419)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserSTATIC || _la == huloParserPUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberContext is an interface to support dynamic dispatch.
type IEnumMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	AllEnumMemberModifier() []IEnumMemberModifierContext
	EnumMemberModifier(i int) IEnumMemberModifierContext

	// IsEnumMemberContext differentiates from other interfaces.
	IsEnumMemberContext()
}

type EnumMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberContext() *EnumMemberContext {
	var p = new(EnumMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMember
	return p
}

func InitEmptyEnumMemberContext(p *EnumMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMember
}

func (*EnumMemberContext) IsEnumMemberContext() {}

func NewEnumMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberContext {
	var p = new(EnumMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumMember

	return p
}

func (s *EnumMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumMemberContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *EnumMemberContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *EnumMemberContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *EnumMemberContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *EnumMemberContext) AllEnumMemberModifier() []IEnumMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]IEnumMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumMemberModifierContext); ok {
			tst[i] = t.(IEnumMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *EnumMemberContext) EnumMemberModifier(i int) IEnumMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumMemberModifierContext)
}

func (s *EnumMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumMember() (localctx IEnumMemberContext) {
	localctx = NewEnumMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, huloParserRULE_enumMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1421)
			p.MacroStatement()
		}

		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserFINAL || _la == huloParserPUB {
		{
			p.SetState(1427)
			p.EnumMemberModifier()
		}

		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1433)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1434)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1435)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumMemberModifierContext is an interface to support dynamic dispatch.
type IEnumMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	FINAL() antlr.TerminalNode

	// IsEnumMemberModifierContext differentiates from other interfaces.
	IsEnumMemberModifierContext()
}

type EnumMemberModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumMemberModifierContext() *EnumMemberModifierContext {
	var p = new(EnumMemberModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMemberModifier
	return p
}

func InitEmptyEnumMemberModifierContext(p *EnumMemberModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumMemberModifier
}

func (*EnumMemberModifierContext) IsEnumMemberModifierContext() {}

func NewEnumMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumMemberModifierContext {
	var p = new(EnumMemberModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumMemberModifier

	return p
}

func (s *EnumMemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumMemberModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *EnumMemberModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(huloParserFINAL, 0)
}

func (s *EnumMemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumMemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumMemberModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumMemberModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumMemberModifier() (localctx IEnumMemberModifierContext) {
	localctx = NewEnumMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, huloParserRULE_enumMemberModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1437)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserFINAL || _la == huloParserPUB) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumBuiltinMethodModifierContext is an interface to support dynamic dispatch.
type IEnumBuiltinMethodModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode

	// IsEnumBuiltinMethodModifierContext differentiates from other interfaces.
	IsEnumBuiltinMethodModifierContext()
}

type EnumBuiltinMethodModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBuiltinMethodModifierContext() *EnumBuiltinMethodModifierContext {
	var p = new(EnumBuiltinMethodModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBuiltinMethodModifier
	return p
}

func InitEmptyEnumBuiltinMethodModifierContext(p *EnumBuiltinMethodModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumBuiltinMethodModifier
}

func (*EnumBuiltinMethodModifierContext) IsEnumBuiltinMethodModifierContext() {}

func NewEnumBuiltinMethodModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBuiltinMethodModifierContext {
	var p = new(EnumBuiltinMethodModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumBuiltinMethodModifier

	return p
}

func (s *EnumBuiltinMethodModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBuiltinMethodModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(huloParserCONST, 0)
}

func (s *EnumBuiltinMethodModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBuiltinMethodModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBuiltinMethodModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumBuiltinMethodModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumBuiltinMethodModifier() (localctx IEnumBuiltinMethodModifierContext) {
	localctx = NewEnumBuiltinMethodModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, huloParserRULE_enumBuiltinMethodModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1439)
		p.Match(huloParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumInitializeContext is an interface to support dynamic dispatch.
type IEnumInitializeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumInitializeMember() []IEnumInitializeMemberContext
	EnumInitializeMember(i int) IEnumInitializeMemberContext
	SEMI() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsEnumInitializeContext differentiates from other interfaces.
	IsEnumInitializeContext()
}

type EnumInitializeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumInitializeContext() *EnumInitializeContext {
	var p = new(EnumInitializeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumInitialize
	return p
}

func InitEmptyEnumInitializeContext(p *EnumInitializeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumInitialize
}

func (*EnumInitializeContext) IsEnumInitializeContext() {}

func NewEnumInitializeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumInitializeContext {
	var p = new(EnumInitializeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumInitialize

	return p
}

func (s *EnumInitializeContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumInitializeContext) AllEnumInitializeMember() []IEnumInitializeMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumInitializeMemberContext); ok {
			len++
		}
	}

	tst := make([]IEnumInitializeMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumInitializeMemberContext); ok {
			tst[i] = t.(IEnumInitializeMemberContext)
			i++
		}
	}

	return tst
}

func (s *EnumInitializeContext) EnumInitializeMember(i int) IEnumInitializeMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumInitializeMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumInitializeMemberContext)
}

func (s *EnumInitializeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, 0)
}

func (s *EnumInitializeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *EnumInitializeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *EnumInitializeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumInitializeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumInitializeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumInitialize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumInitialize() (localctx IEnumInitializeContext) {
	localctx = NewEnumInitializeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, huloParserRULE_enumInitialize)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1441)
				p.EnumInitializeMember()
			}
			{
				p.SetState(1442)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1449)
		p.EnumInitializeMember()
	}
	{
		p.SetState(1450)
		p.Match(huloParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumInitializeMemberContext is an interface to support dynamic dispatch.
type IEnumInitializeMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext

	// IsEnumInitializeMemberContext differentiates from other interfaces.
	IsEnumInitializeMemberContext()
}

type EnumInitializeMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumInitializeMemberContext() *EnumInitializeMemberContext {
	var p = new(EnumInitializeMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumInitializeMember
	return p
}

func InitEmptyEnumInitializeMemberContext(p *EnumInitializeMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_enumInitializeMember
}

func (*EnumInitializeMemberContext) IsEnumInitializeMemberContext() {}

func NewEnumInitializeMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumInitializeMemberContext {
	var p = new(EnumInitializeMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_enumInitializeMember

	return p
}

func (s *EnumInitializeMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumInitializeMemberContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *EnumInitializeMemberContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *EnumInitializeMemberContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *EnumInitializeMemberContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *EnumInitializeMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumInitializeMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumInitializeMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitEnumInitializeMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) EnumInitializeMember() (localctx IEnumInitializeMemberContext) {
	localctx = NewEnumInitializeMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, huloParserRULE_enumInitializeMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1452)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1453)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159771687121846273) != 0) {
		{
			p.SetState(1454)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1457)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITraitDeclarationContext is an interface to support dynamic dispatch.
type ITraitDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRAIT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	TraitBody() ITraitBodyContext
	AllMacroStatement() []IMacroStatementContext
	MacroStatement(i int) IMacroStatementContext
	TraitModifier() ITraitModifierContext
	GenericParameters() IGenericParametersContext

	// IsTraitDeclarationContext differentiates from other interfaces.
	IsTraitDeclarationContext()
}

type TraitDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitDeclarationContext() *TraitDeclarationContext {
	var p = new(TraitDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitDeclaration
	return p
}

func InitEmptyTraitDeclarationContext(p *TraitDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitDeclaration
}

func (*TraitDeclarationContext) IsTraitDeclarationContext() {}

func NewTraitDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitDeclarationContext {
	var p = new(TraitDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_traitDeclaration

	return p
}

func (s *TraitDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitDeclarationContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(huloParserTRAIT, 0)
}

func (s *TraitDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *TraitDeclarationContext) TraitBody() ITraitBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitBodyContext)
}

func (s *TraitDeclarationContext) AllMacroStatement() []IMacroStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMacroStatementContext); ok {
			len++
		}
	}

	tst := make([]IMacroStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMacroStatementContext); ok {
			tst[i] = t.(IMacroStatementContext)
			i++
		}
	}

	return tst
}

func (s *TraitDeclarationContext) MacroStatement(i int) IMacroStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMacroStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMacroStatementContext)
}

func (s *TraitDeclarationContext) TraitModifier() ITraitModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitModifierContext)
}

func (s *TraitDeclarationContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *TraitDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTraitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TraitDeclaration() (localctx ITraitDeclarationContext) {
	localctx = NewTraitDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, huloParserRULE_traitDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserAT {
		{
			p.SetState(1459)
			p.MacroStatement()
		}

		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserPUB {
		{
			p.SetState(1465)
			p.TraitModifier()
		}

	}
	{
		p.SetState(1468)
		p.Match(huloParserTRAIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1469)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(1470)
			p.GenericParameters()
		}

	}
	{
		p.SetState(1473)
		p.TraitBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITraitModifierContext is an interface to support dynamic dispatch.
type ITraitModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode

	// IsTraitModifierContext differentiates from other interfaces.
	IsTraitModifierContext()
}

type TraitModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitModifierContext() *TraitModifierContext {
	var p = new(TraitModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitModifier
	return p
}

func InitEmptyTraitModifierContext(p *TraitModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitModifier
}

func (*TraitModifierContext) IsTraitModifierContext() {}

func NewTraitModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitModifierContext {
	var p = new(TraitModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_traitModifier

	return p
}

func (s *TraitModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *TraitModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTraitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TraitModifier() (localctx ITraitModifierContext) {
	localctx = NewTraitModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, huloParserRULE_traitModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		p.Match(huloParserPUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITraitBodyContext is an interface to support dynamic dispatch.
type ITraitBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllComment() []ICommentContext
	Comment(i int) ICommentContext
	AllTraitMember() []ITraitMemberContext
	TraitMember(i int) ITraitMemberContext
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode

	// IsTraitBodyContext differentiates from other interfaces.
	IsTraitBodyContext()
}

type TraitBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitBodyContext() *TraitBodyContext {
	var p = new(TraitBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitBody
	return p
}

func InitEmptyTraitBodyContext(p *TraitBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitBody
}

func (*TraitBodyContext) IsTraitBodyContext() {}

func NewTraitBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitBodyContext {
	var p = new(TraitBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_traitBody

	return p
}

func (s *TraitBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *TraitBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *TraitBodyContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *TraitBodyContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *TraitBodyContext) AllTraitMember() []ITraitMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITraitMemberContext); ok {
			len++
		}
	}

	tst := make([]ITraitMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITraitMemberContext); ok {
			tst[i] = t.(ITraitMemberContext)
			i++
		}
	}

	return tst
}

func (s *TraitBodyContext) TraitMember(i int) ITraitMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitMemberContext)
}

func (s *TraitBodyContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(huloParserSEMI)
}

func (s *TraitBodyContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, i)
}

func (s *TraitBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTraitBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TraitBody() (localctx ITraitBodyContext) {
	localctx = NewTraitBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, huloParserRULE_traitBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2163212288) != 0) || ((int64((_la-120)) & ^0x3f) == 0 && ((int64(1)<<(_la-120))&7) != 0) {
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case huloParserLineComment, huloParserBlockComment:
			{
				p.SetState(1478)
				p.Comment()
			}

		case huloParserCONST, huloParserSTATIC, huloParserFINAL, huloParserPUB, huloParserOPERATOR, huloParserIdentifier:
			{
				p.SetState(1479)
				p.TraitMember()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserSEMI {
			{
				p.SetState(1482)
				p.Match(huloParserSEMI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(1492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1493)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITraitMemberContext is an interface to support dynamic dispatch.
type ITraitMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode
	Type_() ITypeContext
	Identifier() antlr.TerminalNode
	OperatorIdentifier() IOperatorIdentifierContext
	AllTraitMemberModifier() []ITraitMemberModifierContext
	TraitMemberModifier(i int) ITraitMemberModifierContext

	// IsTraitMemberContext differentiates from other interfaces.
	IsTraitMemberContext()
}

type TraitMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitMemberContext() *TraitMemberContext {
	var p = new(TraitMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitMember
	return p
}

func InitEmptyTraitMemberContext(p *TraitMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitMember
}

func (*TraitMemberContext) IsTraitMemberContext() {}

func NewTraitMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitMemberContext {
	var p = new(TraitMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_traitMember

	return p
}

func (s *TraitMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitMemberContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *TraitMemberContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TraitMemberContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *TraitMemberContext) OperatorIdentifier() IOperatorIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorIdentifierContext)
}

func (s *TraitMemberContext) AllTraitMemberModifier() []ITraitMemberModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITraitMemberModifierContext); ok {
			len++
		}
	}

	tst := make([]ITraitMemberModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITraitMemberModifierContext); ok {
			tst[i] = t.(ITraitMemberModifierContext)
			i++
		}
	}

	return tst
}

func (s *TraitMemberContext) TraitMemberModifier(i int) ITraitMemberModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitMemberModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitMemberModifierContext)
}

func (s *TraitMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTraitMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TraitMember() (localctx ITraitMemberContext) {
	localctx = NewTraitMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, huloParserRULE_traitMember)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15728640) != 0 {
		{
			p.SetState(1495)
			p.TraitMemberModifier()
		}

		p.SetState(1500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserIdentifier:
		{
			p.SetState(1501)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserOPERATOR:
		{
			p.SetState(1502)
			p.OperatorIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1505)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1506)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITraitMemberModifierContext is an interface to support dynamic dispatch.
type ITraitMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PUB() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	CONST() antlr.TerminalNode
	STATIC() antlr.TerminalNode

	// IsTraitMemberModifierContext differentiates from other interfaces.
	IsTraitMemberModifierContext()
}

type TraitMemberModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitMemberModifierContext() *TraitMemberModifierContext {
	var p = new(TraitMemberModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitMemberModifier
	return p
}

func InitEmptyTraitMemberModifierContext(p *TraitMemberModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_traitMemberModifier
}

func (*TraitMemberModifierContext) IsTraitMemberModifierContext() {}

func NewTraitMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitMemberModifierContext {
	var p = new(TraitMemberModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_traitMemberModifier

	return p
}

func (s *TraitMemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitMemberModifierContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *TraitMemberModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(huloParserFINAL, 0)
}

func (s *TraitMemberModifierContext) CONST() antlr.TerminalNode {
	return s.GetToken(huloParserCONST, 0)
}

func (s *TraitMemberModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(huloParserSTATIC, 0)
}

func (s *TraitMemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitMemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitMemberModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTraitMemberModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TraitMemberModifier() (localctx ITraitMemberModifierContext) {
	localctx = NewTraitMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, huloParserRULE_traitMemberModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1508)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&15728640) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplDeclarationContext is an interface to support dynamic dispatch.
type IImplDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPL() antlr.TerminalNode
	MemberAccess() IMemberAccessContext
	FOR() antlr.TerminalNode
	ImplDeclarationBody() IImplDeclarationBodyContext
	ImplDeclarationBinding() IImplDeclarationBindingContext

	// IsImplDeclarationContext differentiates from other interfaces.
	IsImplDeclarationContext()
}

type ImplDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplDeclarationContext() *ImplDeclarationContext {
	var p = new(ImplDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_implDeclaration
	return p
}

func InitEmptyImplDeclarationContext(p *ImplDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_implDeclaration
}

func (*ImplDeclarationContext) IsImplDeclarationContext() {}

func NewImplDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplDeclarationContext {
	var p = new(ImplDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_implDeclaration

	return p
}

func (s *ImplDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplDeclarationContext) IMPL() antlr.TerminalNode {
	return s.GetToken(huloParserIMPL, 0)
}

func (s *ImplDeclarationContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ImplDeclarationContext) FOR() antlr.TerminalNode {
	return s.GetToken(huloParserFOR, 0)
}

func (s *ImplDeclarationContext) ImplDeclarationBody() IImplDeclarationBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplDeclarationBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplDeclarationBodyContext)
}

func (s *ImplDeclarationContext) ImplDeclarationBinding() IImplDeclarationBindingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplDeclarationBindingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplDeclarationBindingContext)
}

func (s *ImplDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImplDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImplDeclaration() (localctx IImplDeclarationContext) {
	localctx = NewImplDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, huloParserRULE_implDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.Match(huloParserIMPL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1511)
		p.MemberAccess()
	}
	{
		p.SetState(1512)
		p.Match(huloParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1513)
			p.ImplDeclarationBody()
		}

	case 2:
		{
			p.SetState(1514)
			p.ImplDeclarationBinding()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplDeclarationBindingContext is an interface to support dynamic dispatch.
type IImplDeclarationBindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMemberAccess() []IMemberAccessContext
	MemberAccess(i int) IMemberAccessContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImplDeclarationBindingContext differentiates from other interfaces.
	IsImplDeclarationBindingContext()
}

type ImplDeclarationBindingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplDeclarationBindingContext() *ImplDeclarationBindingContext {
	var p = new(ImplDeclarationBindingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_implDeclarationBinding
	return p
}

func InitEmptyImplDeclarationBindingContext(p *ImplDeclarationBindingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_implDeclarationBinding
}

func (*ImplDeclarationBindingContext) IsImplDeclarationBindingContext() {}

func NewImplDeclarationBindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplDeclarationBindingContext {
	var p = new(ImplDeclarationBindingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_implDeclarationBinding

	return p
}

func (s *ImplDeclarationBindingContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplDeclarationBindingContext) AllMemberAccess() []IMemberAccessContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberAccessContext); ok {
			len++
		}
	}

	tst := make([]IMemberAccessContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberAccessContext); ok {
			tst[i] = t.(IMemberAccessContext)
			i++
		}
	}

	return tst
}

func (s *ImplDeclarationBindingContext) MemberAccess(i int) IMemberAccessContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ImplDeclarationBindingContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ImplDeclarationBindingContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ImplDeclarationBindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplDeclarationBindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplDeclarationBindingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImplDeclarationBinding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImplDeclarationBinding() (localctx IImplDeclarationBindingContext) {
	localctx = NewImplDeclarationBindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, huloParserRULE_implDeclarationBinding)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.MemberAccess()
	}
	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1518)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1519)
			p.MemberAccess()
		}

		p.SetState(1524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplDeclarationBodyContext is an interface to support dynamic dispatch.
type IImplDeclarationBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccess() IMemberAccessContext
	ClassBody() IClassBodyContext

	// IsImplDeclarationBodyContext differentiates from other interfaces.
	IsImplDeclarationBodyContext()
}

type ImplDeclarationBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplDeclarationBodyContext() *ImplDeclarationBodyContext {
	var p = new(ImplDeclarationBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_implDeclarationBody
	return p
}

func InitEmptyImplDeclarationBodyContext(p *ImplDeclarationBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_implDeclarationBody
}

func (*ImplDeclarationBodyContext) IsImplDeclarationBodyContext() {}

func NewImplDeclarationBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplDeclarationBodyContext {
	var p = new(ImplDeclarationBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_implDeclarationBody

	return p
}

func (s *ImplDeclarationBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplDeclarationBodyContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ImplDeclarationBodyContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ImplDeclarationBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplDeclarationBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplDeclarationBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImplDeclarationBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImplDeclarationBody() (localctx IImplDeclarationBodyContext) {
	localctx = NewImplDeclarationBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, huloParserRULE_implDeclarationBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1525)
		p.MemberAccess()
	}
	{
		p.SetState(1526)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendDeclarationContext is an interface to support dynamic dispatch.
type IExtendDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	ExtendEnum() IExtendEnumContext
	ExtendClass() IExtendClassContext
	ExtendTrait() IExtendTraitContext
	ExtendType() IExtendTypeContext
	ExtendMod() IExtendModContext

	// IsExtendDeclarationContext differentiates from other interfaces.
	IsExtendDeclarationContext()
}

type ExtendDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendDeclarationContext() *ExtendDeclarationContext {
	var p = new(ExtendDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendDeclaration
	return p
}

func InitEmptyExtendDeclarationContext(p *ExtendDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendDeclaration
}

func (*ExtendDeclarationContext) IsExtendDeclarationContext() {}

func NewExtendDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendDeclarationContext {
	var p = new(ExtendDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_extendDeclaration

	return p
}

func (s *ExtendDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendDeclarationContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(huloParserEXTEND, 0)
}

func (s *ExtendDeclarationContext) ExtendEnum() IExtendEnumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendEnumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendEnumContext)
}

func (s *ExtendDeclarationContext) ExtendClass() IExtendClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendClassContext)
}

func (s *ExtendDeclarationContext) ExtendTrait() IExtendTraitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendTraitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendTraitContext)
}

func (s *ExtendDeclarationContext) ExtendType() IExtendTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendTypeContext)
}

func (s *ExtendDeclarationContext) ExtendMod() IExtendModContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendModContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendModContext)
}

func (s *ExtendDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExtendDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExtendDeclaration() (localctx IExtendDeclarationContext) {
	localctx = NewExtendDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, huloParserRULE_extendDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1528)
		p.Match(huloParserEXTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserENUM:
		{
			p.SetState(1529)
			p.ExtendEnum()
		}

	case huloParserCLASS:
		{
			p.SetState(1530)
			p.ExtendClass()
		}

	case huloParserTRAIT:
		{
			p.SetState(1531)
			p.ExtendTrait()
		}

	case huloParserTYPE:
		{
			p.SetState(1532)
			p.ExtendType()
		}

	case huloParserMOD_LIT:
		{
			p.SetState(1533)
			p.ExtendMod()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendEnumContext is an interface to support dynamic dispatch.
type IExtendEnumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENUM() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	EnumBodySimple() IEnumBodySimpleContext
	EnumBodyAssociated() IEnumBodyAssociatedContext
	EnumBodyADT() IEnumBodyADTContext

	// IsExtendEnumContext differentiates from other interfaces.
	IsExtendEnumContext()
}

type ExtendEnumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendEnumContext() *ExtendEnumContext {
	var p = new(ExtendEnumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendEnum
	return p
}

func InitEmptyExtendEnumContext(p *ExtendEnumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendEnum
}

func (*ExtendEnumContext) IsExtendEnumContext() {}

func NewExtendEnumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendEnumContext {
	var p = new(ExtendEnumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_extendEnum

	return p
}

func (s *ExtendEnumContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendEnumContext) ENUM() antlr.TerminalNode {
	return s.GetToken(huloParserENUM, 0)
}

func (s *ExtendEnumContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ExtendEnumContext) EnumBodySimple() IEnumBodySimpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodySimpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodySimpleContext)
}

func (s *ExtendEnumContext) EnumBodyAssociated() IEnumBodyAssociatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyAssociatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyAssociatedContext)
}

func (s *ExtendEnumContext) EnumBodyADT() IEnumBodyADTContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumBodyADTContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumBodyADTContext)
}

func (s *ExtendEnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendEnumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendEnumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExtendEnum(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExtendEnum() (localctx IExtendEnumContext) {
	localctx = NewExtendEnumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, huloParserRULE_extendEnum)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1536)
		p.Match(huloParserENUM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1537)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1541)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1538)
			p.EnumBodySimple()
		}

	case 2:
		{
			p.SetState(1539)
			p.EnumBodyAssociated()
		}

	case 3:
		{
			p.SetState(1540)
			p.EnumBodyADT()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendClassContext is an interface to support dynamic dispatch.
type IExtendClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	ClassBody() IClassBodyContext

	// IsExtendClassContext differentiates from other interfaces.
	IsExtendClassContext()
}

type ExtendClassContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendClassContext() *ExtendClassContext {
	var p = new(ExtendClassContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendClass
	return p
}

func InitEmptyExtendClassContext(p *ExtendClassContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendClass
}

func (*ExtendClassContext) IsExtendClassContext() {}

func NewExtendClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendClassContext {
	var p = new(ExtendClassContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_extendClass

	return p
}

func (s *ExtendClassContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendClassContext) CLASS() antlr.TerminalNode {
	return s.GetToken(huloParserCLASS, 0)
}

func (s *ExtendClassContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ExtendClassContext) ClassBody() IClassBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ExtendClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExtendClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExtendClass() (localctx IExtendClassContext) {
	localctx = NewExtendClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, huloParserRULE_extendClass)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1543)
		p.Match(huloParserCLASS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1544)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1545)
		p.ClassBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendTraitContext is an interface to support dynamic dispatch.
type IExtendTraitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRAIT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	TraitBody() ITraitBodyContext

	// IsExtendTraitContext differentiates from other interfaces.
	IsExtendTraitContext()
}

type ExtendTraitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendTraitContext() *ExtendTraitContext {
	var p = new(ExtendTraitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendTrait
	return p
}

func InitEmptyExtendTraitContext(p *ExtendTraitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendTrait
}

func (*ExtendTraitContext) IsExtendTraitContext() {}

func NewExtendTraitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendTraitContext {
	var p = new(ExtendTraitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_extendTrait

	return p
}

func (s *ExtendTraitContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendTraitContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(huloParserTRAIT, 0)
}

func (s *ExtendTraitContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ExtendTraitContext) TraitBody() ITraitBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitBodyContext)
}

func (s *ExtendTraitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendTraitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendTraitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExtendTrait(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExtendTrait() (localctx IExtendTraitContext) {
	localctx = NewExtendTraitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, huloParserRULE_extendTrait)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1547)
		p.Match(huloParserTRAIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1548)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1549)
		p.TraitBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendTypeContext is an interface to support dynamic dispatch.
type IExtendTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	Type_() ITypeContext

	// IsExtendTypeContext differentiates from other interfaces.
	IsExtendTypeContext()
}

type ExtendTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendTypeContext() *ExtendTypeContext {
	var p = new(ExtendTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendType
	return p
}

func InitEmptyExtendTypeContext(p *ExtendTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendType
}

func (*ExtendTypeContext) IsExtendTypeContext() {}

func NewExtendTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendTypeContext {
	var p = new(ExtendTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_extendType

	return p
}

func (s *ExtendTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(huloParserTYPE, 0)
}

func (s *ExtendTypeContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ExtendTypeContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ExtendTypeContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ExtendTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ExtendTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExtendType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExtendType() (localctx IExtendTypeContext) {
	localctx = NewExtendTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, huloParserRULE_extendType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1551)
		p.Match(huloParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1552)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1553)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&23644722677415936) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&66495) != 0) {
		{
			p.SetState(1554)
			p.Type_()
		}

	}
	{
		p.SetState(1557)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendModContext is an interface to support dynamic dispatch.
type IExtendModContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOD_LIT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllModuleStatement() []IModuleStatementContext
	ModuleStatement(i int) IModuleStatementContext

	// IsExtendModContext differentiates from other interfaces.
	IsExtendModContext()
}

type ExtendModContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendModContext() *ExtendModContext {
	var p = new(ExtendModContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendMod
	return p
}

func InitEmptyExtendModContext(p *ExtendModContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_extendMod
}

func (*ExtendModContext) IsExtendModContext() {}

func NewExtendModContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendModContext {
	var p = new(ExtendModContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_extendMod

	return p
}

func (s *ExtendModContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendModContext) MOD_LIT() antlr.TerminalNode {
	return s.GetToken(huloParserMOD_LIT, 0)
}

func (s *ExtendModContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ExtendModContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ExtendModContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ExtendModContext) AllModuleStatement() []IModuleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleStatementContext); ok {
			len++
		}
	}

	tst := make([]IModuleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleStatementContext); ok {
			tst[i] = t.(IModuleStatementContext)
			i++
		}
	}

	return tst
}

func (s *ExtendModContext) ModuleStatement(i int) IModuleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleStatementContext)
}

func (s *ExtendModContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendModContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendModContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExtendMod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExtendMod() (localctx IExtendModContext) {
	localctx = NewExtendModContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, huloParserRULE_extendMod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1559)
		p.Match(huloParserMOD_LIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1560)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1561)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223362080032423930) != 0) || _la == huloParserDOLLAR || _la == huloParserWILDCARD {
		{
			p.SetState(1562)
			p.ModuleStatement()
		}

		p.SetState(1567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1568)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ImportAll() IImportAllContext
	ImportSingle() IImportSingleContext
	ImportMulti() IImportMultiContext

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importDeclaration
	return p
}

func InitEmptyImportDeclarationContext(p *ImportDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importDeclaration
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(huloParserIMPORT, 0)
}

func (s *ImportDeclarationContext) ImportAll() IImportAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportAllContext)
}

func (s *ImportDeclarationContext) ImportSingle() IImportSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportSingleContext)
}

func (s *ImportDeclarationContext) ImportMulti() IImportMultiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportMultiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportMultiContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImportDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, huloParserRULE_importDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1570)
		p.Match(huloParserIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserMUL:
		{
			p.SetState(1571)
			p.ImportAll()
		}

	case huloParserStringLiteral:
		{
			p.SetState(1572)
			p.ImportSingle()
		}

	case huloParserLBRACE:
		{
			p.SetState(1573)
			p.ImportMulti()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportSingleContext is an interface to support dynamic dispatch.
type IImportSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() antlr.TerminalNode
	AsIdentifier() IAsIdentifierContext

	// IsImportSingleContext differentiates from other interfaces.
	IsImportSingleContext()
}

type ImportSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSingleContext() *ImportSingleContext {
	var p = new(ImportSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importSingle
	return p
}

func InitEmptyImportSingleContext(p *ImportSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importSingle
}

func (*ImportSingleContext) IsImportSingleContext() {}

func NewImportSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSingleContext {
	var p = new(ImportSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_importSingle

	return p
}

func (s *ImportSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSingleContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *ImportSingleContext) AsIdentifier() IAsIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsIdentifierContext)
}

func (s *ImportSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImportSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImportSingle() (localctx IImportSingleContext) {
	localctx = NewImportSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, huloParserRULE_importSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1576)
		p.Match(huloParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserAS {
		{
			p.SetState(1577)
			p.AsIdentifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportAllContext is an interface to support dynamic dispatch.
type IImportAllContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MUL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	AsIdentifier() IAsIdentifierContext

	// IsImportAllContext differentiates from other interfaces.
	IsImportAllContext()
}

type ImportAllContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportAllContext() *ImportAllContext {
	var p = new(ImportAllContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importAll
	return p
}

func InitEmptyImportAllContext(p *ImportAllContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importAll
}

func (*ImportAllContext) IsImportAllContext() {}

func NewImportAllContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportAllContext {
	var p = new(ImportAllContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_importAll

	return p
}

func (s *ImportAllContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportAllContext) MUL() antlr.TerminalNode {
	return s.GetToken(huloParserMUL, 0)
}

func (s *ImportAllContext) FROM() antlr.TerminalNode {
	return s.GetToken(huloParserFROM, 0)
}

func (s *ImportAllContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *ImportAllContext) AsIdentifier() IAsIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsIdentifierContext)
}

func (s *ImportAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportAllContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImportAll(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImportAll() (localctx IImportAllContext) {
	localctx = NewImportAllContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, huloParserRULE_importAll)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1580)
		p.Match(huloParserMUL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserAS {
		{
			p.SetState(1581)
			p.AsIdentifier()
		}

	}
	{
		p.SetState(1584)
		p.Match(huloParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1585)
		p.Match(huloParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportMultiContext is an interface to support dynamic dispatch.
type IImportMultiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	AllIdentifierAsIdentifier() []IIdentifierAsIdentifierContext
	IdentifierAsIdentifier(i int) IIdentifierAsIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportMultiContext differentiates from other interfaces.
	IsImportMultiContext()
}

type ImportMultiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportMultiContext() *ImportMultiContext {
	var p = new(ImportMultiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importMulti
	return p
}

func InitEmptyImportMultiContext(p *ImportMultiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_importMulti
}

func (*ImportMultiContext) IsImportMultiContext() {}

func NewImportMultiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportMultiContext {
	var p = new(ImportMultiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_importMulti

	return p
}

func (s *ImportMultiContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportMultiContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ImportMultiContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ImportMultiContext) FROM() antlr.TerminalNode {
	return s.GetToken(huloParserFROM, 0)
}

func (s *ImportMultiContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *ImportMultiContext) AllIdentifierAsIdentifier() []IIdentifierAsIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierAsIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierAsIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierAsIdentifierContext); ok {
			tst[i] = t.(IIdentifierAsIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ImportMultiContext) IdentifierAsIdentifier(i int) IIdentifierAsIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierAsIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierAsIdentifierContext)
}

func (s *ImportMultiContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ImportMultiContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ImportMultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportMultiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportMultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitImportMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ImportMulti() (localctx IImportMultiContext) {
	localctx = NewImportMultiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, huloParserRULE_importMulti)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1587)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserIdentifier {
		{
			p.SetState(1588)
			p.IdentifierAsIdentifier()
		}
		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserCOMMA {
			{
				p.SetState(1589)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1590)
				p.IdentifierAsIdentifier()
			}

			p.SetState(1595)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1598)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1599)
		p.Match(huloParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1600)
		p.Match(huloParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsIdentifierContext is an interface to support dynamic dispatch.
type IAsIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsAsIdentifierContext differentiates from other interfaces.
	IsAsIdentifierContext()
}

type AsIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsIdentifierContext() *AsIdentifierContext {
	var p = new(AsIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_asIdentifier
	return p
}

func InitEmptyAsIdentifierContext(p *AsIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_asIdentifier
}

func (*AsIdentifierContext) IsAsIdentifierContext() {}

func NewAsIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsIdentifierContext {
	var p = new(AsIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_asIdentifier

	return p
}

func (s *AsIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AsIdentifierContext) AS() antlr.TerminalNode {
	return s.GetToken(huloParserAS, 0)
}

func (s *AsIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *AsIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitAsIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) AsIdentifier() (localctx IAsIdentifierContext) {
	localctx = NewAsIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, huloParserRULE_asIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1602)
		p.Match(huloParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1603)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierAsIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierAsIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AsIdentifier() IAsIdentifierContext

	// IsIdentifierAsIdentifierContext differentiates from other interfaces.
	IsIdentifierAsIdentifierContext()
}

type IdentifierAsIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierAsIdentifierContext() *IdentifierAsIdentifierContext {
	var p = new(IdentifierAsIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_identifierAsIdentifier
	return p
}

func InitEmptyIdentifierAsIdentifierContext(p *IdentifierAsIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_identifierAsIdentifier
}

func (*IdentifierAsIdentifierContext) IsIdentifierAsIdentifierContext() {}

func NewIdentifierAsIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierAsIdentifierContext {
	var p = new(IdentifierAsIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_identifierAsIdentifier

	return p
}

func (s *IdentifierAsIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierAsIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *IdentifierAsIdentifierContext) AsIdentifier() IAsIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsIdentifierContext)
}

func (s *IdentifierAsIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierAsIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierAsIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitIdentifierAsIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) IdentifierAsIdentifier() (localctx IIdentifierAsIdentifierContext) {
	localctx = NewIdentifierAsIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, huloParserRULE_identifierAsIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1605)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserAS {
		{
			p.SetState(1606)
			p.AsIdentifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleDeclarationContext is an interface to support dynamic dispatch.
type IModuleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MOD_LIT() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	PUB() antlr.TerminalNode
	AllModuleStatement() []IModuleStatementContext
	ModuleStatement(i int) IModuleStatementContext

	// IsModuleDeclarationContext differentiates from other interfaces.
	IsModuleDeclarationContext()
}

type ModuleDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclarationContext() *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_moduleDeclaration
	return p
}

func InitEmptyModuleDeclarationContext(p *ModuleDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_moduleDeclaration
}

func (*ModuleDeclarationContext) IsModuleDeclarationContext() {}

func NewModuleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclarationContext {
	var p = new(ModuleDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_moduleDeclaration

	return p
}

func (s *ModuleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclarationContext) MOD_LIT() antlr.TerminalNode {
	return s.GetToken(huloParserMOD_LIT, 0)
}

func (s *ModuleDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ModuleDeclarationContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ModuleDeclarationContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ModuleDeclarationContext) PUB() antlr.TerminalNode {
	return s.GetToken(huloParserPUB, 0)
}

func (s *ModuleDeclarationContext) AllModuleStatement() []IModuleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleStatementContext); ok {
			len++
		}
	}

	tst := make([]IModuleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleStatementContext); ok {
			tst[i] = t.(IModuleStatementContext)
			i++
		}
	}

	return tst
}

func (s *ModuleDeclarationContext) ModuleStatement(i int) IModuleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleStatementContext)
}

func (s *ModuleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitModuleDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ModuleDeclaration() (localctx IModuleDeclarationContext) {
	localctx = NewModuleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, huloParserRULE_moduleDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserPUB {
		{
			p.SetState(1609)
			p.Match(huloParserPUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1612)
		p.Match(huloParserMOD_LIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1613)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1614)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9223362080032423930) != 0) || _la == huloParserDOLLAR || _la == huloParserWILDCARD {
		{
			p.SetState(1615)
			p.ModuleStatement()
		}

		p.SetState(1620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1621)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleStatementContext is an interface to support dynamic dispatch.
type IModuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UseDeclaration() IUseDeclarationContext
	ModuleDeclaration() IModuleDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	TraitDeclaration() ITraitDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	ExtendDeclaration() IExtendDeclarationContext
	AssignStatement() IAssignStatementContext

	// IsModuleStatementContext differentiates from other interfaces.
	IsModuleStatementContext()
}

type ModuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleStatementContext() *ModuleStatementContext {
	var p = new(ModuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_moduleStatement
	return p
}

func InitEmptyModuleStatementContext(p *ModuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_moduleStatement
}

func (*ModuleStatementContext) IsModuleStatementContext() {}

func NewModuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleStatementContext {
	var p = new(ModuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_moduleStatement

	return p
}

func (s *ModuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleStatementContext) UseDeclaration() IUseDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *ModuleStatementContext) ModuleDeclaration() IModuleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *ModuleStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ModuleStatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *ModuleStatementContext) TraitDeclaration() ITraitDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitDeclarationContext)
}

func (s *ModuleStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *ModuleStatementContext) ExtendDeclaration() IExtendDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendDeclarationContext)
}

func (s *ModuleStatementContext) AssignStatement() IAssignStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignStatementContext)
}

func (s *ModuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitModuleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ModuleStatement() (localctx IModuleStatementContext) {
	localctx = NewModuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, huloParserRULE_moduleStatement)
	p.SetState(1631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1623)
			p.UseDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1624)
			p.ModuleDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1625)
			p.ClassDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1626)
			p.EnumDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1627)
			p.TraitDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1628)
			p.FunctionDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1629)
			p.ExtendDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1630)
			p.AssignStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseDeclarationContext is an interface to support dynamic dispatch.
type IUseDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	UseSingle() IUseSingleContext
	UseMulti() IUseMultiContext
	UseAll() IUseAllContext

	// IsUseDeclarationContext differentiates from other interfaces.
	IsUseDeclarationContext()
}

type UseDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContext() *UseDeclarationContext {
	var p = new(UseDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useDeclaration
	return p
}

func InitEmptyUseDeclarationContext(p *UseDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useDeclaration
}

func (*UseDeclarationContext) IsUseDeclarationContext() {}

func NewUseDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContext {
	var p = new(UseDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_useDeclaration

	return p
}

func (s *UseDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContext) USE() antlr.TerminalNode {
	return s.GetToken(huloParserUSE, 0)
}

func (s *UseDeclarationContext) UseSingle() IUseSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseSingleContext)
}

func (s *UseDeclarationContext) UseMulti() IUseMultiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseMultiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseMultiContext)
}

func (s *UseDeclarationContext) UseAll() IUseAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseAllContext)
}

func (s *UseDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitUseDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) UseDeclaration() (localctx IUseDeclarationContext) {
	localctx = NewUseDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, huloParserRULE_useDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1633)
		p.Match(huloParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserIdentifier:
		{
			p.SetState(1634)
			p.UseSingle()
		}

	case huloParserLBRACE:
		{
			p.SetState(1635)
			p.UseMulti()
		}

	case huloParserMUL:
		{
			p.SetState(1636)
			p.UseAll()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseSingleContext is an interface to support dynamic dispatch.
type IUseSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AsIdentifier() IAsIdentifierContext

	// IsUseSingleContext differentiates from other interfaces.
	IsUseSingleContext()
}

type UseSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseSingleContext() *UseSingleContext {
	var p = new(UseSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useSingle
	return p
}

func InitEmptyUseSingleContext(p *UseSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useSingle
}

func (*UseSingleContext) IsUseSingleContext() {}

func NewUseSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseSingleContext {
	var p = new(UseSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_useSingle

	return p
}

func (s *UseSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *UseSingleContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *UseSingleContext) AsIdentifier() IAsIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsIdentifierContext)
}

func (s *UseSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitUseSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) UseSingle() (localctx IUseSingleContext) {
	localctx = NewUseSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, huloParserRULE_useSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1639)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserAS {
		{
			p.SetState(1640)
			p.AsIdentifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseMultiContext is an interface to support dynamic dispatch.
type IUseMultiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllIdentifierAsIdentifier() []IIdentifierAsIdentifierContext
	IdentifierAsIdentifier(i int) IIdentifierAsIdentifierContext
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUseMultiContext differentiates from other interfaces.
	IsUseMultiContext()
}

type UseMultiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseMultiContext() *UseMultiContext {
	var p = new(UseMultiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useMulti
	return p
}

func InitEmptyUseMultiContext(p *UseMultiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useMulti
}

func (*UseMultiContext) IsUseMultiContext() {}

func NewUseMultiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseMultiContext {
	var p = new(UseMultiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_useMulti

	return p
}

func (s *UseMultiContext) GetParser() antlr.Parser { return s.parser }

func (s *UseMultiContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *UseMultiContext) AllIdentifierAsIdentifier() []IIdentifierAsIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierAsIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierAsIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierAsIdentifierContext); ok {
			tst[i] = t.(IIdentifierAsIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseMultiContext) IdentifierAsIdentifier(i int) IIdentifierAsIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierAsIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierAsIdentifierContext)
}

func (s *UseMultiContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *UseMultiContext) FROM() antlr.TerminalNode {
	return s.GetToken(huloParserFROM, 0)
}

func (s *UseMultiContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *UseMultiContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *UseMultiContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *UseMultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseMultiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseMultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitUseMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) UseMulti() (localctx IUseMultiContext) {
	localctx = NewUseMultiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, huloParserRULE_useMulti)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1643)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1644)
		p.IdentifierAsIdentifier()
	}
	p.SetState(1649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1645)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1646)
			p.IdentifierAsIdentifier()
		}

		p.SetState(1651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1652)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1653)
		p.Match(huloParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1654)
		p.Match(huloParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseAllContext is an interface to support dynamic dispatch.
type IUseAllContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MUL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	AsIdentifier() IAsIdentifierContext

	// IsUseAllContext differentiates from other interfaces.
	IsUseAllContext()
}

type UseAllContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAllContext() *UseAllContext {
	var p = new(UseAllContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useAll
	return p
}

func InitEmptyUseAllContext(p *UseAllContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_useAll
}

func (*UseAllContext) IsUseAllContext() {}

func NewUseAllContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAllContext {
	var p = new(UseAllContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_useAll

	return p
}

func (s *UseAllContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAllContext) MUL() antlr.TerminalNode {
	return s.GetToken(huloParserMUL, 0)
}

func (s *UseAllContext) FROM() antlr.TerminalNode {
	return s.GetToken(huloParserFROM, 0)
}

func (s *UseAllContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *UseAllContext) AsIdentifier() IAsIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsIdentifierContext)
}

func (s *UseAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAllContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitUseAll(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) UseAll() (localctx IUseAllContext) {
	localctx = NewUseAllContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, huloParserRULE_useAll)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1656)
		p.Match(huloParserMUL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserAS {
		{
			p.SetState(1657)
			p.AsIdentifier()
		}

	}
	{
		p.SetState(1660)
		p.Match(huloParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1661)
		p.Match(huloParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Type_() ITypeContext
	GenericParameters() IGenericParametersContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) TYPE() antlr.TerminalNode {
	return s.GetToken(huloParserTYPE, 0)
}

func (s *TypeDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *TypeDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(huloParserASSIGN, 0)
}

func (s *TypeDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeDeclarationContext) GenericParameters() IGenericParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParametersContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, huloParserRULE_typeDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1663)
		p.Match(huloParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1664)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserLT {
		{
			p.SetState(1665)
			p.GenericParameters()
		}

	}
	{
		p.SetState(1668)
		p.Match(huloParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1669)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericArgumentsContext is an interface to support dynamic dispatch.
type IGenericArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsGenericArgumentsContext differentiates from other interfaces.
	IsGenericArgumentsContext()
}

type GenericArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericArgumentsContext() *GenericArgumentsContext {
	var p = new(GenericArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericArguments
	return p
}

func InitEmptyGenericArgumentsContext(p *GenericArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericArguments
}

func (*GenericArgumentsContext) IsGenericArgumentsContext() {}

func NewGenericArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericArgumentsContext {
	var p = new(GenericArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_genericArguments

	return p
}

func (s *GenericArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(huloParserLT, 0)
}

func (s *GenericArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(huloParserGT, 0)
}

func (s *GenericArgumentsContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *GenericArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitGenericArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) GenericArguments() (localctx IGenericArgumentsContext) {
	localctx = NewGenericArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, huloParserRULE_genericArguments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		p.Match(huloParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&23644722677415936) != 0) || ((int64((_la-106)) & ^0x3f) == 0 && ((int64(1)<<(_la-106))&66495) != 0) {
		{
			p.SetState(1672)
			p.TypeList()
		}

	}
	{
		p.SetState(1675)
		p.Match(huloParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParametersContext is an interface to support dynamic dispatch.
type IGenericParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GenericParameterList() IGenericParameterListContext
	GT() antlr.TerminalNode

	// IsGenericParametersContext differentiates from other interfaces.
	IsGenericParametersContext()
}

type GenericParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParametersContext() *GenericParametersContext {
	var p = new(GenericParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericParameters
	return p
}

func InitEmptyGenericParametersContext(p *GenericParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericParameters
}

func (*GenericParametersContext) IsGenericParametersContext() {}

func NewGenericParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParametersContext {
	var p = new(GenericParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_genericParameters

	return p
}

func (s *GenericParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(huloParserLT, 0)
}

func (s *GenericParametersContext) GenericParameterList() IGenericParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterListContext)
}

func (s *GenericParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(huloParserGT, 0)
}

func (s *GenericParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitGenericParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) GenericParameters() (localctx IGenericParametersContext) {
	localctx = NewGenericParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, huloParserRULE_genericParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1677)
		p.Match(huloParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1678)
		p.GenericParameterList()
	}
	{
		p.SetState(1679)
		p.Match(huloParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParameterListContext is an interface to support dynamic dispatch.
type IGenericParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericParameter() []IGenericParameterContext
	GenericParameter(i int) IGenericParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGenericParameterListContext differentiates from other interfaces.
	IsGenericParameterListContext()
}

type GenericParameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParameterListContext() *GenericParameterListContext {
	var p = new(GenericParameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericParameterList
	return p
}

func InitEmptyGenericParameterListContext(p *GenericParameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericParameterList
}

func (*GenericParameterListContext) IsGenericParameterListContext() {}

func NewGenericParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParameterListContext {
	var p = new(GenericParameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_genericParameterList

	return p
}

func (s *GenericParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParameterListContext) AllGenericParameter() []IGenericParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericParameterContext); ok {
			len++
		}
	}

	tst := make([]IGenericParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericParameterContext); ok {
			tst[i] = t.(IGenericParameterContext)
			i++
		}
	}

	return tst
}

func (s *GenericParameterListContext) GenericParameter(i int) IGenericParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericParameterContext)
}

func (s *GenericParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *GenericParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *GenericParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitGenericParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) GenericParameterList() (localctx IGenericParameterListContext) {
	localctx = NewGenericParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, huloParserRULE_genericParameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1681)
		p.GenericParameter()
	}
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1682)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1683)
			p.GenericParameter()
		}

		p.SetState(1688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericParameterContext is an interface to support dynamic dispatch.
type IGenericParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsGenericParameterContext differentiates from other interfaces.
	IsGenericParameterContext()
}

type GenericParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericParameterContext() *GenericParameterContext {
	var p = new(GenericParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericParameter
	return p
}

func InitEmptyGenericParameterContext(p *GenericParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_genericParameter
}

func (*GenericParameterContext) IsGenericParameterContext() {}

func NewGenericParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericParameterContext {
	var p = new(GenericParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_genericParameter

	return p
}

func (s *GenericParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericParameterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *GenericParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *GenericParameterContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GenericParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitGenericParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) GenericParameter() (localctx IGenericParameterContext) {
	localctx = NewGenericParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, huloParserRULE_genericParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCOLON {
		{
			p.SetState(1690)
			p.Match(huloParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeTypeContext is an interface to support dynamic dispatch.
type ICompositeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BITOR() antlr.TerminalNode
	Type_() ITypeContext
	BITAND() antlr.TerminalNode
	CompositeType() ICompositeTypeContext

	// IsCompositeTypeContext differentiates from other interfaces.
	IsCompositeTypeContext()
}

type CompositeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeTypeContext() *CompositeTypeContext {
	var p = new(CompositeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_compositeType
	return p
}

func InitEmptyCompositeTypeContext(p *CompositeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_compositeType
}

func (*CompositeTypeContext) IsCompositeTypeContext() {}

func NewCompositeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeTypeContext {
	var p = new(CompositeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_compositeType

	return p
}

func (s *CompositeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeTypeContext) BITOR() antlr.TerminalNode {
	return s.GetToken(huloParserBITOR, 0)
}

func (s *CompositeTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CompositeTypeContext) BITAND() antlr.TerminalNode {
	return s.GetToken(huloParserBITAND, 0)
}

func (s *CompositeTypeContext) CompositeType() ICompositeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeTypeContext)
}

func (s *CompositeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCompositeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CompositeType() (localctx ICompositeTypeContext) {
	localctx = NewCompositeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, huloParserRULE_compositeType)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserBITOR:
		{
			p.SetState(1694)
			p.Match(huloParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Type_()
		}

	case huloParserBITAND:
		{
			p.SetState(1696)
			p.Match(huloParserBITAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1697)
			p.Type_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1701)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1700)
			p.CompositeType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccess() IMemberAccessContext
	StringLiteral() antlr.TerminalNode
	FunctionType() IFunctionTypeContext
	ObjectType() IObjectTypeContext
	TupleType() ITupleTypeContext
	STR() antlr.TerminalNode
	NUM() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	ANY() antlr.TerminalNode
	VOID() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	QUEST() antlr.TerminalNode
	Comment() ICommentContext
	CompositeType() ICompositeTypeContext
	TypeAccessPoint() ITypeAccessPointContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *TypeContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *TypeContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *TypeContext) ObjectType() IObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeContext)
}

func (s *TypeContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *TypeContext) STR() antlr.TerminalNode {
	return s.GetToken(huloParserSTR, 0)
}

func (s *TypeContext) NUM() antlr.TerminalNode {
	return s.GetToken(huloParserNUM, 0)
}

func (s *TypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(huloParserBOOL, 0)
}

func (s *TypeContext) ANY() antlr.TerminalNode {
	return s.GetToken(huloParserANY, 0)
}

func (s *TypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(huloParserVOID, 0)
}

func (s *TypeContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *TypeContext) QUEST() antlr.TerminalNode {
	return s.GetToken(huloParserQUEST, 0)
}

func (s *TypeContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *TypeContext) CompositeType() ICompositeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeTypeContext)
}

func (s *TypeContext) TypeAccessPoint() ITypeAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAccessPointContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, huloParserRULE_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1703)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&32799) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1705)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1704)
				p.TypeAccessPoint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(1707)
			p.MemberAccess()
		}

	case 3:
		{
			p.SetState(1708)
			p.Match(huloParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1709)
			p.FunctionType()
		}

	case 5:
		{
			p.SetState(1710)
			p.ObjectType()
		}

	case 6:
		{
			p.SetState(1711)
			p.TupleType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1715)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1714)
			p.Match(huloParserQUEST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1718)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1717)
			p.Comment()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1721)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1720)
			p.CompositeType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeLiteralContext is an interface to support dynamic dispatch.
type ITypeLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STR() antlr.TerminalNode
	NUM() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	ANY() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsTypeLiteralContext differentiates from other interfaces.
	IsTypeLiteralContext()
}

type TypeLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeLiteralContext() *TypeLiteralContext {
	var p = new(TypeLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeLiteral
	return p
}

func InitEmptyTypeLiteralContext(p *TypeLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeLiteral
}

func (*TypeLiteralContext) IsTypeLiteralContext() {}

func NewTypeLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeLiteralContext {
	var p = new(TypeLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_typeLiteral

	return p
}

func (s *TypeLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeLiteralContext) STR() antlr.TerminalNode {
	return s.GetToken(huloParserSTR, 0)
}

func (s *TypeLiteralContext) NUM() antlr.TerminalNode {
	return s.GetToken(huloParserNUM, 0)
}

func (s *TypeLiteralContext) BOOL() antlr.TerminalNode {
	return s.GetToken(huloParserBOOL, 0)
}

func (s *TypeLiteralContext) ANY() antlr.TerminalNode {
	return s.GetToken(huloParserANY, 0)
}

func (s *TypeLiteralContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *TypeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTypeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TypeLiteral() (localctx ITypeLiteralContext) {
	localctx = NewTypeLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, huloParserRULE_typeLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1723)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-107)) & ^0x3f) == 0 && ((int64(1)<<(_la-107))&32783) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullableTypeContext is an interface to support dynamic dispatch.
type INullableTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	QUEST() antlr.TerminalNode

	// IsNullableTypeContext differentiates from other interfaces.
	IsNullableTypeContext()
}

type NullableTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullableTypeContext() *NullableTypeContext {
	var p = new(NullableTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_nullableType
	return p
}

func InitEmptyNullableTypeContext(p *NullableTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_nullableType
}

func (*NullableTypeContext) IsNullableTypeContext() {}

func NewNullableTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullableTypeContext {
	var p = new(NullableTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_nullableType

	return p
}

func (s *NullableTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NullableTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *NullableTypeContext) QUEST() antlr.TerminalNode {
	return s.GetToken(huloParserQUEST, 0)
}

func (s *NullableTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullableTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullableTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitNullableType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) NullableType() (localctx INullableTypeContext) {
	localctx = NewNullableTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, huloParserRULE_nullableType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1725)
		p.Type_()
	}
	{
		p.SetState(1726)
		p.Match(huloParserQUEST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionTypeContext is an interface to support dynamic dispatch.
type IUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllBITOR() []antlr.TerminalNode
	BITOR(i int) antlr.TerminalNode

	// IsUnionTypeContext differentiates from other interfaces.
	IsUnionTypeContext()
}

type UnionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTypeContext() *UnionTypeContext {
	var p = new(UnionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_unionType
	return p
}

func InitEmptyUnionTypeContext(p *UnionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_unionType
}

func (*UnionTypeContext) IsUnionTypeContext() {}

func NewUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTypeContext {
	var p = new(UnionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_unionType

	return p
}

func (s *UnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *UnionTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *UnionTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(huloParserBITOR)
}

func (s *UnionTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(huloParserBITOR, i)
}

func (s *UnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitUnionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) UnionType() (localctx IUnionTypeContext) {
	localctx = NewUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, huloParserRULE_unionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1728)
		p.Type_()
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserBITOR {
		{
			p.SetState(1729)
			p.Match(huloParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1730)
			p.Type_()
		}

		p.SetState(1735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntersectionTypeContext is an interface to support dynamic dispatch.
type IIntersectionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllBITAND() []antlr.TerminalNode
	BITAND(i int) antlr.TerminalNode

	// IsIntersectionTypeContext differentiates from other interfaces.
	IsIntersectionTypeContext()
}

type IntersectionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectionTypeContext() *IntersectionTypeContext {
	var p = new(IntersectionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_intersectionType
	return p
}

func InitEmptyIntersectionTypeContext(p *IntersectionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_intersectionType
}

func (*IntersectionTypeContext) IsIntersectionTypeContext() {}

func NewIntersectionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectionTypeContext {
	var p = new(IntersectionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_intersectionType

	return p
}

func (s *IntersectionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectionTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *IntersectionTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *IntersectionTypeContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(huloParserBITAND)
}

func (s *IntersectionTypeContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(huloParserBITAND, i)
}

func (s *IntersectionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntersectionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitIntersectionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) IntersectionType() (localctx IIntersectionTypeContext) {
	localctx = NewIntersectionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, huloParserRULE_intersectionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1736)
		p.Type_()
	}
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserBITAND {
		{
			p.SetState(1737)
			p.Match(huloParserBITAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1738)
			p.Type_()
		}

		p.SetState(1743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACK, 0)
}

func (s *ArrayTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACK, 0)
}

func (s *ArrayTypeContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserNumberLiteral, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, huloParserRULE_arrayType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1744)
		p.Type_()
	}
	{
		p.SetState(1745)
		p.Match(huloParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserNumberLiteral {
		{
			p.SetState(1746)
			p.Match(huloParserNumberLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1749)
		p.Match(huloParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAccessPointContext is an interface to support dynamic dispatch.
type ITypeAccessPointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	RBRACK() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	TypeAccessPoint() ITypeAccessPointContext

	// IsTypeAccessPointContext differentiates from other interfaces.
	IsTypeAccessPointContext()
}

type TypeAccessPointContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAccessPointContext() *TypeAccessPointContext {
	var p = new(TypeAccessPointContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeAccessPoint
	return p
}

func InitEmptyTypeAccessPointContext(p *TypeAccessPointContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeAccessPoint
}

func (*TypeAccessPointContext) IsTypeAccessPointContext() {}

func NewTypeAccessPointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAccessPointContext {
	var p = new(TypeAccessPointContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_typeAccessPoint

	return p
}

func (s *TypeAccessPointContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAccessPointContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACK, 0)
}

func (s *TypeAccessPointContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACK, 0)
}

func (s *TypeAccessPointContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserNumberLiteral, 0)
}

func (s *TypeAccessPointContext) TypeAccessPoint() ITypeAccessPointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAccessPointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAccessPointContext)
}

func (s *TypeAccessPointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAccessPointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAccessPointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTypeAccessPoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TypeAccessPoint() (localctx ITypeAccessPointContext) {
	localctx = NewTypeAccessPointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, huloParserRULE_typeAccessPoint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1751)
		p.Match(huloParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserNumberLiteral {
		{
			p.SetState(1752)
			p.Match(huloParserNumberLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1755)
		p.Match(huloParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1757)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1756)
			p.TypeAccessPoint()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, huloParserRULE_typeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1759)
		p.Type_()
	}
	p.SetState(1764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1760)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1761)
			p.Type_()
		}

		p.SetState(1766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeofExpressionContext is an interface to support dynamic dispatch.
type ITypeofExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPEOF() antlr.TerminalNode
	Expression() IExpressionContext

	// IsTypeofExpressionContext differentiates from other interfaces.
	IsTypeofExpressionContext()
}

type TypeofExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeofExpressionContext() *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeofExpression
	return p
}

func InitEmptyTypeofExpressionContext(p *TypeofExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_typeofExpression
}

func (*TypeofExpressionContext) IsTypeofExpressionContext() {}

func NewTypeofExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeofExpressionContext {
	var p = new(TypeofExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_typeofExpression

	return p
}

func (s *TypeofExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeofExpressionContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(huloParserTYPEOF, 0)
}

func (s *TypeofExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeofExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTypeofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TypeofExpression() (localctx ITypeofExpressionContext) {
	localctx = NewTypeofExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, huloParserRULE_typeofExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1767)
		p.Match(huloParserTYPEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1768)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsExpressionContext is an interface to support dynamic dispatch.
type IAsExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableExpression() IVariableExpressionContext
	AS() antlr.TerminalNode
	Type_() ITypeContext

	// IsAsExpressionContext differentiates from other interfaces.
	IsAsExpressionContext()
}

type AsExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsExpressionContext() *AsExpressionContext {
	var p = new(AsExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_asExpression
	return p
}

func InitEmptyAsExpressionContext(p *AsExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_asExpression
}

func (*AsExpressionContext) IsAsExpressionContext() {}

func NewAsExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsExpressionContext {
	var p = new(AsExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_asExpression

	return p
}

func (s *AsExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsExpressionContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *AsExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(huloParserAS, 0)
}

func (s *AsExpressionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitAsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) AsExpression() (localctx IAsExpressionContext) {
	localctx = NewAsExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, huloParserRULE_asExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.VariableExpression()
	}
	{
		p.SetState(1771)
		p.Match(huloParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1772)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectTypeContext is an interface to support dynamic dispatch.
type IObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllObjectTypeMember() []IObjectTypeMemberContext
	ObjectTypeMember(i int) IObjectTypeMemberContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectTypeContext differentiates from other interfaces.
	IsObjectTypeContext()
}

type ObjectTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeContext() *ObjectTypeContext {
	var p = new(ObjectTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_objectType
	return p
}

func InitEmptyObjectTypeContext(p *ObjectTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_objectType
}

func (*ObjectTypeContext) IsObjectTypeContext() {}

func NewObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeContext {
	var p = new(ObjectTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_objectType

	return p
}

func (s *ObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *ObjectTypeContext) AllObjectTypeMember() []IObjectTypeMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectTypeMemberContext); ok {
			len++
		}
	}

	tst := make([]IObjectTypeMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectTypeMemberContext); ok {
			tst[i] = t.(IObjectTypeMemberContext)
			i++
		}
	}

	return tst
}

func (s *ObjectTypeContext) ObjectTypeMember(i int) IObjectTypeMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectTypeMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectTypeMemberContext)
}

func (s *ObjectTypeContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *ObjectTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ObjectTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitObjectType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ObjectType() (localctx IObjectTypeContext) {
	localctx = NewObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, huloParserRULE_objectType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1774)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1775)
		p.ObjectTypeMember()
	}
	p.SetState(1780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1776)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1777)
			p.ObjectTypeMember()
		}

		p.SetState(1782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1783)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectTypeMemberContext is an interface to support dynamic dispatch.
type IObjectTypeMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsObjectTypeMemberContext differentiates from other interfaces.
	IsObjectTypeMemberContext()
}

type ObjectTypeMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectTypeMemberContext() *ObjectTypeMemberContext {
	var p = new(ObjectTypeMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_objectTypeMember
	return p
}

func InitEmptyObjectTypeMemberContext(p *ObjectTypeMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_objectTypeMember
}

func (*ObjectTypeMemberContext) IsObjectTypeMemberContext() {}

func NewObjectTypeMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectTypeMemberContext {
	var p = new(ObjectTypeMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_objectTypeMember

	return p
}

func (s *ObjectTypeMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectTypeMemberContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ObjectTypeMemberContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *ObjectTypeMemberContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ObjectTypeMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectTypeMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectTypeMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitObjectTypeMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ObjectTypeMember() (localctx IObjectTypeMemberContext) {
	localctx = NewObjectTypeMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, huloParserRULE_objectTypeMember)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1785)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1786)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1787)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACK() antlr.TerminalNode
	TypeList() ITypeListContext
	RBRACK() antlr.TerminalNode

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACK, 0)
}

func (s *TupleTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TupleTypeContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACK, 0)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, huloParserRULE_tupleType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1789)
		p.Match(huloParserLBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1790)
		p.TypeList()
	}
	{
		p.SetState(1791)
		p.Match(huloParserRBRACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReceiverParameters() IReceiverParametersContext
	THROWS() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	FunctionReturnValue() IFunctionReturnValueContext

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) ReceiverParameters() IReceiverParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiverParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiverParametersContext)
}

func (s *FunctionTypeContext) THROWS() antlr.TerminalNode {
	return s.GetToken(huloParserTHROWS, 0)
}

func (s *FunctionTypeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserARROW, 0)
}

func (s *FunctionTypeContext) FunctionReturnValue() IFunctionReturnValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionReturnValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionReturnValueContext)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, huloParserRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1793)
		p.ReceiverParameters()
	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserTHROWS {
		{
			p.SetState(1794)
			p.Match(huloParserTHROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserARROW {
		{
			p.SetState(1797)
			p.Match(huloParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1798)
			p.FunctionReturnValue()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Block() IBlockContext
	AllCatchClause() []ICatchClauseContext
	CatchClause(i int) ICatchClauseContext
	FinallyClause() IFinallyClauseContext

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_tryStatement
	return p
}

func InitEmptyTryStatementContext(p *TryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_tryStatement
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(huloParserTRY, 0)
}

func (s *TryStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryStatementContext) AllCatchClause() []ICatchClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICatchClauseContext); ok {
			len++
		}
	}

	tst := make([]ICatchClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICatchClauseContext); ok {
			tst[i] = t.(ICatchClauseContext)
			i++
		}
	}

	return tst
}

func (s *TryStatementContext) CatchClause(i int) ICatchClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryStatementContext) FinallyClause() IFinallyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFinallyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFinallyClauseContext)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitTryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) TryStatement() (localctx ITryStatementContext) {
	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, huloParserRULE_tryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1801)
		p.Match(huloParserTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1802)
		p.Block()
	}
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCATCH {
		{
			p.SetState(1803)
			p.CatchClause()
		}

		p.SetState(1808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserFINALLY {
		{
			p.SetState(1809)
			p.FinallyClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATCH() antlr.TerminalNode
	Block() IBlockContext
	CatchClauseReceiver() ICatchClauseReceiverContext
	MemberAccess() IMemberAccessContext

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_catchClause
	return p
}

func InitEmptyCatchClauseContext(p *CatchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_catchClause
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(huloParserCATCH, 0)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) CatchClauseReceiver() ICatchClauseReceiverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICatchClauseReceiverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICatchClauseReceiverContext)
}

func (s *CatchClauseContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, huloParserRULE_catchClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1812)
		p.Match(huloParserCATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case huloParserLPAREN:
		{
			p.SetState(1813)
			p.CatchClauseReceiver()
		}

	case huloParserTHIS, huloParserSUPER, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserIdentifier:
		{
			p.SetState(1814)
			p.MemberAccess()
		}

	case huloParserLBRACE:

	default:
	}
	{
		p.SetState(1817)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICatchClauseReceiverContext is an interface to support dynamic dispatch.
type ICatchClauseReceiverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsCatchClauseReceiverContext differentiates from other interfaces.
	IsCatchClauseReceiverContext()
}

type CatchClauseReceiverContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseReceiverContext() *CatchClauseReceiverContext {
	var p = new(CatchClauseReceiverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_catchClauseReceiver
	return p
}

func InitEmptyCatchClauseReceiverContext(p *CatchClauseReceiverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_catchClauseReceiver
}

func (*CatchClauseReceiverContext) IsCatchClauseReceiverContext() {}

func NewCatchClauseReceiverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseReceiverContext {
	var p = new(CatchClauseReceiverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_catchClauseReceiver

	return p
}

func (s *CatchClauseReceiverContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseReceiverContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *CatchClauseReceiverContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *CatchClauseReceiverContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *CatchClauseReceiverContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *CatchClauseReceiverContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CatchClauseReceiverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseReceiverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseReceiverContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitCatchClauseReceiver(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) CatchClauseReceiver() (localctx ICatchClauseReceiverContext) {
	localctx = NewCatchClauseReceiverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, huloParserRULE_catchClauseReceiver)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1819)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1820)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCOLON {
		{
			p.SetState(1821)
			p.Match(huloParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1822)
			p.Type_()
		}

	}
	{
		p.SetState(1825)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFinallyClauseContext is an interface to support dynamic dispatch.
type IFinallyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FINALLY() antlr.TerminalNode
	Block() IBlockContext

	// IsFinallyClauseContext differentiates from other interfaces.
	IsFinallyClauseContext()
}

type FinallyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyClauseContext() *FinallyClauseContext {
	var p = new(FinallyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_finallyClause
	return p
}

func InitEmptyFinallyClauseContext(p *FinallyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_finallyClause
}

func (*FinallyClauseContext) IsFinallyClauseContext() {}

func NewFinallyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyClauseContext {
	var p = new(FinallyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_finallyClause

	return p
}

func (s *FinallyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyClauseContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(huloParserFINALLY, 0)
}

func (s *FinallyClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitFinallyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) FinallyClause() (localctx IFinallyClauseContext) {
	localctx = NewFinallyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, huloParserRULE_finallyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1827)
		p.Match(huloParserFINALLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1828)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THROW() antlr.TerminalNode
	NewDelExpression() INewDelExpressionContext
	CallExpression() ICallExpressionContext

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_throwStatement
	return p
}

func InitEmptyThrowStatementContext(p *ThrowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_throwStatement
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(huloParserTHROW, 0)
}

func (s *ThrowStatementContext) NewDelExpression() INewDelExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewDelExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewDelExpressionContext)
}

func (s *ThrowStatementContext) CallExpression() ICallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitThrowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, huloParserRULE_throwStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1830)
		p.Match(huloParserTHROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserNEW, huloParserDELETE:
		{
			p.SetState(1831)
			p.NewDelExpression()
		}

	case huloParserTHIS, huloParserSUPER, huloParserNULL, huloParserNUM, huloParserSTR, huloParserBOOL, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral, huloParserIdentifier:
		{
			p.SetState(1832)
			p.CallExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(huloParserBREAK, 0)
}

func (s *BreakStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, huloParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1835)
		p.Match(huloParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1836)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(huloParserCONTINUE, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, huloParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1839)
		p.Match(huloParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	ConditionalExpression() IConditionalExpressionContext
	AllBlock() []IBlockContext
	Block(i int) IBlockContext
	ELSE() antlr.TerminalNode
	IfStatement() IIfStatementContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(huloParserIF, 0)
}

func (s *IfStatementContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *IfStatementContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(huloParserELSE, 0)
}

func (s *IfStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, huloParserRULE_ifStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		p.Match(huloParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1842)
		p.ConditionalExpression()
	}
	{
		p.SetState(1843)
		p.Block()
	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserELSE {
		{
			p.SetState(1844)
			p.Match(huloParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case huloParserIF:
			{
				p.SetState(1845)
				p.IfStatement()
			}

		case huloParserLBRACE:
			{
				p.SetState(1846)
				p.Block()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchStatementContext is an interface to support dynamic dispatch.
type IMatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllMatchCaseClause() []IMatchCaseClauseContext
	MatchCaseClause(i int) IMatchCaseClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	MatchDefaultClause() IMatchDefaultClauseContext
	AllComment() []ICommentContext
	Comment(i int) ICommentContext

	// IsMatchStatementContext differentiates from other interfaces.
	IsMatchStatementContext()
}

type MatchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchStatementContext() *MatchStatementContext {
	var p = new(MatchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchStatement
	return p
}

func InitEmptyMatchStatementContext(p *MatchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchStatement
}

func (*MatchStatementContext) IsMatchStatementContext() {}

func NewMatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchStatementContext {
	var p = new(MatchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchStatement

	return p
}

func (s *MatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchStatementContext) MATCH() antlr.TerminalNode {
	return s.GetToken(huloParserMATCH, 0)
}

func (s *MatchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserLBRACE, 0)
}

func (s *MatchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(huloParserRBRACE, 0)
}

func (s *MatchStatementContext) AllMatchCaseClause() []IMatchCaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchCaseClauseContext); ok {
			len++
		}
	}

	tst := make([]IMatchCaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchCaseClauseContext); ok {
			tst[i] = t.(IMatchCaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchStatementContext) MatchCaseClause(i int) IMatchCaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchCaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchCaseClauseContext)
}

func (s *MatchStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *MatchStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *MatchStatementContext) MatchDefaultClause() IMatchDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchDefaultClauseContext)
}

func (s *MatchStatementContext) AllComment() []ICommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommentContext); ok {
			len++
		}
	}

	tst := make([]ICommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommentContext); ok {
			tst[i] = t.(ICommentContext)
			i++
		}
	}

	return tst
}

func (s *MatchStatementContext) Comment(i int) ICommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *MatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchStatement() (localctx IMatchStatementContext) {
	localctx = NewMatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, huloParserRULE_matchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1851)
		p.Match(huloParserMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1852)
		p.Expression()
	}
	{
		p.SetState(1853)
		p.Match(huloParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2329496527984132160) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&159877240238112769) != 0) {
		{
			p.SetState(1854)
			p.MatchCaseClause()
		}
		{
			p.SetState(1855)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1859)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserLineComment || _la == huloParserBlockComment {
			{
				p.SetState(1856)
				p.Comment()
			}

			p.SetState(1861)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(1866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserWILDCARD {
		{
			p.SetState(1867)
			p.MatchDefaultClause()
		}
		p.SetState(1869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserCOMMA {
			{
				p.SetState(1868)
				p.Match(huloParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == huloParserLineComment || _la == huloParserBlockComment {
			{
				p.SetState(1871)
				p.Comment()
			}

			p.SetState(1876)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1879)
		p.Match(huloParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchCaseClauseContext is an interface to support dynamic dispatch.
type IMatchCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_ARROW() antlr.TerminalNode
	MatchCaseBody() IMatchCaseBodyContext
	Type_() ITypeContext
	MatchEnum() IMatchEnumContext
	MemberAccess() IMemberAccessContext
	MatchTriple() IMatchTripleContext
	Expression() IExpressionContext
	RangeExpression() IRangeExpressionContext

	// IsMatchCaseClauseContext differentiates from other interfaces.
	IsMatchCaseClauseContext()
}

type MatchCaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchCaseClauseContext() *MatchCaseClauseContext {
	var p = new(MatchCaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchCaseClause
	return p
}

func InitEmptyMatchCaseClauseContext(p *MatchCaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchCaseClause
}

func (*MatchCaseClauseContext) IsMatchCaseClauseContext() {}

func NewMatchCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchCaseClauseContext {
	var p = new(MatchCaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchCaseClause

	return p
}

func (s *MatchCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchCaseClauseContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_ARROW, 0)
}

func (s *MatchCaseClauseContext) MatchCaseBody() IMatchCaseBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchCaseBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchCaseBodyContext)
}

func (s *MatchCaseClauseContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MatchCaseClauseContext) MatchEnum() IMatchEnumContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchEnumContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchEnumContext)
}

func (s *MatchCaseClauseContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *MatchCaseClauseContext) MatchTriple() IMatchTripleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchTripleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchTripleContext)
}

func (s *MatchCaseClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchCaseClauseContext) RangeExpression() IRangeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *MatchCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchCaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchCaseClause() (localctx IMatchCaseClauseContext) {
	localctx = NewMatchCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, huloParserRULE_matchCaseClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1887)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1881)
			p.Type_()
		}

	case 2:
		{
			p.SetState(1882)
			p.MatchEnum()
		}

	case 3:
		{
			p.SetState(1883)
			p.MemberAccess()
		}

	case 4:
		{
			p.SetState(1884)
			p.MatchTriple()
		}

	case 5:
		{
			p.SetState(1885)
			p.Expression()
		}

	case 6:
		{
			p.SetState(1886)
			p.RangeExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1889)
		p.Match(huloParserDOUBLE_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1890)
		p.MatchCaseBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchEnumContext is an interface to support dynamic dispatch.
type IMatchEnumContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MemberAccess() IMemberAccessContext
	LPAREN() antlr.TerminalNode
	AllMatchEnumMember() []IMatchEnumMemberContext
	MatchEnumMember(i int) IMatchEnumMemberContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	IF() antlr.TerminalNode
	Expression() IExpressionContext

	// IsMatchEnumContext differentiates from other interfaces.
	IsMatchEnumContext()
}

type MatchEnumContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchEnumContext() *MatchEnumContext {
	var p = new(MatchEnumContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchEnum
	return p
}

func InitEmptyMatchEnumContext(p *MatchEnumContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchEnum
}

func (*MatchEnumContext) IsMatchEnumContext() {}

func NewMatchEnumContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchEnumContext {
	var p = new(MatchEnumContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchEnum

	return p
}

func (s *MatchEnumContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchEnumContext) MemberAccess() IMemberAccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberAccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *MatchEnumContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *MatchEnumContext) AllMatchEnumMember() []IMatchEnumMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchEnumMemberContext); ok {
			len++
		}
	}

	tst := make([]IMatchEnumMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchEnumMemberContext); ok {
			tst[i] = t.(IMatchEnumMemberContext)
			i++
		}
	}

	return tst
}

func (s *MatchEnumContext) MatchEnumMember(i int) IMatchEnumMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchEnumMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchEnumMemberContext)
}

func (s *MatchEnumContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *MatchEnumContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *MatchEnumContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *MatchEnumContext) IF() antlr.TerminalNode {
	return s.GetToken(huloParserIF, 0)
}

func (s *MatchEnumContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchEnumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchEnumContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchEnumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchEnum(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchEnum() (localctx IMatchEnumContext) {
	localctx = NewMatchEnumContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, huloParserRULE_matchEnum)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1892)
		p.MemberAccess()
	}
	{
		p.SetState(1893)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1894)
		p.MatchEnumMember()
	}
	p.SetState(1899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1895)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1896)
			p.MatchEnumMember()
		}

		p.SetState(1901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1902)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserIF {
		{
			p.SetState(1903)
			p.Match(huloParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1904)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchEnumMemberContext is an interface to support dynamic dispatch.
type IMatchEnumMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Literal() ILiteralContext
	WILDCARD() antlr.TerminalNode

	// IsMatchEnumMemberContext differentiates from other interfaces.
	IsMatchEnumMemberContext()
}

type MatchEnumMemberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchEnumMemberContext() *MatchEnumMemberContext {
	var p = new(MatchEnumMemberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchEnumMember
	return p
}

func InitEmptyMatchEnumMemberContext(p *MatchEnumMemberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchEnumMember
}

func (*MatchEnumMemberContext) IsMatchEnumMemberContext() {}

func NewMatchEnumMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchEnumMemberContext {
	var p = new(MatchEnumMemberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchEnumMember

	return p
}

func (s *MatchEnumMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchEnumMemberContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *MatchEnumMemberContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MatchEnumMemberContext) WILDCARD() antlr.TerminalNode {
	return s.GetToken(huloParserWILDCARD, 0)
}

func (s *MatchEnumMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchEnumMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchEnumMemberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchEnumMember(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchEnumMember() (localctx IMatchEnumMemberContext) {
	localctx = NewMatchEnumMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, huloParserRULE_matchEnumMember)
	p.SetState(1910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1907)
			p.Match(huloParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case huloParserNULL, huloParserNumberLiteral, huloParserStringLiteral, huloParserBoolLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1908)
			p.Literal()
		}

	case huloParserWILDCARD:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1909)
			p.Match(huloParserWILDCARD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchTripleContext is an interface to support dynamic dispatch.
type IMatchTripleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllMatchTripleValue() []IMatchTripleValueContext
	MatchTripleValue(i int) IMatchTripleValueContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	IF() antlr.TerminalNode
	Expression() IExpressionContext

	// IsMatchTripleContext differentiates from other interfaces.
	IsMatchTripleContext()
}

type MatchTripleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchTripleContext() *MatchTripleContext {
	var p = new(MatchTripleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchTriple
	return p
}

func InitEmptyMatchTripleContext(p *MatchTripleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchTriple
}

func (*MatchTripleContext) IsMatchTripleContext() {}

func NewMatchTripleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchTripleContext {
	var p = new(MatchTripleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchTriple

	return p
}

func (s *MatchTripleContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchTripleContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *MatchTripleContext) AllMatchTripleValue() []IMatchTripleValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMatchTripleValueContext); ok {
			len++
		}
	}

	tst := make([]IMatchTripleValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMatchTripleValueContext); ok {
			tst[i] = t.(IMatchTripleValueContext)
			i++
		}
	}

	return tst
}

func (s *MatchTripleContext) MatchTripleValue(i int) IMatchTripleValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchTripleValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchTripleValueContext)
}

func (s *MatchTripleContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *MatchTripleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *MatchTripleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *MatchTripleContext) IF() antlr.TerminalNode {
	return s.GetToken(huloParserIF, 0)
}

func (s *MatchTripleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchTripleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchTripleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchTripleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchTriple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchTriple() (localctx IMatchTripleContext) {
	localctx = NewMatchTripleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, huloParserRULE_matchTriple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1912)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1913)
		p.MatchTripleValue()
	}
	p.SetState(1918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(1914)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1915)
			p.MatchTripleValue()
		}

		p.SetState(1920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1921)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserIF {
		{
			p.SetState(1922)
			p.Match(huloParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1923)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchTripleValueContext is an interface to support dynamic dispatch.
type IMatchTripleValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	WILDCARD() antlr.TerminalNode

	// IsMatchTripleValueContext differentiates from other interfaces.
	IsMatchTripleValueContext()
}

type MatchTripleValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchTripleValueContext() *MatchTripleValueContext {
	var p = new(MatchTripleValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchTripleValue
	return p
}

func InitEmptyMatchTripleValueContext(p *MatchTripleValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchTripleValue
}

func (*MatchTripleValueContext) IsMatchTripleValueContext() {}

func NewMatchTripleValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchTripleValueContext {
	var p = new(MatchTripleValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchTripleValue

	return p
}

func (s *MatchTripleValueContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchTripleValueContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *MatchTripleValueContext) WILDCARD() antlr.TerminalNode {
	return s.GetToken(huloParserWILDCARD, 0)
}

func (s *MatchTripleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchTripleValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchTripleValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchTripleValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchTripleValue() (localctx IMatchTripleValueContext) {
	localctx = NewMatchTripleValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, huloParserRULE_matchTripleValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1926)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserWILDCARD || _la == huloParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchCaseBodyContext is an interface to support dynamic dispatch.
type IMatchCaseBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ReturnStatement() IReturnStatementContext
	Block() IBlockContext

	// IsMatchCaseBodyContext differentiates from other interfaces.
	IsMatchCaseBodyContext()
}

type MatchCaseBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchCaseBodyContext() *MatchCaseBodyContext {
	var p = new(MatchCaseBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchCaseBody
	return p
}

func InitEmptyMatchCaseBodyContext(p *MatchCaseBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchCaseBody
}

func (*MatchCaseBodyContext) IsMatchCaseBodyContext() {}

func NewMatchCaseBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchCaseBodyContext {
	var p = new(MatchCaseBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchCaseBody

	return p
}

func (s *MatchCaseBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchCaseBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MatchCaseBodyContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *MatchCaseBodyContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MatchCaseBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchCaseBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchCaseBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchCaseBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchCaseBody() (localctx IMatchCaseBodyContext) {
	localctx = NewMatchCaseBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, huloParserRULE_matchCaseBody)
	p.SetState(1931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1928)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1929)
			p.ReturnStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1930)
			p.Block()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchDefaultClauseContext is an interface to support dynamic dispatch.
type IMatchDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WILDCARD() antlr.TerminalNode
	DOUBLE_ARROW() antlr.TerminalNode
	MatchCaseBody() IMatchCaseBodyContext

	// IsMatchDefaultClauseContext differentiates from other interfaces.
	IsMatchDefaultClauseContext()
}

type MatchDefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchDefaultClauseContext() *MatchDefaultClauseContext {
	var p = new(MatchDefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchDefaultClause
	return p
}

func InitEmptyMatchDefaultClauseContext(p *MatchDefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_matchDefaultClause
}

func (*MatchDefaultClauseContext) IsMatchDefaultClauseContext() {}

func NewMatchDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchDefaultClauseContext {
	var p = new(MatchDefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_matchDefaultClause

	return p
}

func (s *MatchDefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchDefaultClauseContext) WILDCARD() antlr.TerminalNode {
	return s.GetToken(huloParserWILDCARD, 0)
}

func (s *MatchDefaultClauseContext) DOUBLE_ARROW() antlr.TerminalNode {
	return s.GetToken(huloParserDOUBLE_ARROW, 0)
}

func (s *MatchDefaultClauseContext) MatchCaseBody() IMatchCaseBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchCaseBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchCaseBodyContext)
}

func (s *MatchDefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchDefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchDefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitMatchDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) MatchDefaultClause() (localctx IMatchDefaultClauseContext) {
	localctx = NewMatchDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, huloParserRULE_matchDefaultClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1933)
		p.Match(huloParserWILDCARD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1934)
		p.Match(huloParserDOUBLE_ARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1935)
		p.MatchCaseBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext
	RangeStatement() IRangeStatementContext
	ForStatement() IForStatementContext
	ForeachStatement() IForeachStatementContext
	LoopLabel() ILoopLabelContext

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_loopStatement
	return p
}

func InitEmptyLoopStatementContext(p *LoopStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_loopStatement
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *LoopStatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *LoopStatementContext) RangeStatement() IRangeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeStatementContext)
}

func (s *LoopStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *LoopStatementContext) ForeachStatement() IForeachStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachStatementContext)
}

func (s *LoopStatementContext) LoopLabel() ILoopLabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopLabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopLabelContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLoopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, huloParserRULE_loopStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserIdentifier {
		{
			p.SetState(1937)
			p.LoopLabel()
		}

	}
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1940)
			p.WhileStatement()
		}

	case 2:
		{
			p.SetState(1941)
			p.DoWhileStatement()
		}

	case 3:
		{
			p.SetState(1942)
			p.RangeStatement()
		}

	case 4:
		{
			p.SetState(1943)
			p.ForStatement()
		}

	case 5:
		{
			p.SetState(1944)
			p.ForeachStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopLabelContext is an interface to support dynamic dispatch.
type ILoopLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode

	// IsLoopLabelContext differentiates from other interfaces.
	IsLoopLabelContext()
}

type LoopLabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopLabelContext() *LoopLabelContext {
	var p = new(LoopLabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_loopLabel
	return p
}

func InitEmptyLoopLabelContext(p *LoopLabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_loopLabel
}

func (*LoopLabelContext) IsLoopLabelContext() {}

func NewLoopLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopLabelContext {
	var p = new(LoopLabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_loopLabel

	return p
}

func (s *LoopLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopLabelContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *LoopLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *LoopLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitLoopLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) LoopLabel() (localctx ILoopLabelContext) {
	localctx = NewLoopLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, huloParserRULE_loopLabel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1947)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1948)
		p.Match(huloParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeachStatementContext is an interface to support dynamic dispatch.
type IForeachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	ForeachClause() IForeachClauseContext
	Expression() IExpressionContext
	Block() IBlockContext
	IN() antlr.TerminalNode
	OF() antlr.TerminalNode

	// IsForeachStatementContext differentiates from other interfaces.
	IsForeachStatementContext()
}

type ForeachStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachStatementContext() *ForeachStatementContext {
	var p = new(ForeachStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_foreachStatement
	return p
}

func InitEmptyForeachStatementContext(p *ForeachStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_foreachStatement
}

func (*ForeachStatementContext) IsForeachStatementContext() {}

func NewForeachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachStatementContext {
	var p = new(ForeachStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_foreachStatement

	return p
}

func (s *ForeachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachStatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(huloParserLOOP, 0)
}

func (s *ForeachStatementContext) ForeachClause() IForeachClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachClauseContext)
}

func (s *ForeachStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForeachStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForeachStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(huloParserIN, 0)
}

func (s *ForeachStatementContext) OF() antlr.TerminalNode {
	return s.GetToken(huloParserOF, 0)
}

func (s *ForeachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitForeachStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ForeachStatement() (localctx IForeachStatementContext) {
	localctx = NewForeachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, huloParserRULE_foreachStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1950)
		p.Match(huloParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1951)
		p.ForeachClause()
	}
	{
		p.SetState(1952)
		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserIN || _la == huloParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1953)
		p.Expression()
	}
	{
		p.SetState(1954)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeachClauseContext is an interface to support dynamic dispatch.
type IForeachClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllForeachVariableName() []IForeachVariableNameContext
	ForeachVariableName(i int) IForeachVariableNameContext
	LPAREN() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsForeachClauseContext differentiates from other interfaces.
	IsForeachClauseContext()
}

type ForeachClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachClauseContext() *ForeachClauseContext {
	var p = new(ForeachClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_foreachClause
	return p
}

func InitEmptyForeachClauseContext(p *ForeachClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_foreachClause
}

func (*ForeachClauseContext) IsForeachClauseContext() {}

func NewForeachClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachClauseContext {
	var p = new(ForeachClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_foreachClause

	return p
}

func (s *ForeachClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachClauseContext) AllForeachVariableName() []IForeachVariableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForeachVariableNameContext); ok {
			len++
		}
	}

	tst := make([]IForeachVariableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForeachVariableNameContext); ok {
			tst[i] = t.(IForeachVariableNameContext)
			i++
		}
	}

	return tst
}

func (s *ForeachClauseContext) ForeachVariableName(i int) IForeachVariableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForeachVariableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForeachVariableNameContext)
}

func (s *ForeachClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *ForeachClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, 0)
}

func (s *ForeachClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *ForeachClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitForeachClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ForeachClause() (localctx IForeachClauseContext) {
	localctx = NewForeachClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, huloParserRULE_foreachClause)
	p.SetState(1963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserDOLLAR, huloParserWILDCARD, huloParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1956)
			p.ForeachVariableName()
		}

	case huloParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1957)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1958)
			p.ForeachVariableName()
		}
		{
			p.SetState(1959)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1960)
			p.ForeachVariableName()
		}
		{
			p.SetState(1961)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForeachVariableNameContext is an interface to support dynamic dispatch.
type IForeachVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableName() IVariableNameContext
	VariableExpression() IVariableExpressionContext

	// IsForeachVariableNameContext differentiates from other interfaces.
	IsForeachVariableNameContext()
}

type ForeachVariableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachVariableNameContext() *ForeachVariableNameContext {
	var p = new(ForeachVariableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_foreachVariableName
	return p
}

func InitEmptyForeachVariableNameContext(p *ForeachVariableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_foreachVariableName
}

func (*ForeachVariableNameContext) IsForeachVariableNameContext() {}

func NewForeachVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachVariableNameContext {
	var p = new(ForeachVariableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_foreachVariableName

	return p
}

func (s *ForeachVariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachVariableNameContext) VariableName() IVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *ForeachVariableNameContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *ForeachVariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachVariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachVariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitForeachVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ForeachVariableName() (localctx IForeachVariableNameContext) {
	localctx = NewForeachVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, huloParserRULE_foreachVariableName)
	p.SetState(1967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case huloParserWILDCARD, huloParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1965)
			p.VariableName()
		}

	case huloParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1966)
			p.VariableExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	ForClause() IForClauseContext
	Block() IBlockContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(huloParserLOOP, 0)
}

func (s *ForStatementContext) ForClause() IForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForClauseContext)
}

func (s *ForStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *ForStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, huloParserRULE_forStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1969)
		p.Match(huloParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1971)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1970)
			p.Match(huloParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1973)
		p.ForClause()
	}
	p.SetState(1975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserRPAREN {
		{
			p.SetState(1974)
			p.Match(huloParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1977)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForClauseContext is an interface to support dynamic dispatch.
type IForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSEMI() []antlr.TerminalNode
	SEMI(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	Statement() IStatementContext

	// IsForClauseContext differentiates from other interfaces.
	IsForClauseContext()
}

type ForClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForClauseContext() *ForClauseContext {
	var p = new(ForClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_forClause
	return p
}

func InitEmptyForClauseContext(p *ForClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_forClause
}

func (*ForClauseContext) IsForClauseContext() {}

func NewForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForClauseContext {
	var p = new(ForClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_forClause

	return p
}

func (s *ForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ForClauseContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(huloParserSEMI)
}

func (s *ForClauseContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(huloParserSEMI, i)
}

func (s *ForClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForClauseContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitForClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ForClause() (localctx IForClauseContext) {
	localctx = NewForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, huloParserRULE_forClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6893797309010731670) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&267858078178738181) != 0) {
		{
			p.SetState(1979)
			p.Statement()
		}

	}
	{
		p.SetState(1982)
		p.Match(huloParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1983)
		p.Expression()
	}
	{
		p.SetState(1984)
		p.Match(huloParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1986)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1985)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeStatementContext is an interface to support dynamic dispatch.
type IRangeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	IN() antlr.TerminalNode
	RangeClause() IRangeClauseContext
	Block() IBlockContext

	// IsRangeStatementContext differentiates from other interfaces.
	IsRangeStatementContext()
}

type RangeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeStatementContext() *RangeStatementContext {
	var p = new(RangeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_rangeStatement
	return p
}

func InitEmptyRangeStatementContext(p *RangeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_rangeStatement
}

func (*RangeStatementContext) IsRangeStatementContext() {}

func NewRangeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeStatementContext {
	var p = new(RangeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_rangeStatement

	return p
}

func (s *RangeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeStatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(huloParserLOOP, 0)
}

func (s *RangeStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *RangeStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(huloParserIN, 0)
}

func (s *RangeStatementContext) RangeClause() IRangeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeClauseContext)
}

func (s *RangeStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *RangeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitRangeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) RangeStatement() (localctx IRangeStatementContext) {
	localctx = NewRangeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, huloParserRULE_rangeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		p.Match(huloParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1989)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1990)
		p.Match(huloParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1991)
		p.RangeClause()
	}
	{
		p.SetState(1992)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeClauseContext is an interface to support dynamic dispatch.
type IRangeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RANGE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsRangeClauseContext differentiates from other interfaces.
	IsRangeClauseContext()
}

type RangeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeClauseContext() *RangeClauseContext {
	var p = new(RangeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_rangeClause
	return p
}

func InitEmptyRangeClauseContext(p *RangeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_rangeClause
}

func (*RangeClauseContext) IsRangeClauseContext() {}

func NewRangeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeClauseContext {
	var p = new(RangeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_rangeClause

	return p
}

func (s *RangeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeClauseContext) RANGE() antlr.TerminalNode {
	return s.GetToken(huloParserRANGE, 0)
}

func (s *RangeClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *RangeClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RangeClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *RangeClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *RangeClauseContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *RangeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitRangeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) RangeClause() (localctx IRangeClauseContext) {
	localctx = NewRangeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, huloParserRULE_rangeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1994)
		p.Match(huloParserRANGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1995)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1996)
		p.Expression()
	}
	{
		p.SetState(1997)
		p.Match(huloParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1998)
		p.Expression()
	}
	p.SetState(2001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCOMMA {
		{
			p.SetState(1999)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2000)
			p.Expression()
		}

	}
	{
		p.SetState(2003)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO() antlr.TerminalNode
	Block() IBlockContext
	LOOP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) DO() antlr.TerminalNode {
	return s.GetToken(huloParserDO, 0)
}

func (s *DoWhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DoWhileStatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(huloParserLOOP, 0)
}

func (s *DoWhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserLPAREN, 0)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(huloParserRPAREN, 0)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitDoWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, huloParserRULE_doWhileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2005)
		p.Match(huloParserDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2006)
		p.Block()
	}
	{
		p.SetState(2007)
		p.Match(huloParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2008)
		p.Match(huloParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2009)
		p.Expression()
	}
	{
		p.SetState(2010)
		p.Match(huloParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOP() antlr.TerminalNode
	Block() IBlockContext
	Expression() IExpressionContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(huloParserLOOP, 0)
}

func (s *WhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, huloParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2012)
		p.Match(huloParserLOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2014)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2013)
			p.Expression()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2016)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStatementContext is an interface to support dynamic dispatch.
type IDeferStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	CallExpression() ICallExpressionContext

	// IsDeferStatementContext differentiates from other interfaces.
	IsDeferStatementContext()
}

type DeferStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStatementContext() *DeferStatementContext {
	var p = new(DeferStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_deferStatement
	return p
}

func InitEmptyDeferStatementContext(p *DeferStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_deferStatement
}

func (*DeferStatementContext) IsDeferStatementContext() {}

func NewDeferStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStatementContext {
	var p = new(DeferStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_deferStatement

	return p
}

func (s *DeferStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStatementContext) DEFER() antlr.TerminalNode {
	return s.GetToken(huloParserDEFER, 0)
}

func (s *DeferStatementContext) CallExpression() ICallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallExpressionContext)
}

func (s *DeferStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitDeferStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) DeferStatement() (localctx IDeferStatementContext) {
	localctx = NewDeferStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, huloParserRULE_deferStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2018)
		p.Match(huloParserDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2019)
		p.CallExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareStatementContext is an interface to support dynamic dispatch.
type IDeclareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	Block() IBlockContext
	ClassDeclaration() IClassDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	TraitDeclaration() ITraitDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	ModuleDeclaration() IModuleDeclarationContext
	TypeDeclaration() ITypeDeclarationContext

	// IsDeclareStatementContext differentiates from other interfaces.
	IsDeclareStatementContext()
}

type DeclareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareStatementContext() *DeclareStatementContext {
	var p = new(DeclareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_declareStatement
	return p
}

func InitEmptyDeclareStatementContext(p *DeclareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_declareStatement
}

func (*DeclareStatementContext) IsDeclareStatementContext() {}

func NewDeclareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareStatementContext {
	var p = new(DeclareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_declareStatement

	return p
}

func (s *DeclareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareStatementContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(huloParserDECLARE, 0)
}

func (s *DeclareStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DeclareStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *DeclareStatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *DeclareStatementContext) TraitDeclaration() ITraitDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITraitDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITraitDeclarationContext)
}

func (s *DeclareStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *DeclareStatementContext) ModuleDeclaration() IModuleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclarationContext)
}

func (s *DeclareStatementContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *DeclareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitDeclareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) DeclareStatement() (localctx IDeclareStatementContext) {
	localctx = NewDeclareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, huloParserRULE_declareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2021)
		p.Match(huloParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2029)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2022)
			p.Block()
		}

	case 2:
		{
			p.SetState(2023)
			p.ClassDeclaration()
		}

	case 3:
		{
			p.SetState(2024)
			p.EnumDeclaration()
		}

	case 4:
		{
			p.SetState(2025)
			p.TraitDeclaration()
		}

	case 5:
		{
			p.SetState(2026)
			p.FunctionDeclaration()
		}

	case 6:
		{
			p.SetState(2027)
			p.ModuleDeclaration()
		}

	case 7:
		{
			p.SetState(2028)
			p.TypeDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelInputStatementContext is an interface to support dynamic dispatch.
type IChannelInputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetChannelPayload returns the channelPayload token.
	GetChannelPayload() antlr.Token

	// SetChannelPayload sets the channelPayload token.
	SetChannelPayload(antlr.Token)

	// Getter signatures
	VariableExpression() IVariableExpressionContext
	BACKARROW() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	NumberLiteral() antlr.TerminalNode
	BITAND() antlr.TerminalNode

	// IsChannelInputStatementContext differentiates from other interfaces.
	IsChannelInputStatementContext()
}

type ChannelInputStatementContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	channelPayload antlr.Token
}

func NewEmptyChannelInputStatementContext() *ChannelInputStatementContext {
	var p = new(ChannelInputStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_channelInputStatement
	return p
}

func InitEmptyChannelInputStatementContext(p *ChannelInputStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_channelInputStatement
}

func (*ChannelInputStatementContext) IsChannelInputStatementContext() {}

func NewChannelInputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelInputStatementContext {
	var p = new(ChannelInputStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_channelInputStatement

	return p
}

func (s *ChannelInputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelInputStatementContext) GetChannelPayload() antlr.Token { return s.channelPayload }

func (s *ChannelInputStatementContext) SetChannelPayload(v antlr.Token) { s.channelPayload = v }

func (s *ChannelInputStatementContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *ChannelInputStatementContext) BACKARROW() antlr.TerminalNode {
	return s.GetToken(huloParserBACKARROW, 0)
}

func (s *ChannelInputStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserStringLiteral, 0)
}

func (s *ChannelInputStatementContext) NumberLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserNumberLiteral, 0)
}

func (s *ChannelInputStatementContext) BITAND() antlr.TerminalNode {
	return s.GetToken(huloParserBITAND, 0)
}

func (s *ChannelInputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelInputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelInputStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitChannelInputStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ChannelInputStatement() (localctx IChannelInputStatementContext) {
	localctx = NewChannelInputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, huloParserRULE_channelInputStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2031)
		p.VariableExpression()
	}
	{
		p.SetState(2032)
		p.Match(huloParserBACKARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2033)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ChannelInputStatementContext).channelPayload = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == huloParserNumberLiteral || _la == huloParserStringLiteral) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ChannelInputStatementContext).channelPayload = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserBITAND {
		{
			p.SetState(2034)
			p.Match(huloParserBITAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelOutputExpressionContext is an interface to support dynamic dispatch.
type IChannelOutputExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKARROW() antlr.TerminalNode
	VariableExpression() IVariableExpressionContext

	// IsChannelOutputExpressionContext differentiates from other interfaces.
	IsChannelOutputExpressionContext()
}

type ChannelOutputExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelOutputExpressionContext() *ChannelOutputExpressionContext {
	var p = new(ChannelOutputExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_channelOutputExpression
	return p
}

func InitEmptyChannelOutputExpressionContext(p *ChannelOutputExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_channelOutputExpression
}

func (*ChannelOutputExpressionContext) IsChannelOutputExpressionContext() {}

func NewChannelOutputExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelOutputExpressionContext {
	var p = new(ChannelOutputExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_channelOutputExpression

	return p
}

func (s *ChannelOutputExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelOutputExpressionContext) BACKARROW() antlr.TerminalNode {
	return s.GetToken(huloParserBACKARROW, 0)
}

func (s *ChannelOutputExpressionContext) VariableExpression() IVariableExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableExpressionContext)
}

func (s *ChannelOutputExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelOutputExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelOutputExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitChannelOutputExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ChannelOutputExpression() (localctx IChannelOutputExpressionContext) {
	localctx = NewChannelOutputExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, huloParserRULE_channelOutputExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2037)
		p.Match(huloParserBACKARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2038)
		p.VariableExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsafeExpressionContext is an interface to support dynamic dispatch.
type IUnsafeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsafeLiteral() antlr.TerminalNode

	// IsUnsafeExpressionContext differentiates from other interfaces.
	IsUnsafeExpressionContext()
}

type UnsafeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsafeExpressionContext() *UnsafeExpressionContext {
	var p = new(UnsafeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_unsafeExpression
	return p
}

func InitEmptyUnsafeExpressionContext(p *UnsafeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_unsafeExpression
}

func (*UnsafeExpressionContext) IsUnsafeExpressionContext() {}

func NewUnsafeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsafeExpressionContext {
	var p = new(UnsafeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_unsafeExpression

	return p
}

func (s *UnsafeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsafeExpressionContext) UnsafeLiteral() antlr.TerminalNode {
	return s.GetToken(huloParserUnsafeLiteral, 0)
}

func (s *UnsafeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsafeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsafeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitUnsafeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) UnsafeExpression() (localctx IUnsafeExpressionContext) {
	localctx = NewUnsafeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, huloParserRULE_unsafeExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2040)
		p.Match(huloParserUnsafeLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComptimeExpressionContext is an interface to support dynamic dispatch.
type IComptimeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPTIME() antlr.TerminalNode
	Block() IBlockContext
	WHEN() antlr.TerminalNode
	ConditionalExpression() IConditionalExpressionContext
	AllComptimeCaseClause() []IComptimeCaseClauseContext
	ComptimeCaseClause(i int) IComptimeCaseClauseContext
	ComptimeDefaultClause() IComptimeDefaultClauseContext

	// IsComptimeExpressionContext differentiates from other interfaces.
	IsComptimeExpressionContext()
}

type ComptimeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComptimeExpressionContext() *ComptimeExpressionContext {
	var p = new(ComptimeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comptimeExpression
	return p
}

func InitEmptyComptimeExpressionContext(p *ComptimeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comptimeExpression
}

func (*ComptimeExpressionContext) IsComptimeExpressionContext() {}

func NewComptimeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComptimeExpressionContext {
	var p = new(ComptimeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_comptimeExpression

	return p
}

func (s *ComptimeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComptimeExpressionContext) COMPTIME() antlr.TerminalNode {
	return s.GetToken(huloParserCOMPTIME, 0)
}

func (s *ComptimeExpressionContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ComptimeExpressionContext) WHEN() antlr.TerminalNode {
	return s.GetToken(huloParserWHEN, 0)
}

func (s *ComptimeExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ComptimeExpressionContext) AllComptimeCaseClause() []IComptimeCaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComptimeCaseClauseContext); ok {
			len++
		}
	}

	tst := make([]IComptimeCaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComptimeCaseClauseContext); ok {
			tst[i] = t.(IComptimeCaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *ComptimeExpressionContext) ComptimeCaseClause(i int) IComptimeCaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComptimeCaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComptimeCaseClauseContext)
}

func (s *ComptimeExpressionContext) ComptimeDefaultClause() IComptimeDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComptimeDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComptimeDefaultClauseContext)
}

func (s *ComptimeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComptimeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComptimeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitComptimeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ComptimeExpression() (localctx IComptimeExpressionContext) {
	localctx = NewComptimeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, huloParserRULE_comptimeExpression)
	var _la int

	var _alt int

	p.SetState(2057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2042)
			p.Match(huloParserCOMPTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2043)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2044)
			p.Match(huloParserCOMPTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2045)
			p.Match(huloParserWHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2046)
			p.ConditionalExpression()
		}
		{
			p.SetState(2047)
			p.Block()
		}
		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2048)
					p.ComptimeCaseClause()
				}

			}
			p.SetState(2053)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == huloParserELSE {
			{
				p.SetState(2054)
				p.ComptimeDefaultClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComptimeCaseClauseContext is an interface to support dynamic dispatch.
type IComptimeCaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	WHEN() antlr.TerminalNode
	ConditionalExpression() IConditionalExpressionContext
	Block() IBlockContext

	// IsComptimeCaseClauseContext differentiates from other interfaces.
	IsComptimeCaseClauseContext()
}

type ComptimeCaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComptimeCaseClauseContext() *ComptimeCaseClauseContext {
	var p = new(ComptimeCaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comptimeCaseClause
	return p
}

func InitEmptyComptimeCaseClauseContext(p *ComptimeCaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comptimeCaseClause
}

func (*ComptimeCaseClauseContext) IsComptimeCaseClauseContext() {}

func NewComptimeCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComptimeCaseClauseContext {
	var p = new(ComptimeCaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_comptimeCaseClause

	return p
}

func (s *ComptimeCaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ComptimeCaseClauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(huloParserELSE, 0)
}

func (s *ComptimeCaseClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(huloParserWHEN, 0)
}

func (s *ComptimeCaseClauseContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ComptimeCaseClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ComptimeCaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComptimeCaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComptimeCaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitComptimeCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ComptimeCaseClause() (localctx IComptimeCaseClauseContext) {
	localctx = NewComptimeCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, huloParserRULE_comptimeCaseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2059)
		p.Match(huloParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2060)
		p.Match(huloParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2061)
		p.ConditionalExpression()
	}
	{
		p.SetState(2062)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComptimeDefaultClauseContext is an interface to support dynamic dispatch.
type IComptimeDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE() antlr.TerminalNode
	Block() IBlockContext

	// IsComptimeDefaultClauseContext differentiates from other interfaces.
	IsComptimeDefaultClauseContext()
}

type ComptimeDefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComptimeDefaultClauseContext() *ComptimeDefaultClauseContext {
	var p = new(ComptimeDefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comptimeDefaultClause
	return p
}

func InitEmptyComptimeDefaultClauseContext(p *ComptimeDefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_comptimeDefaultClause
}

func (*ComptimeDefaultClauseContext) IsComptimeDefaultClauseContext() {}

func NewComptimeDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComptimeDefaultClauseContext {
	var p = new(ComptimeDefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_comptimeDefaultClause

	return p
}

func (s *ComptimeDefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ComptimeDefaultClauseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(huloParserELSE, 0)
}

func (s *ComptimeDefaultClauseContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ComptimeDefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComptimeDefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComptimeDefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitComptimeDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ComptimeDefaultClause() (localctx IComptimeDefaultClauseContext) {
	localctx = NewComptimeDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, huloParserRULE_comptimeDefaultClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2064)
		p.Match(huloParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2065)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternDeclarationContext is an interface to support dynamic dispatch.
type IExternDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	ExternList() IExternListContext

	// IsExternDeclarationContext differentiates from other interfaces.
	IsExternDeclarationContext()
}

type ExternDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternDeclarationContext() *ExternDeclarationContext {
	var p = new(ExternDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_externDeclaration
	return p
}

func InitEmptyExternDeclarationContext(p *ExternDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_externDeclaration
}

func (*ExternDeclarationContext) IsExternDeclarationContext() {}

func NewExternDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternDeclarationContext {
	var p = new(ExternDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_externDeclaration

	return p
}

func (s *ExternDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternDeclarationContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(huloParserEXTERN, 0)
}

func (s *ExternDeclarationContext) ExternList() IExternListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternListContext)
}

func (s *ExternDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExternDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExternDeclaration() (localctx IExternDeclarationContext) {
	localctx = NewExternDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, huloParserRULE_externDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2067)
		p.Match(huloParserEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2068)
		p.ExternList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternListContext is an interface to support dynamic dispatch.
type IExternListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExternItem() []IExternItemContext
	ExternItem(i int) IExternItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExternListContext differentiates from other interfaces.
	IsExternListContext()
}

type ExternListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternListContext() *ExternListContext {
	var p = new(ExternListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_externList
	return p
}

func InitEmptyExternListContext(p *ExternListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_externList
}

func (*ExternListContext) IsExternListContext() {}

func NewExternListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternListContext {
	var p = new(ExternListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_externList

	return p
}

func (s *ExternListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternListContext) AllExternItem() []IExternItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternItemContext); ok {
			len++
		}
	}

	tst := make([]IExternItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternItemContext); ok {
			tst[i] = t.(IExternItemContext)
			i++
		}
	}

	return tst
}

func (s *ExternListContext) ExternItem(i int) IExternItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternItemContext)
}

func (s *ExternListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(huloParserCOMMA)
}

func (s *ExternListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(huloParserCOMMA, i)
}

func (s *ExternListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExternList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExternList() (localctx IExternListContext) {
	localctx = NewExternListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, huloParserRULE_externList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2070)
		p.ExternItem()
	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == huloParserCOMMA {
		{
			p.SetState(2071)
			p.Match(huloParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2072)
			p.ExternItem()
		}

		p.SetState(2077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternItemContext is an interface to support dynamic dispatch.
type IExternItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Type_() ITypeContext

	// IsExternItemContext differentiates from other interfaces.
	IsExternItemContext()
}

type ExternItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternItemContext() *ExternItemContext {
	var p = new(ExternItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_externItem
	return p
}

func InitEmptyExternItemContext(p *ExternItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = huloParserRULE_externItem
}

func (*ExternItemContext) IsExternItemContext() {}

func NewExternItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternItemContext {
	var p = new(ExternItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = huloParserRULE_externItem

	return p
}

func (s *ExternItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternItemContext) Identifier() antlr.TerminalNode {
	return s.GetToken(huloParserIdentifier, 0)
}

func (s *ExternItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(huloParserCOLON, 0)
}

func (s *ExternItemContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ExternItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case huloParserVisitor:
		return t.VisitExternItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *huloParser) ExternItem() (localctx IExternItemContext) {
	localctx = NewExternItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, huloParserRULE_externItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2078)
		p.Match(huloParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == huloParserCOLON {
		{
			p.SetState(2079)
			p.Match(huloParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2080)
			p.Type_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
